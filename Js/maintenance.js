/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 54);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(33);

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  typeof document.createElement -> undefined
 */
function isStandardBrowserEnv() {
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined' &&
    typeof document.createElement === 'function'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object' && !isArray(obj)) {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};


/***/ }),
/* 2 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(16);

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 4 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(113)
var ieee754 = __webpack_require__(114)
var isArray = __webpack_require__(38)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 6 */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

var listToStyles = __webpack_require__(68)

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

module.exports = function (parentId, list, _isProduction) {
  isProduction = _isProduction

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[data-vue-ssr-id~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),
/* 8 */
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate
    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var processNextTick = __webpack_require__(12);
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = __webpack_require__(11);
util.inherits = __webpack_require__(6);
/*</replacement>*/

var Readable = __webpack_require__(43);
var Writable = __webpack_require__(47);

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  processNextTick(cb, err);
};

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "../Views/f33df365d6d0255b586f2920355e94d7.eot";

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * vue-nav-tabs v0.5.1
 * (c) 2017-present cristij <joracristi@gmail.com>
 * Released under the MIT License.
 */
(function (global, factory) {
   true ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.vueTabs = global.vueTabs || {})));
}(this, (function (exports) { 'use strict';

var VueTabs = {
    name: 'vue-tabs',
    props: {
        activeTabColor: String,
        activeTextColor: String,
        /**
         * Tab title position: center | bottom | top
         */
        textPosition: {
            type: String,
            default: 'center'
        },
        /**
         * Tab type: tabs | pills
         */
        type: {
            type: String,
            default: 'tabs'
        },
        direction: {
            type: String,
            default: 'horizontal'
        },
        /**
         * Centers the tabs and makes the container div full width
         */
        centered: Boolean,
        value: [String, Number, Object]
    },
    data: function data() {
        return {
            activeTabIndex: 0,
            tabs: []
        };
    },

    computed: {
        isTabShape: function isTabShape() {
            return this.type === 'tabs';
        },
        isStacked: function isStacked() {
            return this.direction === 'vertical';
        },
        classList: function classList() {
            var navType = this.isTabShape ? 'nav-tabs' : 'nav-pills';
            var centerClass = this.centered ? 'nav-justified' : '';
            var isStacked = this.isStacked ? 'nav-stacked' : '';
            return 'nav ' + navType + ' ' + centerClass + ' ' + isStacked;
        },
        stackedClass: function stackedClass() {
            return this.isStacked ? 'stacked' : '';
        },
        activeTabStyle: function activeTabStyle() {
            return {
                backgroundColor: this.activeTabColor,
                color: this.activeTextColor
            };
        }
    },
    methods: {
        navigateToTab: function navigateToTab(index, route) {
            this.changeTab(this.activeTabIndex, index, route);
        },
        activateTab: function activateTab(index) {
            this.activeTabIndex = index;
            var tab = this.tabs[index];
            tab.active = true;
            this.$emit('input', index);
        },
        changeTab: function changeTab(oldIndex, newIndex, route) {
            this.activeTabIndex = newIndex;
            var oldTab = this.tabs[oldIndex];
            var newTab = this.tabs[newIndex];
            oldTab.active = false;
            newTab.active = true;
            //this.$emit('input', newIndex);
            this.$emit('tab-change', newIndex, newTab, oldTab);
            this.tryChangeRoute(route);
        },
        tryChangeRoute: function tryChangeRoute(route) {
            if (this.$router && route) {
                this.$router.push(route);
            }
        },
        addTab: function addTab(item) {
            var index = this.$slots.default.indexOf(item.$vnode);
            this.tabs.splice(index, 0, item);
        },
        removeTab: function removeTab(item) {
            var tabs = this.tabs;
            var index = tabs.indexOf(item);
            if (index > -1) {
                tabs.splice(index, 1);
            }
        },
        getTabs: function getTabs() {
            if (this.$slots.default) {
                return this.$slots.default.filter(function (comp) {
                    return comp.componentOptions;
                });
            }
            return [];
        },
        findTabAndActivate: function findTabAndActivate(tabNameOrIndex) {
            var indexToActivate = this.tabs.findIndex(function (tab, index) {
                return tab.title === tabNameOrIndex || index === tabNameOrIndex;
            });
            if (indexToActivate != -1) {
                this.changeTab(this.activeTabIndex, indexToActivate);
            } else {
                this.changeTab(this.activeTabIndex, 0);
            }
        },
        renderTabTitle: function renderTabTitle(index) {
            var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
            var h = this.$createElement;

            if (this.tabs.length === 0) return;
            var tab = this.tabs[index];
            var active = tab.active,
                title = tab.title;

            var titleStyles = { color: this.activeTabColor };
            if (position === 'center') titleStyles.color = this.activeTextColor;
            var simpleTitle = h(
                'span',
                { 'class': 'title title_' + position, style: active ? titleStyles : {} },
                [position === 'center' && this.renderIcon(index), '\xA0', title]
            );

            if (tab.$slots.title) return tab.$slots.title;
            return simpleTitle;
        },
        renderIcon: function renderIcon(index) {
            var h = this.$createElement;

            if (this.tabs.length === 0) return;
            var tab = this.tabs[index];
            var icon = tab.icon;

            var simpleIcon = h(
                'i',
                { 'class': icon },
                []
            );
            if (!tab.$slots.title && icon) return simpleIcon;
        },
        renderTabs: function renderTabs() {
            var _this = this;

            var h = this.$createElement;

            return this.tabs.map(function (tab, index) {
                if (!tab) return;
                var route = tab.route,
                    id = tab.id,
                    title = tab.title,
                    icon = tab.icon;

                var active = _this.activeTabIndex === index;
                return h(
                    'li',
                    {
                        attrs: { name: 'tab',
                            role: 'presentation' },
                        on: {
                            'click': function click() {
                                return _this.navigateToTab(index, route);
                            }
                        },
                        'class': ['tab', { active: active }],
                        key: title },
                    [_this.textPosition === 'top' && _this.renderTabTitle(index, _this.textPosition), h(
                        'a',
                        {
                            attrs: { href: 'javascript:void(0)',

                                'aria-selected': active,
                                'aria-controls': '#' + id,
                                role: 'tab' },
                            on: {
                                'click': function click() {
                                    return _this.navigateToTab(index);
                                }
                            },

                            style: active ? _this.activeTabStyle : {},
                            'class': { 'active_tab': active } },
                        [_this.textPosition !== 'center' && !tab.$slots.title && _this.renderIcon(index), _this.textPosition === 'center' && _this.renderTabTitle(index, _this.textPosition)]
                    ), _this.textPosition === 'bottom' && _this.renderTabTitle(index, _this.textPosition)]
                );
            });
        }
    },
    render: function render() {
        var h = arguments[0];

        var tabList = this.renderTabs();
        return h(
            'div',
            { 'class': ['vue-tabs', this.stackedClass] },
            [h(
                'div',
                { 'class': [{ 'nav-tabs-navigation': !this.isStacked }, { 'left-vertical-tabs': this.isStacked }] },
                [h(
                    'div',
                    { 'class': ['nav-tabs-wrapper', this.stackedClass] },
                    [h(
                        'ul',
                        { 'class': this.classList, attrs: { role: 'tablist' }
                        },
                        [tabList]
                    )]
                )]
            ), h(
                'div',
                { 'class': ['tab-content', { 'right-text-tabs': this.isStacked }] },
                [this.$slots.default]
            )]
        );
    },

    watch: {
        tabs: function tabs(newList) {
            if (newList.length > 0 && !this.value) {
                this.activateTab(this.activeTabIndex);
            }
            if (newList.length > 0 && this.value) {
                this.findTabAndActivate(this.value);
            }
        },
        value: function value(newVal) {
            this.findTabAndActivate(newVal);
        }
    }
};

var VTab = {
    name: 'v-tab',
    props: {
        title: {
            type: String,
            default: ''
        },
        icon: {
            type: String,
            default: ''
        },
        /***
         * Function to execute before tab switch. Return value must be boolean
         * If the return result is false, tab switch is restricted
         */
        beforeChange: {
            type: Function
        },
        id: String,
        route: {
            type: [String, Object]
        },
        transitionName: String,
        transitionMode: String
    },
    computed: {
        isValidParent: function isValidParent() {
            return this.$parent.$options.name === 'vue-tabs';
        },
        hash: function hash() {
            return '#' + this.id;
        }
    },
    data: function data() {
        return {
            active: false,
            validationError: null
        };
    },
    mounted: function mounted() {
        this.$parent.addTab(this);
    },
    destroyed: function destroyed() {
        if (this.$el && this.$el.parentNode) {
            this.$el.parentNode.removeChild(this.$el);
        }
        this.$parent.removeTab(this);
    },
    render: function render() {
        var h = arguments[0];

        return h(
            'section',
            { 'class': 'tab-container',
                attrs: { role: 'tabpanel' },
                directives: [{
                    name: 'show',
                    value: this.active
                }]
            },
            [this.$slots.default]
        );
    }
};

var VueTabsPlugin = {
  install: function install(Vue) {
    Vue.component('vue-tabs', VueTabs);
    Vue.component('v-tab', VTab);
  }
};
// Automatic installation if Vue has been added to the global scope.
if (typeof window !== 'undefined' && window.Vue) {
  window.Vue.use(VueTabsPlugin);
  window.VueTabs = VueTabsPlugin;
}

exports['default'] = VueTabsPlugin;
exports.VueTabs = VueTabs;
exports.VTab = VTab;

Object.defineProperty(exports, '__esModule', { value: true });

})));

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(15);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"attrs":{"id":"id"}}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(3)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../node_modules/css-loader/index.js!./vue-tabs.css", function() {
			var newContent = require("!!../node_modules/css-loader/index.js!./vue-tabs.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(undefined);
// imports


// module
exports.push([module.i, ".vue-tabs.stacked {\n  display: flex\n}\n\n.vue-tabs a {\n  text-decoration: none;\n  color: gray\n}\n\n.vue-tabs .nav {\n  margin-bottom: 0;\n  margin-top: 0;\n  padding-left: 0;\n  list-style: none\n}\n\n.vue-tabs .nav:before,\n.vue-tabs .nav:after {\n  content: \" \";\n  display: table\n}\n\n.vue-tabs .nav:after {\n  clear: both\n}\n\n.vue-tabs .nav>li {\n  position: relative;\n  display: block\n}\n\n.vue-tabs .nav>li>a {\n  position: relative;\n  display: block;\n  padding: 10px 15px\n}\n\n.vue-tabs .nav>li>a:hover,\n.vue-tabs .nav>li>a:focus {\n  text-decoration: none;\n  background-color: #eee\n}\n\n.vue-tabs .nav>li span.title {\n  display: flex;\n  justify-content: center\n}\n\n.vue-tabs .nav>li.disabled>a {\n  color: #777\n}\n\n.vue-tabs .nav>li.disabled>a:hover,\n.vue-tabs .nav>li.disabled>a:focus {\n  color: #777;\n  text-decoration: none;\n  background-color: transparent;\n  cursor: not-allowed\n}\n\n.vue-tabs .nav .nav-divider {\n  height: 1px;\n  margin: 9px 0;\n  overflow: hidden;\n  background-color: #e5e5e5\n}\n\n.vue-tabs .nav>li>a>img {\n  max-width: none\n}\n\n.vue-tabs .nav-tabs {\n  border-bottom: 1px solid #ddd\n}\n\n.vue-tabs .nav-tabs>li {\n  float: left;\n  margin-bottom: -1px\n}\n\n.vue-tabs .nav-tabs>li>a {\n  margin-right: 2px;\n  line-height: 1.42857;\n  border: 1px solid transparent;\n  border-radius: 4px 4px 0 0\n}\n\n.vue-tabs .nav-tabs>li>a:hover {\n  border-color: #eee #eee #ddd\n}\n\n.vue-tabs .nav-tabs>li.active>a,\n.vue-tabs .nav-tabs>li.active>a:hover,\n.vue-tabs .nav-tabs>li.active>a:focus {\n  color: #fff;\n  background-color: #f0ad4e;\n  border: 1px solid #ddd;\n  border-bottom-color: transparent;\n  cursor: default\n}\n\n.vue-tabs .nav-pills>li {\n  float: left\n}\n\n.vue-tabs .nav-pills>li>a {\n  border-radius: 4px\n}\n\n.vue-tabs .nav-pills>li+li {\n  margin-left: 2px\n}\n\n.vue-tabs .nav-pills>li.active>a,\n.vue-tabs .nav-pills>li.active>a:hover,\n.vue-tabs .nav-pills>li.active>a:focus {\n  color: #fff;\n  background-color: #337ab7\n}\n\n.vue-tabs .nav-stacked>li {\n  float: none\n}\n\n.vue-tabs .nav-stacked>li+li {\n  margin-top: 2px;\n  margin-left: 0\n}\n\n.vue-tabs .nav-justified,\n.vue-tabs .nav-tabs.nav-justified {\n  width: 100%\n}\n\n.vue-tabs .nav-justified>li,\n.vue-tabs .nav-tabs.nav-justified>li {\n  float: none\n}\n\n.vue-tabs .nav-justified>li>a,\n.vue-tabs .nav-tabs.nav-justified>li>a {\n  text-align: center;\n  margin-bottom: 5px\n}\n\n.vue-tabs .nav-justified>.dropdown .dropdown-menu {\n  top: auto;\n  left: auto\n}\n\n@media (min-width: 768px) {\n  .vue-tabs .nav-justified>li,\n  .vue-tabs .nav-tabs.nav-justified>li {\n    display: table-cell;\n    width: 1%\n  }\n  .vue-tabs .nav-justified>li>a,\n  .vue-tabs .nav-tabs.nav-justified>li>a {\n    margin-bottom: 0\n  }\n}\n\n.vue-tabs .nav-tabs-justified,\n.vue-tabs .nav-tabs.nav-justified {\n  border-bottom: 0\n}\n\n.vue-tabs .nav-tabs-justified>li>a,\n.vue-tabs .nav-tabs.nav-justified>li>a {\n  margin-right: 0;\n  border-radius: 4px\n}\n\n.vue-tabs .nav-tabs-justified>.active>a,\n.vue-tabs .nav-tabs.nav-justified>.active>a,\n.vue-tabs .nav-tabs-justified>.active>a:hover,\n.vue-tabs .nav-tabs.nav-justified>.active>a:hover,\n.vue-tabs .nav-tabs-justified>.active>a:focus,\n.vue-tabs .nav-tabs.nav-justified>.active>a:focus {\n  border: 1px solid #ddd\n}\n\n@media (min-width: 768px) {\n  .vue-tabs .nav-tabs-justified>li>a,\n  .vue-tabs .nav-tabs.nav-justified>li>a {\n    border-bottom: 1px solid #ddd;\n    border-radius: 4px 4px 0 0\n  }\n  .vue-tabs .nav-tabs-justified>.active>a,\n  .vue-tabs .nav-tabs.nav-justified>.active>a,\n  .vue-tabs .nav-tabs-justified>.active>a:hover,\n  .vue-tabs .nav-tabs.nav-justified>.active>a:hover,\n  .vue-tabs .nav-tabs-justified>.active>a:focus,\n  .vue-tabs .nav-tabs.nav-justified>.active>a:focus {\n    border-bottom-color: #fff\n  }\n}\n\n.vue-tabs .tab-content>.tab-pane {\n  display: none\n}\n\n.vue-tabs .tab-content>.active {\n  display: block\n}\n\n.vue-tabs section[aria-hidden=\"true\"] {\n  display: none\n}", ""]);

// exports


/***/ }),
/* 16 */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(18);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(3)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../css-loader/index.js!../../less-loader/dist/cjs.js!./simple-line-icons.less", function() {
			var newContent = require("!!../../css-loader/index.js!../../less-loader/dist/cjs.js!./simple-line-icons.less");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(undefined);
// imports


// module
exports.push([module.i, "@font-face {\n  font-family: 'simple-line-icons';\n  src: url(" + __webpack_require__(10) + ");\n  src: url(" + __webpack_require__(10) + "#iefix) format('embedded-opentype'), url(" + __webpack_require__(19) + ") format('woff2'), url(" + __webpack_require__(20) + ") format('truetype'), url(" + __webpack_require__(21) + ") format('woff'), url(" + __webpack_require__(22) + "#simple-line-icons) format('svg');\n  font-weight: normal;\n  font-style: normal;\n}\n/*\n Use the following CSS code if you want to have a class per icon.\n Instead of a list of all class selectors, you can use the generic [class*=\"icon-\"] selector, but it's slower:\n*/\n.icon-user,\n.icon-people,\n.icon-user-female,\n.icon-user-follow,\n.icon-user-following,\n.icon-user-unfollow,\n.icon-login,\n.icon-logout,\n.icon-emotsmile,\n.icon-phone,\n.icon-call-end,\n.icon-call-in,\n.icon-call-out,\n.icon-map,\n.icon-location-pin,\n.icon-direction,\n.icon-directions,\n.icon-compass,\n.icon-layers,\n.icon-menu,\n.icon-list,\n.icon-options-vertical,\n.icon-options,\n.icon-arrow-down,\n.icon-arrow-left,\n.icon-arrow-right,\n.icon-arrow-up,\n.icon-arrow-up-circle,\n.icon-arrow-left-circle,\n.icon-arrow-right-circle,\n.icon-arrow-down-circle,\n.icon-check,\n.icon-clock,\n.icon-plus,\n.icon-minus,\n.icon-close,\n.icon-event,\n.icon-exclamation,\n.icon-organization,\n.icon-trophy,\n.icon-screen-smartphone,\n.icon-screen-desktop,\n.icon-plane,\n.icon-notebook,\n.icon-mustache,\n.icon-mouse,\n.icon-magnet,\n.icon-energy,\n.icon-disc,\n.icon-cursor,\n.icon-cursor-move,\n.icon-crop,\n.icon-chemistry,\n.icon-speedometer,\n.icon-shield,\n.icon-screen-tablet,\n.icon-magic-wand,\n.icon-hourglass,\n.icon-graduation,\n.icon-ghost,\n.icon-game-controller,\n.icon-fire,\n.icon-eyeglass,\n.icon-envelope-open,\n.icon-envelope-letter,\n.icon-bell,\n.icon-badge,\n.icon-anchor,\n.icon-wallet,\n.icon-vector,\n.icon-speech,\n.icon-puzzle,\n.icon-printer,\n.icon-present,\n.icon-playlist,\n.icon-pin,\n.icon-picture,\n.icon-handbag,\n.icon-globe-alt,\n.icon-globe,\n.icon-folder-alt,\n.icon-folder,\n.icon-film,\n.icon-feed,\n.icon-drop,\n.icon-drawer,\n.icon-docs,\n.icon-doc,\n.icon-diamond,\n.icon-cup,\n.icon-calculator,\n.icon-bubbles,\n.icon-briefcase,\n.icon-book-open,\n.icon-basket-loaded,\n.icon-basket,\n.icon-bag,\n.icon-action-undo,\n.icon-action-redo,\n.icon-wrench,\n.icon-umbrella,\n.icon-trash,\n.icon-tag,\n.icon-support,\n.icon-frame,\n.icon-size-fullscreen,\n.icon-size-actual,\n.icon-shuffle,\n.icon-share-alt,\n.icon-share,\n.icon-rocket,\n.icon-question,\n.icon-pie-chart,\n.icon-pencil,\n.icon-note,\n.icon-loop,\n.icon-home,\n.icon-grid,\n.icon-graph,\n.icon-microphone,\n.icon-music-tone-alt,\n.icon-music-tone,\n.icon-earphones-alt,\n.icon-earphones,\n.icon-equalizer,\n.icon-like,\n.icon-dislike,\n.icon-control-start,\n.icon-control-rewind,\n.icon-control-play,\n.icon-control-pause,\n.icon-control-forward,\n.icon-control-end,\n.icon-volume-1,\n.icon-volume-2,\n.icon-volume-off,\n.icon-calendar,\n.icon-bulb,\n.icon-chart,\n.icon-ban,\n.icon-bubble,\n.icon-camrecorder,\n.icon-camera,\n.icon-cloud-download,\n.icon-cloud-upload,\n.icon-envelope,\n.icon-eye,\n.icon-flag,\n.icon-heart,\n.icon-info,\n.icon-key,\n.icon-link,\n.icon-lock,\n.icon-lock-open,\n.icon-magnifier,\n.icon-magnifier-add,\n.icon-magnifier-remove,\n.icon-paper-clip,\n.icon-paper-plane,\n.icon-power,\n.icon-refresh,\n.icon-reload,\n.icon-settings,\n.icon-star,\n.icon-symbol-female,\n.icon-symbol-male,\n.icon-target,\n.icon-credit-card,\n.icon-paypal,\n.icon-social-tumblr,\n.icon-social-twitter,\n.icon-social-facebook,\n.icon-social-instagram,\n.icon-social-linkedin,\n.icon-social-pinterest,\n.icon-social-github,\n.icon-social-google,\n.icon-social-reddit,\n.icon-social-skype,\n.icon-social-dribbble,\n.icon-social-behance,\n.icon-social-foursqare,\n.icon-social-soundcloud,\n.icon-social-spotify,\n.icon-social-stumbleupon,\n.icon-social-youtube,\n.icon-social-dropbox,\n.icon-social-vkontakte,\n.icon-social-steam {\n  font-family: 'simple-line-icons';\n  speak: none;\n  font-style: normal;\n  font-weight: normal;\n  font-variant: normal;\n  text-transform: none;\n  line-height: 1;\n  /* Better Font Rendering =========== */\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n.icon-user:before {\n  content: \"\\E005\";\n}\n.icon-people:before {\n  content: \"\\E001\";\n}\n.icon-user-female:before {\n  content: \"\\E000\";\n}\n.icon-user-follow:before {\n  content: \"\\E002\";\n}\n.icon-user-following:before {\n  content: \"\\E003\";\n}\n.icon-user-unfollow:before {\n  content: \"\\E004\";\n}\n.icon-login:before {\n  content: \"\\E066\";\n}\n.icon-logout:before {\n  content: \"\\E065\";\n}\n.icon-emotsmile:before {\n  content: \"\\E021\";\n}\n.icon-phone:before {\n  content: \"\\E600\";\n}\n.icon-call-end:before {\n  content: \"\\E048\";\n}\n.icon-call-in:before {\n  content: \"\\E047\";\n}\n.icon-call-out:before {\n  content: \"\\E046\";\n}\n.icon-map:before {\n  content: \"\\E033\";\n}\n.icon-location-pin:before {\n  content: \"\\E096\";\n}\n.icon-direction:before {\n  content: \"\\E042\";\n}\n.icon-directions:before {\n  content: \"\\E041\";\n}\n.icon-compass:before {\n  content: \"\\E045\";\n}\n.icon-layers:before {\n  content: \"\\E034\";\n}\n.icon-menu:before {\n  content: \"\\E601\";\n}\n.icon-list:before {\n  content: \"\\E067\";\n}\n.icon-options-vertical:before {\n  content: \"\\E602\";\n}\n.icon-options:before {\n  content: \"\\E603\";\n}\n.icon-arrow-down:before {\n  content: \"\\E604\";\n}\n.icon-arrow-left:before {\n  content: \"\\E605\";\n}\n.icon-arrow-right:before {\n  content: \"\\E606\";\n}\n.icon-arrow-up:before {\n  content: \"\\E607\";\n}\n.icon-arrow-up-circle:before {\n  content: \"\\E078\";\n}\n.icon-arrow-left-circle:before {\n  content: \"\\E07A\";\n}\n.icon-arrow-right-circle:before {\n  content: \"\\E079\";\n}\n.icon-arrow-down-circle:before {\n  content: \"\\E07B\";\n}\n.icon-check:before {\n  content: \"\\E080\";\n}\n.icon-clock:before {\n  content: \"\\E081\";\n}\n.icon-plus:before {\n  content: \"\\E095\";\n}\n.icon-minus:before {\n  content: \"\\E615\";\n}\n.icon-close:before {\n  content: \"\\E082\";\n}\n.icon-event:before {\n  content: \"\\E619\";\n}\n.icon-exclamation:before {\n  content: \"\\E617\";\n}\n.icon-organization:before {\n  content: \"\\E616\";\n}\n.icon-trophy:before {\n  content: \"\\E006\";\n}\n.icon-screen-smartphone:before {\n  content: \"\\E010\";\n}\n.icon-screen-desktop:before {\n  content: \"\\E011\";\n}\n.icon-plane:before {\n  content: \"\\E012\";\n}\n.icon-notebook:before {\n  content: \"\\E013\";\n}\n.icon-mustache:before {\n  content: \"\\E014\";\n}\n.icon-mouse:before {\n  content: \"\\E015\";\n}\n.icon-magnet:before {\n  content: \"\\E016\";\n}\n.icon-energy:before {\n  content: \"\\E020\";\n}\n.icon-disc:before {\n  content: \"\\E022\";\n}\n.icon-cursor:before {\n  content: \"\\E06E\";\n}\n.icon-cursor-move:before {\n  content: \"\\E023\";\n}\n.icon-crop:before {\n  content: \"\\E024\";\n}\n.icon-chemistry:before {\n  content: \"\\E026\";\n}\n.icon-speedometer:before {\n  content: \"\\E007\";\n}\n.icon-shield:before {\n  content: \"\\E00E\";\n}\n.icon-screen-tablet:before {\n  content: \"\\E00F\";\n}\n.icon-magic-wand:before {\n  content: \"\\E017\";\n}\n.icon-hourglass:before {\n  content: \"\\E018\";\n}\n.icon-graduation:before {\n  content: \"\\E019\";\n}\n.icon-ghost:before {\n  content: \"\\E01A\";\n}\n.icon-game-controller:before {\n  content: \"\\E01B\";\n}\n.icon-fire:before {\n  content: \"\\E01C\";\n}\n.icon-eyeglass:before {\n  content: \"\\E01D\";\n}\n.icon-envelope-open:before {\n  content: \"\\E01E\";\n}\n.icon-envelope-letter:before {\n  content: \"\\E01F\";\n}\n.icon-bell:before {\n  content: \"\\E027\";\n}\n.icon-badge:before {\n  content: \"\\E028\";\n}\n.icon-anchor:before {\n  content: \"\\E029\";\n}\n.icon-wallet:before {\n  content: \"\\E02A\";\n}\n.icon-vector:before {\n  content: \"\\E02B\";\n}\n.icon-speech:before {\n  content: \"\\E02C\";\n}\n.icon-puzzle:before {\n  content: \"\\E02D\";\n}\n.icon-printer:before {\n  content: \"\\E02E\";\n}\n.icon-present:before {\n  content: \"\\E02F\";\n}\n.icon-playlist:before {\n  content: \"\\E030\";\n}\n.icon-pin:before {\n  content: \"\\E031\";\n}\n.icon-picture:before {\n  content: \"\\E032\";\n}\n.icon-handbag:before {\n  content: \"\\E035\";\n}\n.icon-globe-alt:before {\n  content: \"\\E036\";\n}\n.icon-globe:before {\n  content: \"\\E037\";\n}\n.icon-folder-alt:before {\n  content: \"\\E039\";\n}\n.icon-folder:before {\n  content: \"\\E089\";\n}\n.icon-film:before {\n  content: \"\\E03A\";\n}\n.icon-feed:before {\n  content: \"\\E03B\";\n}\n.icon-drop:before {\n  content: \"\\E03E\";\n}\n.icon-drawer:before {\n  content: \"\\E03F\";\n}\n.icon-docs:before {\n  content: \"\\E040\";\n}\n.icon-doc:before {\n  content: \"\\E085\";\n}\n.icon-diamond:before {\n  content: \"\\E043\";\n}\n.icon-cup:before {\n  content: \"\\E044\";\n}\n.icon-calculator:before {\n  content: \"\\E049\";\n}\n.icon-bubbles:before {\n  content: \"\\E04A\";\n}\n.icon-briefcase:before {\n  content: \"\\E04B\";\n}\n.icon-book-open:before {\n  content: \"\\E04C\";\n}\n.icon-basket-loaded:before {\n  content: \"\\E04D\";\n}\n.icon-basket:before {\n  content: \"\\E04E\";\n}\n.icon-bag:before {\n  content: \"\\E04F\";\n}\n.icon-action-undo:before {\n  content: \"\\E050\";\n}\n.icon-action-redo:before {\n  content: \"\\E051\";\n}\n.icon-wrench:before {\n  content: \"\\E052\";\n}\n.icon-umbrella:before {\n  content: \"\\E053\";\n}\n.icon-trash:before {\n  content: \"\\E054\";\n}\n.icon-tag:before {\n  content: \"\\E055\";\n}\n.icon-support:before {\n  content: \"\\E056\";\n}\n.icon-frame:before {\n  content: \"\\E038\";\n}\n.icon-size-fullscreen:before {\n  content: \"\\E057\";\n}\n.icon-size-actual:before {\n  content: \"\\E058\";\n}\n.icon-shuffle:before {\n  content: \"\\E059\";\n}\n.icon-share-alt:before {\n  content: \"\\E05A\";\n}\n.icon-share:before {\n  content: \"\\E05B\";\n}\n.icon-rocket:before {\n  content: \"\\E05C\";\n}\n.icon-question:before {\n  content: \"\\E05D\";\n}\n.icon-pie-chart:before {\n  content: \"\\E05E\";\n}\n.icon-pencil:before {\n  content: \"\\E05F\";\n}\n.icon-note:before {\n  content: \"\\E060\";\n}\n.icon-loop:before {\n  content: \"\\E064\";\n}\n.icon-home:before {\n  content: \"\\E069\";\n}\n.icon-grid:before {\n  content: \"\\E06A\";\n}\n.icon-graph:before {\n  content: \"\\E06B\";\n}\n.icon-microphone:before {\n  content: \"\\E063\";\n}\n.icon-music-tone-alt:before {\n  content: \"\\E061\";\n}\n.icon-music-tone:before {\n  content: \"\\E062\";\n}\n.icon-earphones-alt:before {\n  content: \"\\E03C\";\n}\n.icon-earphones:before {\n  content: \"\\E03D\";\n}\n.icon-equalizer:before {\n  content: \"\\E06C\";\n}\n.icon-like:before {\n  content: \"\\E068\";\n}\n.icon-dislike:before {\n  content: \"\\E06D\";\n}\n.icon-control-start:before {\n  content: \"\\E06F\";\n}\n.icon-control-rewind:before {\n  content: \"\\E070\";\n}\n.icon-control-play:before {\n  content: \"\\E071\";\n}\n.icon-control-pause:before {\n  content: \"\\E072\";\n}\n.icon-control-forward:before {\n  content: \"\\E073\";\n}\n.icon-control-end:before {\n  content: \"\\E074\";\n}\n.icon-volume-1:before {\n  content: \"\\E09F\";\n}\n.icon-volume-2:before {\n  content: \"\\E0A0\";\n}\n.icon-volume-off:before {\n  content: \"\\E0A1\";\n}\n.icon-calendar:before {\n  content: \"\\E075\";\n}\n.icon-bulb:before {\n  content: \"\\E076\";\n}\n.icon-chart:before {\n  content: \"\\E077\";\n}\n.icon-ban:before {\n  content: \"\\E07C\";\n}\n.icon-bubble:before {\n  content: \"\\E07D\";\n}\n.icon-camrecorder:before {\n  content: \"\\E07E\";\n}\n.icon-camera:before {\n  content: \"\\E07F\";\n}\n.icon-cloud-download:before {\n  content: \"\\E083\";\n}\n.icon-cloud-upload:before {\n  content: \"\\E084\";\n}\n.icon-envelope:before {\n  content: \"\\E086\";\n}\n.icon-eye:before {\n  content: \"\\E087\";\n}\n.icon-flag:before {\n  content: \"\\E088\";\n}\n.icon-heart:before {\n  content: \"\\E08A\";\n}\n.icon-info:before {\n  content: \"\\E08B\";\n}\n.icon-key:before {\n  content: \"\\E08C\";\n}\n.icon-link:before {\n  content: \"\\E08D\";\n}\n.icon-lock:before {\n  content: \"\\E08E\";\n}\n.icon-lock-open:before {\n  content: \"\\E08F\";\n}\n.icon-magnifier:before {\n  content: \"\\E090\";\n}\n.icon-magnifier-add:before {\n  content: \"\\E091\";\n}\n.icon-magnifier-remove:before {\n  content: \"\\E092\";\n}\n.icon-paper-clip:before {\n  content: \"\\E093\";\n}\n.icon-paper-plane:before {\n  content: \"\\E094\";\n}\n.icon-power:before {\n  content: \"\\E097\";\n}\n.icon-refresh:before {\n  content: \"\\E098\";\n}\n.icon-reload:before {\n  content: \"\\E099\";\n}\n.icon-settings:before {\n  content: \"\\E09A\";\n}\n.icon-star:before {\n  content: \"\\E09B\";\n}\n.icon-symbol-female:before {\n  content: \"\\E09C\";\n}\n.icon-symbol-male:before {\n  content: \"\\E09D\";\n}\n.icon-target:before {\n  content: \"\\E09E\";\n}\n.icon-credit-card:before {\n  content: \"\\E025\";\n}\n.icon-paypal:before {\n  content: \"\\E608\";\n}\n.icon-social-tumblr:before {\n  content: \"\\E00A\";\n}\n.icon-social-twitter:before {\n  content: \"\\E009\";\n}\n.icon-social-facebook:before {\n  content: \"\\E00B\";\n}\n.icon-social-instagram:before {\n  content: \"\\E609\";\n}\n.icon-social-linkedin:before {\n  content: \"\\E60A\";\n}\n.icon-social-pinterest:before {\n  content: \"\\E60B\";\n}\n.icon-social-github:before {\n  content: \"\\E60C\";\n}\n.icon-social-google:before {\n  content: \"\\E60D\";\n}\n.icon-social-reddit:before {\n  content: \"\\E60E\";\n}\n.icon-social-skype:before {\n  content: \"\\E60F\";\n}\n.icon-social-dribbble:before {\n  content: \"\\E00D\";\n}\n.icon-social-behance:before {\n  content: \"\\E610\";\n}\n.icon-social-foursqare:before {\n  content: \"\\E611\";\n}\n.icon-social-soundcloud:before {\n  content: \"\\E612\";\n}\n.icon-social-spotify:before {\n  content: \"\\E613\";\n}\n.icon-social-stumbleupon:before {\n  content: \"\\E614\";\n}\n.icon-social-youtube:before {\n  content: \"\\E008\";\n}\n.icon-social-dropbox:before {\n  content: \"\\E00C\";\n}\n.icon-social-vkontakte:before {\n  content: \"\\E618\";\n}\n.icon-social-steam:before {\n  content: \"\\E620\";\n}\n", ""]);

// exports


/***/ }),
/* 19 */
/***/ (function(module, exports) {

module.exports = "data:application/font-woff2;base64,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"

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "../Views/d2285965fe34b05465047401b8595dd0.ttf";

/***/ }),
/* 21 */
/***/ (function(module, exports) {

module.exports = "data:application/font-woff;base64,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"

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "../Views/2fe2efe63441d830b1acd106c1fe8734.svg";

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
let MenuGrid = __webpack_require__(24);

function gridInit( _addOrderCallback ) {
    //TODO: esta lista deberia ser una lista de objetos con el nombre y el id de la categoria
    var categorias = ["carnes", "arroz", "ensaladas", "entradas", "postres"]
    var productos = ["tiramisu", "brownie", "helado", "pastel"]
    var alter = [
        {
            id: '1', value: 'carnes', children: [
                { id: '12', value: 'hamburguesa' },
                { id: '13', value: 'filet' },
                { id: '14', value: 'pescado' },
                { id: '15', value: 'pollo' }
            ]
        },
        {
            id: '2', value: 'arroz', children: [
                { id: '22', value: 'arroz frito' },
                { id: '23', value: 'arroz con coco' },
                { id: '24', value: 'chino' },
                { id: '25', value: 'arroz y salsa' }
            ]
        },
        { id: '3', value: 'ensaladas' },
        { id: '4', value: 'entradas' },
        { id: '5', value: 'postres' }
    ];

    var grid = new MenuGrid.MenuGridComponent(3, 4, alter);

    grid.rowsDef = {
        autoRows: true,
        height: 'auto',
        minmax: '80px'
    };

    // si los items enviados no son texto o numero hay que crear un dataformatter
    grid.itemsDef.dataFormatter = function (item) {
        // este formater es exclusivo para los objetos de alter
        return item.value;
    }

    // evento que se ejecuta cuando uno de los divs internos recibe un click
    grid.columnsDef.itemsCallback = (function (event, item) {
        if (item.children) {
            this.updateContent(item.children);
        } else { // no children
            // TODO: Make this return callback to decouple logic
            if(_addOrderCallback) {
                _addOrderCallback( item );
            } else {
                alert('no active client');
            }
        }
    }).bind(grid);

    grid.actionsDef = [{
        value: 'Atras',
        action: function () {
            grid.updateContent(alter);
        }
    }];

    // si create no tiene parametros usa la configuracion por defecto
    var gridElement = grid.create();
    grid.toString();


    var container = document.getElementById("container");
    container.appendChild(gridElement);

    //

    return grid;
}

/* harmony default export */ __webpack_exports__["a"] = ({ gridInit });

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MenuGridComponent", function() { return MenuGridComponent; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__menu_grid_css__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__menu_grid_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__menu_grid_css__);


function MenuGrid(columns, rows, items) {
    this.domElement;
    this.columns = columns;
    this.rows = rows;
    this.items = items;
    this.itemsDef = {
        dataFormatter: function (item) {
            if (typeof (item) === 'string' || typeof (item) === 'number') {
                return item;
            }
        }
    };
    
    this.rowsDef = {
        autoRows: false,
        height: 'auto',
        minmax: '80px'
    };
    
    this.columnsDef = {
        width: 'auto'
    };

    this.defaultProps = {
        columns: 1,
        rows: 0,
        rowsDef: {
            autoRows: false,
            height: 'auto',
            minmax: '80px'
        },
        columnsDef: {
            width: 'auto'
        }
    }
}

MenuGrid.prototype.create = function (gridConfiguration) {
    let gConf = gridConfiguration || this.defaultProps;

    if (!gridConfiguration) {
        gConf.columns = this.columns || this.defaultProps.columns;
        gConf.rows = this.rows || this.defaultProps.rows;
        gConf.rowsDef = this.rowsDef || this.defaultProps.rowsDef;
    }

    let grid = {
        columns: gConf.columns || this.columns,
        rows: gConf.rows || this.rows,
        items: gConf.items || this.items || [],
        rowsDef: gConf.rowsDef || this.defaultProps.rowsDef,
        columnsDef: gConf.columnsDef || this.defaultProps.columnsDef,
        actionsDef: gConf.actionsDef || this.actionsDef
    }

    this.domElement = this.generateDom(grid);
    return this.domElement;
}

MenuGrid.prototype.valueFormatterCallback = function (item) {
    if (this.itemsDef && this.itemsDef.dataFormatter) {
        return this.itemsDef.dataFormatter(item);
    } else {
        return item;
    }
}


MenuGrid.prototype.createContentContainer = function (gridConfiguration) {
    let cols = gridConfiguration.columns;
    let rows = gridConfiguration.rows;

    let grid = document.createElement('div');
    grid.classList.add('grid-container');
    let styles = `
        display: grid;
        grid-gap: 10px;
    `;
    let stylesCol = `grid-template-columns: repeat(${cols}, 1fr);`;
    let stylesRows = '';
    if (gridConfiguration.rowsDef.autoRows) {
        stylesRows += `grid-auto-rows: minmax(${gridConfiguration.rowsDef.minmax}, auto);`;
    } else {
        stylesRows += `grid-template-rows: repeat(${rows}, 1fr);`
    }

    grid.setAttribute('style', [styles, stylesCol, stylesRows].join(';'));

    return { grid, styles, stylesCol, stylesRows };
}

MenuGrid.prototype.createContent = function (gridContentDomElement, items) {
    if (items) {
        items.forEach((element) => {
            let gItem = document.createElement('div');
            gItem.setAttribute('clickable', 'true');
            gItem.data = element;
            gItem.classList.add(['grid-cell']);
            if (this.valueFormatterCallback) {
                gItem.innerText = this.valueFormatterCallback(element);
            }

            gridContentDomElement.appendChild(gItem);
        });
    }
}

MenuGrid.prototype.updateContent = function (items) {
    let content = this.domElement.querySelector('.grid-container');
    this.clearContent();
    this.createContent(content, items);
}

MenuGrid.prototype.createActions = function (actionsDef, styles, stylesCol) {
    let actionsRow = document.createElement('div');

    actionsRow.classList.add(['grid-actions']);
    let actions = actionsDef;

    if (actions && actions.length) {
        actions.forEach((action) => {
            let gItem = document.createElement('div');
            gItem.data = action;
            gItem.classList.add(['action-cell']);
            gItem.innerText = action.value;
            gItem.addEventListener('click', function () {
                action.action();
            });

            actionsRow.appendChild(gItem);
        });
    }

    actionsRow.setAttribute('style', [styles, stylesCol].join(';'));

    return actionsRow;
}


MenuGrid.prototype.generateDom = function (gridConfiguration) {

    let gridProps = this.createContentContainer(gridConfiguration);
    let content = this.createContent(gridProps.grid, gridConfiguration.items);
    let actionsRow = this.createActions(gridConfiguration.actionsDef,
        gridProps.styles, gridProps.stylesCol);

    // event listeners
    gridProps.grid.addEventListener('click', (event) => {
        if (event.target && event.target.hasAttribute('clickable')) {
            if (typeof (this.itemsCallback) === 'function') {
                this.itemsCallback(event, event.target.data);
            }
        }
    }, true);


    let wrapper = document.createElement('div');
    wrapper.classList.add(['grid-wrapper']);

    wrapper.appendChild(gridProps.grid);
    wrapper.appendChild(actionsRow);

    return wrapper;
}

MenuGrid.prototype.clearContent = function () {
    let content = this.domElement.querySelector('.grid-container');
    content.innerHTML = '';
}

MenuGrid.prototype.itemsCallback = function () {
    if (this.columnsDef && typeof (this.columnsDef.itemsCallback) === 'function') {
        this.columnsDef.itemsCallback(event, event.target.data);
    }
}

MenuGrid.prototype.toString = function () {
    
}

let MenuGridComponent = MenuGrid;



/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(26);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"attrs":{"id":"id"}}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(3)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../node_modules/css-loader/index.js!./menu-grid.css", function() {
			var newContent = require("!!../../node_modules/css-loader/index.js!./menu-grid.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(undefined);
// imports


// module
exports.push([module.i, ".grid-wrapper {\n    width: 100%;\n}\n\n.grid-wrapper > .grid-container > .grid-cell {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    overflow: hidden;\n    word-break: break-word;\n    padding: 5px;\n    box-sizing: border-box;\n    user-select: none;\n    cursor: pointer;\n}\n\n.grid-wrapper > .grid-container > .grid-cell:nth-child(even) {\n    background-color: #d6edc5;\n}\n\n.grid-wrapper > .grid-container > .grid-cell:nth-child(odd) {\n    background-color: green;\n}\n\n.grid-actions {\n    margin-top: 10px;\n}\n\n.grid-actions > .action-cell {\n    height: 80px;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    overflow: hidden;\n    word-break: break-word;\n    padding: 5px;\n    box-sizing: border-box;\n    background-color: rosybrown;\n    user-select: none;\n    cursor: pointer;\n}", ""]);

// exports


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";


let ClientsService = function () {
    this.clients = [];
}

ClientsService.prototype.buildClient = function (_name) {

    let _client = {
        id: this.clients.length + 1,
        name: _name,
        orders: []
    };

    return _client;
}

ClientsService.prototype.addClient = function (_client) {
    this.clients.push(_client);
}

ClientsService.prototype.createClient = function (_name) {
    let client = this.buildClient(_name);
    this.addClient(client);
    return client;
}

ClientsService.prototype.addOrderToClient = function (_client, _order) {
    let found = _client.orders.filter(order => {
        return order.id == _order.id;
    });

    if (found.length > 0) {
        found[0].amount = found[0].amount + 1;
    } else {
        _order.amount = 1;
        _client.orders.push(_order);
    }
}

ClientsService.prototype.substractOrderToClient = function (_client, _order) {
    let found = _client.orders.filter(order => {
        return order.id == _order.id;
    });

    if (found.length > 0) {
        if(_order.amount == 1){
            _client.orders.splice( _client.orders.indexOf(_order), 1);
        } else {
            found[0].amount = found[0].amount - 1;
        }
    }
}


let service = new ClientsService();

/* harmony default export */ __webpack_exports__["a"] = ({ service });



/***/ }),
/* 28 */
/***/ (function(module, exports) {

Vue.component('inline-edit', {
    props: [
        'text'
    ],
    template: `
            <div>
                <span v-if="!editVisible">
                    {{text}}
                    <span v-on:click="editVisible = true">&#9998;</span>
                </span>
                <div v-if="editVisible">
                    <input type="text" v-model="text">
                    <span v-on:click="updateText()">&#10004;</span>
                </div>
            </div>
        `,
    data: function () {
        return {
            editVisible: false
        }
    },
    methods: {
        updateText: function () {
            this.editVisible = false;
            this.$emit('changed', this.text);
        }
    }
});

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(64);
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;


/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vue_loader_lib_selector_type_script_index_0_Vuetable_vue__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vue_loader_lib_template_compiler_index_id_data_v_b0ab162c_hasScoped_true_vue_loader_lib_selector_type_template_index_0_Vuetable_vue__ = __webpack_require__(91);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(70)
}
var normalizeComponent = __webpack_require__(8)
/* script */

/* template */

/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = "data-v-b0ab162c"
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__vue_loader_lib_selector_type_script_index_0_Vuetable_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__vue_loader_lib_template_compiler_index_id_data_v_b0ab162c_hasScoped_true_vue_loader_lib_selector_type_template_index_0_Vuetable_vue__["a" /* default */],
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "node_modules/vuetable-2/src/components/Vuetable.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] Vuetable.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-b0ab162c", Component.options)
  } else {
    hotAPI.reload("data-v-b0ab162c", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(1);
var normalizeHeaderName = __webpack_require__(76);

var PROTECTION_PREFIX = /^\)\]\}',?\n/;
var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(34);
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(34);
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      data = data.replace(PROTECTION_PREFIX, '');
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMehtodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(5)
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(1);
var settle = __webpack_require__(77);
var buildURL = __webpack_require__(79);
var parseHeaders = __webpack_require__(80);
var isURLSameOrigin = __webpack_require__(81);
var createError = __webpack_require__(35);
var btoa = (typeof window !== 'undefined' && window.btoa && window.btoa.bind(window)) || __webpack_require__(82);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if (process.env.NODE_ENV !== 'test' &&
        typeof window !== 'undefined' &&
        window.XDomainRequest && !('withCredentials' in request) &&
        !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || (request.readyState !== 4 && !xDomain)) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/mzabriskie/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED'));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(83);

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ?
          cookies.read(config.xsrfCookieName) :
          undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        if (request.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(78);

/**
 * Create an Error with the specified message, config, error code, and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 @ @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, response);
};


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),
/* 38 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(117);
var util = __webpack_require__(119);

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(120);

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var ClientRequest = __webpack_require__(123)
var extend = __webpack_require__(130)
var statusCodes = __webpack_require__(131)
var url = __webpack_require__(39)

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

exports.vbArray = isFunction(global.VBArray)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(43);
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(47);
exports.Duplex = __webpack_require__(9);
exports.Transform = __webpack_require__(49);
exports.PassThrough = __webpack_require__(128);


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var processNextTick = __webpack_require__(12);
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(38);
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(44).EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(45);
/*</replacement>*/

// TODO(bmeurer): Change this back to const once hole checks are
// properly optimized away early in Ignition+TurboFan.
/*<replacement>*/
var Buffer = __webpack_require__(32).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(11);
util.inherits = __webpack_require__(6);
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(125);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(126);
var destroyImpl = __webpack_require__(46);
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(9);

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(48).StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(9);

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(48).StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(4)))

/***/ }),
/* 44 */
/***/ (function(module, exports) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(44).EventEmitter;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var processNextTick = __webpack_require__(12);
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      processNextTick(emitErrorNT, this, err);
    }
    return;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      processNextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var processNextTick = __webpack_require__(12);
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = __webpack_require__(11);
util.inherits = __webpack_require__(6);
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(127)
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(45);
/*</replacement>*/

/*<replacement>*/
var Buffer = __webpack_require__(32).Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

var destroyImpl = __webpack_require__(46);

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(9);

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(9);

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = _isUint8Array(chunk) && !state.objectMode;

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    processNextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    processNextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      processNextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(29).setImmediate, __webpack_require__(2)))

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = __webpack_require__(5).Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(9);

/*<replacement>*/
var util = __webpack_require__(11);
util.inherits = __webpack_require__(6);
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return stream.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),
/* 50 */
/***/ (function(module, exports) {

function webpackEmptyContext(req) {
	throw new Error("Cannot find module '" + req + "'.");
}
webpackEmptyContext.keys = function() { return []; };
webpackEmptyContext.resolve = webpackEmptyContext;
module.exports = webpackEmptyContext;
webpackEmptyContext.id = 50;

/***/ }),
/* 51 */,
/* 52 */,
/* 53 */,
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__maintenance_styles_less__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__maintenance_styles_less___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__maintenance_styles_less__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_simple_line_icons_less_simple_line_icons_less__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_simple_line_icons_less_simple_line_icons_less___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__node_modules_simple_line_icons_less_simple_line_icons_less__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vuetable_2__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_vuetable_2___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_vuetable_2__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__maintenance_components_home_vue__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__maintenance_components_categories_vue__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__maintenance_components_dishes_vue__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__maintenance_components_menu_vue__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__maintenance_components_salon_vue__ = __webpack_require__(108);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__maintenance_components_configuration_vue__ = __webpack_require__(138);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__maintenance_services_api_service__ = __webpack_require__(135);



Vue.use(__WEBPACK_IMPORTED_MODULE_2_vuetable_2___default.a);
Vue.use(VueRouter)









const Ingredients = { template: '<div>Ingredientes</div>' }

let api = new __WEBPACK_IMPORTED_MODULE_9__maintenance_services_api_service__["a" /* default */]();
let categories = api.categories;
let dishes = api.dishes;

const router = new VueRouter({
  routes: [
    { path: '/', component: __WEBPACK_IMPORTED_MODULE_3__maintenance_components_home_vue__["a" /* default */] },
    { path: '/categorias', component: __WEBPACK_IMPORTED_MODULE_4__maintenance_components_categories_vue__["a" /* default */]},
    { path: '/platillos', component: __WEBPACK_IMPORTED_MODULE_5__maintenance_components_dishes_vue__["a" /* default */] },
    { path: '/menu', component: __WEBPACK_IMPORTED_MODULE_6__maintenance_components_menu_vue__["a" /* default */] },
    { path: '/salon', component: __WEBPACK_IMPORTED_MODULE_7__maintenance_components_salon_vue__["a" /* default */] },
    { path: '/configuration', component: __WEBPACK_IMPORTED_MODULE_8__maintenance_components_configuration_vue__["a" /* default */] },
  ]
})

const app = new Vue({
  router,
  data: {
    localCategories: categories,
    localDishes: dishes,
    localTables: [],
    localFloor: {
      name:'Salon 1',
      backgroundColor: "#FAF7F8",
      size: {
        width: 500,
        height: 500
      }
    }
  },
  created: function() {
    this.$on('save:configuration', ( _tablesConfiguration, _floorConfiguration) => {
      console.log( _tablesConfiguration, _floorConfiguration );
      this.localTables = _tablesConfiguration;
      this.loalFloor = _floorConfiguration;
    })
  },
  methods: {
    tablesListener: function( args) {
      console.log( args );
    }
  }
}).$mount('#app')

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(56);
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(3)(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../node_modules/css-loader/index.js!../node_modules/less-loader/dist/cjs.js!./styles.less", function() {
			var newContent = require("!!../node_modules/css-loader/index.js!../node_modules/less-loader/dist/cjs.js!./styles.less");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(undefined);
// imports


// module
exports.push([module.i, "@font-face {\n  font-family: 'Roboto';\n  src: local('Roboto Light'), local('Roboto-Light'), url(" + __webpack_require__(57) + ") format('woff2'), url(" + __webpack_require__(58) + ") format('woff'), url(" + __webpack_require__(59) + ") format('truetype');\n  font-weight: 300;\n  font-style: normal;\n}\n@font-face {\n  font-family: 'Roboto';\n  src: local('Roboto'), local('Roboto-Regular'), url(" + __webpack_require__(60) + ") format('woff2'), url(" + __webpack_require__(61) + ") format('woff'), url(" + __webpack_require__(62) + ") format('truetype');\n  font-weight: 400;\n  font-style: normal;\n}\n* {\n  font-weight: 300;\n}\nhtml,\nbody {\n  font-family: 'Roboto', sans-serif;\n}\nhtml .bg-primary,\nbody .bg-primary {\n  background-color: #009688 !important;\n}\nhtml nav a,\nbody nav a,\nhtml nav a:active,\nbody nav a:active,\nhtml nav a:hover,\nbody nav a:hover {\n  color: rgba(255, 255, 255, 0.87);\n}\nhtml a,\nbody a,\nhtml a:active,\nbody a:active,\nhtml a:hover,\nbody a:hover {\n  color: rgba(0, 0, 0, 0.87);\n}\nhtml .navbar-toggler-icon,\nbody .navbar-toggler-icon {\n  font-family: 'simple-line-icons';\n  speak: none;\n  font-style: normal;\n  font-weight: normal;\n  font-variant: normal;\n  text-transform: none;\n  line-height: 1;\n  -webkit-font-smoothing: antialiased;\n  color: rgba(255, 255, 255, 0.87);\n}\nhtml .navbar-toggler-icon:before,\nbody .navbar-toggler-icon:before {\n  content: \"\\E601\";\n  display: flex;\n  width: 100%;\n  height: 100%;\n  justify-content: center;\n  align-items: center;\n}\nhtml .main,\nbody .main {\n  margin: 20px;\n}\n", ""]);

// exports


/***/ }),
/* 57 */
/***/ (function(module, exports) {

module.exports = "data:application/font-woff2;base64,d09GMgABAAAAAGtUABEAAAAA8PQAAGrzAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGhYbwHQcUAZgAIQoCIEeCZdiEQgKgstYgq1qATYCJAOLWAuFbgAEIAWJMweWYwyBMRvs3VdwblN+fFSl3uDFbp9fK0EK5OZHcreSuUQEaDaicjuIopDvW7P///9PSzrGKEY6QPVTq/oroWZmmoOFFwaSQWRtNdBDwsVYkEK1y5/aXOngWe6OPcpQ5valMmEty/A4HQiWrFIlVcquXxhwZ/j0IjcspxDtmDEJ93/9KcNtoB/SHsV8c7vUX+1i2GUK0ZFIJGFJyKvPDV+alu2Z9iMQqTDZZ+PZ7yGuBHQqVswIRCLhpQHlEmoFvLNCWyYvmphwQkhjDDBxOZVf8aUG1K1TiQSnWpjj+ZYkXz4hp1pNJTM5NVu7h1Tk4Xn/3m+dqxdAVVJ+kRUGcA2hAyuwHLeAy0z2D/zcev+vYYwaIyUcnQMVpENKPSZMTEKQ4WaDh1IDRrZ1OgOYWJhBCqKCgEg7+hr/X3V9kgPgdyUb/xy2aHNR7tnKgYHJkD0hg/waaKHemDIwPP/9Gv+2Tt9zbvdLWH8XlfIpjzQEmsgO2xgxKByxtEBqqnoPwNwKxMA8dYgStQFja5YwGKyiYVFsYyPSJo0CPcVo7Lrw0rprT/s+L/LTwTb7L1CKFUlCCFo8SGEorY+n74vp6nnPx5mnl9vC86SzfH9II5lWBtKCDHRaBh3ghMhB6Lhp0lUpykCFtrJrQLM6eGCwI8BchiCzfe73fmKTqVDALImSG1mSaB8oX/qgCwwnZ0sAN1bjzbmEN2/17pEKDzhKUxgkHQzMcwq5yD4YAQUQkP8BAAfrHIT2UIWqPXaohHZH52jmF4n5RgsA+C+XKtlOaXVnz2VfCPojmlp1KcMTzAKpOwAACjb0j7aUitJhNU/5AdJ24Q3pyAhSUHtnu6hd1NtVow3736uaf8654QEkpd1MQrJFOqREcaM0cAocmD9h4VRpMFRX/qZRue/zp0kqugyM1ZhONZl055xv/HdQm39VzRWgbNPyNel6ui/pU3+7JNpOmVoZ9uz8DeTHB0gDIClW01TxmaKcOxbJpij7ABDUgSCloyTfi3zVTmlVpGSfJV1zSanl7bVvyZZpTLYMa8YtL/D/teyV9lFuhYjE1EyfaQAVFgQzb1elvTtKozxK+SmPHMefISPmdm7nsTPTQpWhITdAwMjzv9/Peh/m8dOkQYLQ9HTIkIKZNFWZyrtT8HdnioiniUnX5L3/v8Ta0kIN88v9KjuzncUsocM2fte66df/Z6CTJcoRKiY15wCFPCNZorw6R0Tx9wykyR6gtWf3bTFKAtEgkILMCawHcXJpeQAVHIwQaZpydm3RdiqzEBYHhmEYHaHQTel6pTb/HWY5D2bjPZpdUsv1XNTLUEoR/aJ/0ReKXM+dnqQdxtSouNKV69qXIaAoqCwVBZXY/O9SCWhiKjOIR15AHOfWQJUhZPXrPiFAhAXEhjObzvhC8uG7EljnBAsFCpSq7BI++xIkuYXGHjrOpbVyKKSjRKyxfDNW+KAQN1zZDKqzpeAoWJXVdObxE5jsbfPW3mV1Wmu8vadBU8HuJ9CKm3sQeIxCZ7COFR9PKo7uTwAm8SSTFZuSmrjKTW/zlM8sdXAQ52YA5QOXUwk83fPYN4x3jZjRc0LepvqY5j7cczOo5WGNo+DO3CgLtsyjYruRebED+ytLkkM+PrisMzV1y7HLRvM0yRzNgGVN3EMfB+MsUIYrlmhTBqMxm3V5E8vnrib9b4iHqIFFIo1OkxZtOnTpM2DEmAlTZsxZs2WHwZ4DZy7cefDiL0CgICHCRYqSKNkRKVIdlYYt3TEcXCecctoZGTKdk+W8C7LlyMdXrES5ClWq1WjQ6KIr2nUQeu2Ntz7oNmXBL4uWrFi1Zt2f/vK3f/3n/wSI/zvQIsEJkmJixpwFSzYJDaOsKCtWN2236sf1Zrvb395xGp3BZLE5QpFYKleq9AajyWp3uHytWGkiRARxCOmoQ4RkcpFNEyxxkrYhx6ezdqO49v2AgSoZ/oosDA+SwpiLIA0vI334eaW167MeZFxPnhrOdyevGGGe2bUjvmUalkl9vMf7b5tCkIYqI6OyyUbqS9aIa6L321CKWZKRRURpZHU+MyuyyeDnpx4rDeeHL5mCSMsYdF77XXYm4PoFfEqtWfEgi3ryCwa/2Nea1ZpmOaIO51VkTI/ri5QQnZmF5UFCdi4XL8c8QA7sRWqpQbR+ElY2Bn7pGqv2jkO6/JIcP51a88GDDAcCflk1xHXiMMJQpOWi7Lxm3hiWNO0Yy021LSYnZMXu/DKSeWQaeSKsuBGRER6mPMPPaz2pNZxAX8Lx7d76kXw1kSVYkuPWLHqQZT3+bSiPLIjIDAQ/qzy1I7wbEDKzWcTsnD0J+PQ5ktJyTQYZ5yu1kvwhNwMqM6I2PZozqjPvvc5XbzPmY0YN2Du/ZNpIPsvGmOTlKhcpwcSgkLSJyAtpaZZBUlYmnE+d7KTIzSn83BzdH1edU23SNY9bc1JnyjwY569z2lv0seU9uWVg3S//Eq5vqTCSgyYyCZWdVzqzIJ6cjKxM4+eTHvu2L+n1LQNG8sxEfta8XeRl2AUnI08Opz6IdPU/fcsIRSE5JCI50hIkA05W7jsfT9n3/3Iji594laGovpdqQ9Dct0Zacw4e5KrXkfOWv+tjKHqy30A8fQnZt2wzci+aSBeSiDySlU/4uaM1N3Wmx4O81FOcER1PwEkjJ9s0XPiX/PDNnxIRY0xK18jxoWnHHpkRkkFhYrKajlCABWr0eWCVR50pYT2HVDkMMbosWNrSHhJYZ1CikUJ3GIqFhuDmXtkWlR0Z9mg6UEuJQ5vRKrFRpwSNFNPoCWN4/8kalXO+cc0st4A7ngQSXN2RGeGZEpUSUaWoGOr9SsK0u4ToHuoy70Y1CENaHv3J6xFWKFALu/GtcOqKIJBcbGOqyIIsNJRRkQaiZ+mukV6/9B0DmSAzlTlyQFuRI7jIzfCYGoyKwjr9bDPBLnPs81ViqRS8IxO6fTFELHSslInanK8VrErsKUmwjoBt5tnno8SsFKFD3YShrlDrlTK/go8Ixh9hGGaBDSyvpcGSQrrjmik3aRv3jicEU9zW88RUTRiMhWtJPBgHVj5T+6bKRGbIXN+5NVMQDGm86T6HdRkwauGwPU4shTXZ0SMzWbO0VfaDLXrAE1BC/KV02V4t17+/ZqL6LF9hIuyUKGVNvZbu9Bra/j7UbMy1Xb5GvS5UrpnjZrjjSTDF1HOPrjAYCwcJMjRU0MAEM8zD1jtwAudFO7EIOATHClTPSDEhZRxSU9csgthm3zDNmmRLYxjYU/wJAYGgcTgUiUS5J5JSmMY24GqclLtAyEHyUD4UUEgRJZRRThU1NJY7aEKom9RHGIJxTVFe02yA3IRhB8ReGA8AD4GOsxZoWWor6UA/OkJFvYobEigL5xJR0bGqqcE6GJhYRVveI/qGAbpdDqbkvKZQuayT+ZV4E+56iF7C57P+FOmOEuEM1dSQ1LgQ6fbFELGVCOiSIygaBtaUVEK7I2TLYujYM44UJUIpiF1P42qd5OSIOljd0BDT1rQbgJvQHUJ8YCNBeAkh1uGk9khXTLe5fovAUzjPFCrRSXUruZf+LIvKYIyjB2ZYJGtgR9m6fUYk+jgpU5JJScniYMIQj1SaUQ2pJVOu0JY6MuqO7qruw8PUnVGfGHq8Tsr/dIVYQjdGS0mbkDrVzRkpXVKln+wzVVvYZpV0r4wiOsUqpsqtajrj38pv2xfvSG3qKLI1SD3HEkXJRilishYnJ65eh3eLhuzxmn6DmSR1kGsIlprJTGpbumKajJT2mHRMKl/8Nf5jRpXZ1Q0Ys1qsrJLzTN3Jj0OZGzrJ4CVZKafBdYW2o1mOV/tdibeeZMW7GgUwYJNFtcSYWFwN62A+sZlOxRuZVbtxlXVbqavmueKN6Gt3fwXTMp5yJQbDHkjMJCvFYYvDmMvjCRosdSsNPV7jN8hsgomAuIpFaku6YcovlS6T6yZ8v+0n/ANKHSk+pmSjACiAzUBVU8M3m79hbJmYONoEQAEAgFcDm50se71Eb1OSUfXVhvWIfkW++tfT7SskAILKkdgFJAfLQ/IDBRRSRAlllFNFDY30MR6m4g49HwIfuxawTQTOScpSwLsT4FfLbiFcdXceeqGPDm34ZNhYQrIUnlVRQRhLDFmUoeOCW/CowCrNfHkRHiIrFLlGxA13POfbk16kGOptG+L3ItJFGIyFm281elGRgYYKGphghvl8K7FBNGIISwKJqnNEXCPghjueHpgBwe7hxEVR5eW64gjUqyHn2zNASNy9CHQRBs8XlgQCBoaCEgPxRHZkoaGMijRE9Cw9bQ3IIUCAgAEEw4FyIZ7cFI/nCbmOcBTbIBqUV0QVDpG5BFKUuSJzC7jjSfB0HgXFyEqzrh5ZAwX3kHWFMBgTDhJkaKiggQlmmLO198r6vRoi1ydQICc8K+I7EJUV52VZA0mYlRIzMUnWpSwtfT2ca7lkuWnrsda1IhGZgHIJWYbCxgCS2jWrYfXfvtoFWFD3yuMlNGwC2vM++WSyml/Jykru5mRWkeNSGvKK+Uj8AMRUzLHGctse1swnok6Nz4uJfAzocGvEgKOJ7/nKZ9IPiNnD7a/INNG5GS/JPnn7js0DXfkV4Dyvi99EGG5OlNNeVJMklfo8JZWmAnEDhLazfW5FIUURJT85iZ9EFCY55EjmPiBc4BDCO+cQZCoQW8HU5eqnzv6bGYt0xzA6WeXBubm5cqrpfTGYRn4Jp01MM7FAdKnzDw4gHub1LQCRdM+nD0RgathUJw6LVyRBDFnmcnkvcTTf73uZdL7rYhWELXO0MbO3rWYqiR5AdYinuA2EGiBvG/aXoT3f0z0//k9AzDZqYadhD9edYzx1IB6SJp0VjsqkSiAaSIQRe52m8zaDEaUjz8NMFKpLXYvISqIfRKbzBvEUECND4AcRH1GDPOVmOM9mKH0NYjp364vkF+pgMNHxZjB1lvOIOJ8KEAWlDsbi8LK4z+DazGDoCbEE2llHQR9ivtRL6qZZIroryx6xCELkZnsSmdfkFwrxCaC1tBOJ4nJ0fndHE23HAySf4LxuPKhn7khi9M2xyPl+QxTnyVLO2geeZX2x8T6COyrCGIPYiqMLMLV4L/Eyf+RnZilWWQ8H4+uxa07S0xch4T/zv5RCaoBwMoSTzUBdYxV0RS9NxX7WH+4OXJCj+Bn+GnezX0Zj0vCfqjFMwqZDNjG6a3lkrFmdW4KFgQPIoMhIxNQIhjj8vCpkEqRQSG4/7quTHCrQA9B7QXvTNAVywAD1a6gfGKRIxQUdpQRkwEpyIIOSWbDMh0fhe1aX3vS9u5uNaYNdr+62ZF6CfSQoOlk3AiJAvZ4h4BiMpSVCJU5GIgMkBDjHxhigERYehSwa4PltUylSRkvC+sNxZeoVsHaBSpIiFIUyFKiwHWFlMO1J0G0w6ZwCHweDbjIURwEwXCZVR65sAbQWBZXtBUajjiWhpitBKwQ2JfqEOEHRTm62LJNqB7IWZp305HLM9RODf4z2NmRQUJncANB9MEhoIn0UEMW90iDQCAV6qjUDH1MNcK81Y4PXISltf29VKyX31THXRwF2whVgCjVxK+Br1u3XFS1wYWomlogkoAjKzTWSF3Lh0GbEyJpeGy5xJZzaKG0uc2JkKJWGeU6gaFZQOZ2MFol3qWYodTwwii/RgVY0UxoxcC1lObeOsxQOsXyZSCqIjglJGD8Ox6GyWGroNvFZ4AGPaQR2Y1zL6QYveuZX9sYw7PwoIoTMZ4o1DeUNgfCAKdLLEA6U940FSKMXbyP/GOsAc/hX0Aig/nnHvU/73O8kHwEg/tvwPzhxVhygDnn4gwIoFo4gRGjOyhzogoHMldiMCoxTPx59IUBGgoYTrdUm7dr+zeyETu9z/b4/9fde7Q0jDUM+OXWbG7DjbdpuHdB7OrGPdVZ/6MEe67WgyvRsJXEIMQYm9xvbWXNqmX1qDy+nlPBnxoBTwC3AC8DbIG0G6TDge1JqUS1I9EsS0bo+Pz3gs1aTnDWp1h1d4ZUWXV58soDyj8+S4vU+ZGMYAq7jq75w2oBSuLh+rrzCQ1Tz8RQoXFTRduDTED+pONhhqK5WfZ9V1qAtx/k1PcHjtFeL1nUrBJ3ZhKCtw90vxb3jRQ8vW+95tTWp6ODsI+83BF+OUqmvSPrExy7u7ukpJeuBPv0GfDK4BUl8R7ENif9PeENx3n3pczVNX/via2uPjTSzbFM+y574PiDYM+N9WmjptPL3Yq1p01J8cOylya1JMZ+g16bwaoiIZmgicc77xcoIQLEQTB0/K27AvZu59iv19rYM/kz5XDNagXFC3HsL7QdGh3EiUOr2/uN8AWFX8HGaZGnrH/WrLdzN58TpHsuncqn+40eUd/990g+RfWFz5z2s4amNByTRSwwI5PUyoNC5+H+Y5vOwzLomiwmuJI/2fPglefOu/+yY9y6fLCifnLi8Hr98yqqBme6cpRArJg5PVA6DuP+pbkjZv/0xyWUqlZi7xeTadc6d7y7ZZ+KQyNngvXSRc0CjETHj3Y1qa7WfsBZxFrdQnpEaMNjdQp1X+xnlhGQllx1O5Zg6WaBH/hlRqU/+f4x6OMFQVfAMDlLZd91hTpZ9FuVNOiy6apGyVwtYiPR0QHGJuu+fikUTTGKH+rxEvpCKHQUiROeUihb/TLIp8xBlzce1Mg7uyjNEc4k+iU883xeIkYOUEFhPwuApxosm/aSVCeKVSsbPGPkehUJcgnbrxvk3U8FVmGZoIauW4ZqrwspkhspsV9CfqjOfn/hAjao6hR/bcaAOUiWq2sQF72MWM7Uf/Ad8rTjQQGw0R1b/TLKX+RWjrqL+22PqFi2wwdZxquZ7nO9R+7GrQMrWQdo62qM4f9XVeuwmlYZO/I21PtJGGpHhKcpjrT7ztSyyaapDfD/VhstiPPayhUVOGnlD2i/JpUF4TfktzbWgM9bp7ICJmKwI7zQVWjZGBPeDGMnpR6DFUpUqx4mGRU2oWCQxTI0qSPt7Y3kZLEq02H/735zs+Sfc3RxoU2k9DXSo8sZ1XYrruTTXdxlu4LLc0OW4zBVxmy7PbbniPSuM5zFc5W6BqUHeWsfSwKMj7u6m376Fe77p7916myWWIVIav8Nv8zl0OgJCx0DoBAidAqEzIHQOhC6A0CWQ4V3UEqGi3F5+YaNqZN/ZSIxDUtnV0z+afdgL9kaBA6SZJDhk3SszhtZTRVfz4KFY28kmB6Nq88Yk9WKwcnVHXKlybPgYPWf1HThhCUoBt45EwfDQEN1f3P/xPHtvr+pxdp8ETlGrGat/SvC0exU4o7nZBs7hMogWsOtcUFXKv69GM5h0iP0b/b9nllinNDqcYUYsDudZ2Lj2JHAJdDH+iI63JdbTi37fpLYnY7s6pqnZjAljEeG04tvLJMqr9FMdr2ZubdCshjlGE17qJ4hvp00LRm1wvAiJoaKNUjk3tLrzYxmlzn2JxXSZopd3JmEam8qPGvHMFOWvqIRFiyLJjGTMqLxlsN49mUIAYrA2zCkAL9K+cdSVM5QD1/X3yylsA4qsfRW42ZfBWzzsnwILgpJit80FqSfcLOej1Kg173aEK5CTrrkV5z/qNgZxLKSq2kukAthLBe5KD0gsYhnlTasniHHsHlPDsfuaHia1uan7mTwNPOzrt+9QIlZPf8OP4TJyzHsCV9EXChUFMFoluAuMGvYj8FS7BM5CxcqaWjUtBOf17v2M6nse1fA/YqZ5kHZoWpTW+g+9rMM+syc+bwih7q4XYW8xqYOvuvxLqdMy1YEu+EFZazgdBV4dKn9NRdbXOPvKvIGLVy6U052YGk17BkiivoUqKoTbvLcZwpEFjHde5EI4McsufUElIHDS3ixgUhkuhJOzbFAFCJyyNwuoVIUL4dQsG1QDAqftzQI61eFCOD3LBjWAwBl7s4BFTbgQzsyyQS0gcNbeLKBRGy6Es7NsUAcI1zqB9Fssuu4ozzUdutx8M/NICQhP4bzBhkDRBwTWcg3BWgE/c353oxj4gsCCGoKFAMGF3WQx8gWBRTUEiwFiUpyfcx37XdcpYpDbPLd2tZ6UhqVsSHgOZVv2xVtn/LY1+9yxkkeykI+NT/EVeKMYA0veZmiWEgjcY1pT2NEZjhkMNB76FvBgx4SYRmK1o0gQTWJHrg2xluPwvhEGhsSmTjtGzxZThIVQZ4SooVzDQcZEUywMA9MMlCi6EIscmXClz4kq4lsiC2HGzAwH/1vDwEGVQsihHGQVfrUYS+9T3SuNEN39sW0YUjsdxQp7XEh95iotIdU6A0lSVsbXjjrzTG1lWYY+HXGmpmzrlNpmTB2Tq6HmGJquSuqR+9eI0mFslBthS2PJgIYpbWJq2jsPcag4RqivpXV7Se0kOOPIkHKDSnwBZDVb1PWYmp4ZG8h0NHrRSZyYpuEbEJm2KfW//pRQaPbU1TQZafRWN4lpqGqLsb9ojCk29yn2VsbV1fqkj3tjZszJjMxriUmD1EuP2o1GTZMuFm4gSbceWOwSG492q1c5rGREjWWZms1z0fuFwVH3S1eTzHVt27Ky4kQPmEDJ7+393myNNPfD0mDNc8yTsMkH7+oVyzpyRYSxZOhGxRWqScSTsq9OsyR1Tdk2VHohCLRodYryiE0D3ctyBK5xEmKmCnJF1ZhQxLBk9it0eDFsBMmfKsIV1RNYjEapevIe3e+FfHbtFx5CyhEfsDU5cXtzZdAmrSYc81d0YQwYXVMVNY/xUjIxJfjw+O6uJTKudea+GzZNc6fI0Nv0b8gRP5AL3VGziCuQXve0xdNOT0IMn7230W98oco+cS89zclxp1cpRy/Mnemv/uLTE7yerlVRqcerC1G1kvS1UBbZSmobdarEhHoF/Z3fLh0d6sm+GG7ReCdWDK6oviZqMrodFFYztpUB8aqs42RZZt8h04IIHKgBRrobAcNbOx5sFpiPw+gPRs4SQxDtv5MvGYOgGK2sBMKvvHyZGWVpDZAUj4musliU5Wzgpkg5esWvXkxpSRI1gnh7owNitJCZGuBXcSSJ+t+k7BBSPkSiUWRXHH6e797IR69bYBOntJa+QKnMWNi/K3LJgh3qPP2OvCeNGMj28wAav+bpsybR8artr+wRicpoF5Nt6YZ4upjImHVRdvCV59fZi1N/f6xpvPr4hX8qvujJTJ/9924iN/4k09gPv7jjhps0+fbPoWmSdCuvUfBbRP0KMQzlQQ7W8nX/uKTnaF3Q1vXHK1KKp0qXtjTng9CMAZcnipMqLxHCcT77TijK/KQ4wZdMH3PxCtl2uI21lQxOklvOlgcndKHfjmUUNBMrippF6eWFtI8DQ/WgyDjYVDvPXRlQvnSEnmQMNkSTXpsyLx2QBJGu0QB3dJxiisSbxaxFrQ8Ize+r+HVNV1B+ZdKr4nys/UEFmly/V2WIlTzJzUOLvPIVnlfcPn+RwY1CtOOUYZ7BDyWJwBrgDJ0u9TqU9dA/1MEhN0caihNS16cKJgOhWHP0sVkbJcH5i5ShSybt/WKqInyMEzpUCnIU2JLqRJ3hjLefF+sTRAplvSL3XipqEAm7SuXTcdabgbj9cvNToaVy//7jrAtj+HU8Sxfab0E7bopxUJQ1XYwrJkZgek0gJ7EukgTaXadHL52oMQmhhSoUl05REkS4Ib29GVJS0MJv82mQ3Lr/DEUOMTR5qJoQQLpAjU8y0hd7i3nSO5zIjNUmcm00utRx5JhoA0tcnHLXUBSXdNs8juk4Km9lTPbVUKe2PrFC+hvE4GnyHD3fbs2Qy6W+bvAjOnGe8eXTPGpb6kD83TOc/zct8WxSZkGQM/TbnBw9zYxfuJvskoTN0x+DcBgpSSyiRPUO1a++7ca1bVl7W6sBEdgT5fn/O3MmeXD59jweUZjmSANRluzLUOzOdQ/chZXk4DUAXBwi4cZInzY3eDnYNomxcAyDB0OUMR2ksyCtxRi0GNbFxGs3F+oajBopV//q9fkxTa2Slche/wI0TgkYFeJydWwZC4W/FDyBEeblmTEHrX9g7ZN8i/DNYnFu/MoVUeTTbhsD0tL4EVR6R9Y0SR5eQY2pO3kdQHjww7nWRRVy2/yX+bvvS0aDrLE8yqmF3Y989g1xeLIq4E07uc9HKFtY6PEW2XNZ59kiGIM9LBcwK6BdN+cAb/bnAvLlNqwT2Xc+dgLmqcT5gmMWNNa1mTBbwKmljp3x6G+h2F+cPhEpkpgAr27FDOgKh5QbYPFQapIe9HtawLoZUzGY8AlZrADFWOi88IBAxpB9AmEMjx8CFsgDQoP8DKgp9Hwmh1zqUL+HLqh51yFD55DYDbUyyJHt71kyDHkDYpTYEA/gABZ8o61F0wf/2be1szBOJEFyuDoGVqEIneUYRrEpFFQqamfDRGQNtlnnsgmOw6eWnL8g/MvJOQ+a7+nUYT0fXgBO0x41I62lPTO5Nr9NLCUydqjeOTfYQEw5V7PT1stBoas6lLVrzeT749pVUFW6JbLrp8AdA4sSh0Jmav872lwRoxHtVc1mnNPulgUSfXLGfoG8IH0bgKsFBVhkly2qZdP7vLqgqJh2GPW2RU3YsGB8Wd+cWdGzxma+g8taiySjRMUBeSi0yXolxCgfCKvKVMF1Z8rVttFoTl8OIdk+qhLYX2KR5kzIqpAhIsPxjVZT5/S5YA7UWGR/ksjMbCqr8CI9cpmxcG7RwZ8iGIWgiIJy0XJ5Tr+oY9kx2lxwQR8HT+lS7n0hePBznrZ06oWLqmnVZYdBRQzglT4kD2mO3MzVOZx1Sur5/eIjWklFxb8mug7FDUpkqwa1f2q5YmPESGpta2OLshyXlAXHSiK9wHxZdGTeHUhCQmiXMmO0UPFCPso1Zr2HKGVyvn3YiMcGNmAV1y+yHulGZk1dLcKcyJJmpd444rFl6XNo0x5KG7NvC7IDaXBhzALAhFGocZKgvb7D6Gz1QGVoRmRibmuGY246ad6zoL3h7oxnsscf6eX974V7uppEmf6Uq/viNWXtf316ua0zALQIooZg9/O30DvZGfNK6JRD7pkq+C3CmW/bD6MVNu5SgiQUgCfgQyIy1HwORV5gV0NX9anJtSGHXVMQAijcb6BSYd5VhsTVaUxbb4jh/vV5evSR9tt1n6Ufvn4mJdspRIWqEtkBn6nVEbOYBBjfwuR5ySCUm1ZT3liYI0hNJw0kgoMHkjyeiFM+vj9cI6Lx0RUVTVTPYuV93F7qyXF69NB/Gi998salvVkmG+ZprtrTeQF9zvZmLmTKatp2ED52q/XdRucGKEB6ETOrmkDWbi4mh+MkR3gs9+681zufQ0qI4dw3W7cKGdDqa+vJwgy+YBfZ/BcfdjKIlSBpeg8pxZiz3V5E3nWGTfoJg0ga4LjB40G2mf21aL37gqVU9KSg8rMiFyS1hJgzIDz5vj15Uc6uNu0VyVxCxPfnD6QJCmkKcLudRpOvffaG1155QjQPeF7w3PG8Y6Ekzw3PS0p8urZKfqaibXfPron1wal1ucZn/chtB+dWk/ryHdV0wdz2KS/AyqEko0T9oKd+ZaNWurOURU3aXNVn6HEmMWtKBjasMfjWhDPFoZQcF7JvpXitmCRMIfU4Le4FvPCEjDQsmDlOm5jtYS3XHFtdBRICbU7toGTgoI+DQxoIaPG7YJPFQzdkCs9xwIA7GghVcMKaZNbQzK9Z3mLXzW4UHquq0Y11dDo8xRo+mV+9PjrWYv/uoggD5tT/l37CoS2BJtr/IdyekzVMTLWA47RQpXkJaAxQZ59L+Mbsk4v2XIVuH27GuIx2LMIZ5oWSoRgby8Z2qczreG38ytYwKNRvZpn9sYeNxegCkHPDmeBui+rP5CW46SL7jQPG8hOPE6QYIlvlTiWLUHSVpMo0xnaSfXvVIsOm8hvpyzDuzB8YbwhELRvDciI8uYSusxBUCGryc+r7MmiSjbpgOCyzDoM6w43qQ54xv2o1FxHq4byGA2pNh35x6u6FLTfu6H3bFvwAwbhv6T45vtD6TAplVRD6NQUiSaEc/yb2MawmkcMwBjCUh5wvyCXB5N0Gu3k9dDN0ErHpmaNtEGuhmcNbRZtyDHxdywb6lMAqBqiTzDAfs/5t7dey0hzrISvu8VY7wVbHWO6NUUp2frkFItrpECO97H9pWQ8S/kWl06Jf/c74+YaTYnVSN7FczedlKPoyU8kmttdK7NXJsAMW6yqScvZr1msVIYtqCtVOOhO86oxAH8bwhGEolwey1RGLVOcb30WzlRtLN7E9FmKPVoEfcFjW16lmP3BeEc8sxcRdrLdjSWtTl03QXtooaIPKuFB7enZf2VZwK1fqRVFpHpS8n9EmIXnGOBLPX1d7UTzJ+mRrTb7gb2w6GsUEfZ3PhwiTrUzNKKvyb98VNeBbWDLYz4V2eeJ+sig/3V9eQhZIZhf6agFEBIv9hbX5dlngX5YLYH/MepnAY5H5vwC5gF4YaFRDFflKhADZrla2I4TcKFwshLhJmAoVgc+kNPQ6hu9B6Oh9tmA35eMm+TuvecdHRcKP1Ue8+4kxF3lYQ4UG+TaX/vLBq/pDAjpr0+ePexwtBboa4ccFJLBHJs4g54QY0pjrKeJe+/8CD/EqC6hLuSVovBhkLJTcXlQVXYzWzdTZ5EKs5fdW/ZPao2mzj/i8TcUSKrLnlPOPrZbTedNNWOefp9uo6GJBk89tH9KcpN6v+vEcHnEY3AD5iW7ah1rcyGLBZaed/16Tgnf/++Tt/6n4IFu89hHNmegH8Z+9eNr49/wDZQ5+e05S/JwU585yhyDyuErR9Aj9AVLRWBx/finx0rPU2MnEk/dT2otMEEu1ICmWs9DN4ltURjwUX/yW/4hzZMUIG3S9puZTEOibdaMS/BCwJuOvnm3UCmiOmHc1/C1csZfv81bL0W3kv+1aq3P4a6RsL8/r3cc7Uvev2K60RX83bOxt2vPm35gDuSrrTdOlsna6pBd8NV12NpmFU187FvrhHLWoYMTwTTGNb0jVeVYYkLTqVoE4DOMJkhiFFpHmJnSNO6OJKabXNoHzO0gjBhpqQNzn7glsvPs/Y0VsQbuiE64UQF0kWmUrTxSBiZlRiFKICjCTGtp4zLeLZLJM4AOuxo3W2jILWWlkvcOWdTNo+nJ/o52+NeHbQ7Bo92F7XaLtniQTE9XLOhGC7UcmN4txYQtnsELWziT0PHoeNx5ih44yoKD/ntUDfV1IwelhX/7F7dkXCUmYv8EzzHzZImPrJCWUIh/xezHTvu49nLB6Kzpu523OjTuyeMP+LcM7Ju+c84X1ya1pggQvXuSk5NrfiDtzybu070NxwUb553MGG+QXdVHvDoGnD3vU4iWdCfbvFDgCx+SpUcqNwOmLCtSRz2fFBa+c9sFKPZWmfmaPI0yaAl0kHjfaKPFB10uF4NUid6LxOGVvS/XLluPVe3mNritlTbh6EtDVpFDTFA+drlwDOERxsDdnnAewVnuDZpyszQ5KdYhlcDDHrJGhNSoqXCRz81jYsQ1r0G3HRhzUsVn05SxcRC/phHP5HXCdBBNhcTEhnbATLOBnwHphIysz9qCOxj6pMAil0YI1Eh6ilU6FeyTcEJhOC4KlXIQHzzJsu68+vZ30YEZmWOhhwHqLSK7tUu9K/HGTt+F8aO1uiSd+VBnZWveoK6W18L2m486RTa67dX2FWe7Xr1ySYBp2kz7LNVp7TBfraOALEhR5ADYq5desFbXGqZfmkj7kdcA6sSfS1gZp75y9JUqm+WizLvCAOMz4O8g07l57jP4k09zZaUVvSZmrpE38bxLbGWheobaxsczaxDJVN5GsFWwq2Dg/DUIaBz36dWiJbjXBaEWvltErQmSHytj87weKzHneuoNC4DFw9cfAig+rwUfq/JFs1fyumniTSyFohdGtKSdAj7dssejZ3mZqrGAqN1b8lOCTGG9MJMUKFv+DVYypn+2vYll6bQXdyWAnwLtzdhHvMRB7780Ndb69kP3i21Tb3C7iBSnu6OPZ7VfgunmhVGHx01LxrHB1a759ntHVmu73fooJzx0g3jsd8eRPy6wr79Z0Xvub2p9RUT3Hh3IKZuBgsJW8fDap2VrAg+f0+yphGgN1mljT9L3Gt7ds3Li5Bxifjl+cfTfalu0hQy+oOp+VgmPB4/B2A3XYXldqa5AqGqX/2+uoKGsx3OygbWl3H8Z5QpcUYUknRCNEhthksE8mysCV7S7J1hkX1wysO9Z/AtvE/+m5eMD/+GDqMiWZed+Yf0T4U1HHuPBn3pWPTKdiF5r72yXT8xK483bYrbEZ19WaXDtFwWHS3cydJPFuS+GE1HXjlpB2nsAI3uZVL4xNR/W/lGRumr3SfPW1MWcJk/1dXvySpG+M9WEmq5P9YW/+OVEYTr558ZLsrfgL6NAB7zytgxDy7gP7D6S/z9VB73zr/SAh+ihUQG+vPwKO9DwyVBxR/lZ+Y5Pwp8JLn+jPpi5QeqL8HfOjOPMcreJmzTqcvWWPKDRU/376Vjf142TBQbFH0bXCWPXBL+zfPTPsfsh0Ui7m6z49RBnKVIg++w+APTOdebO1/UAs8jbJZH8bE/E0T7SkJ/dObqZF4Eo1ukcFfHP/vVckRIQldz6mU7dbV0IANZvKsO5PPN4HDpgpWHZmumLjLI0zs5ogDpyZ+3vFy5lmjdtvem8Gxw/4V46l4vFjLtqZ4hzffXdMVXRzdbn498I/7plOd39qKj4q/b28aqv0j6JrT8+c6rln4h8T/1F+LPt0wydh3l6R1z0liow0ftJT00v+JFowJXT7ym9olPRJrxpGIs39y/Yju705HWnaaXE2Tbb7z9UnY+64dS1arYLEGXRIUq1bi7PGYaLe1d6qs5zNnhitOncyxLsmyyebb9RVNsPJXqkTUwLE+Nx7aCNUYReDz42tpipRvi8j7cTuVsZODwfWKXYGuDRAi2/hWXTk3VRoN1apgkaa+KiESb4arjMimrNZDtUGg2Bzc7jMX3qc026ldakU7NU9tlOEluh5ek+cOaHPsGuTZvXaWp1uFVTHQVqJuGq1nreR4i+OlJ3ip13NAxotb12/9Ry2ldq7LAn3MAUWeEaYNvA7E8KNQL5yTbWNjXNguUz2L2DdOU8tL+37rYiHn/46HXB2Tepio8+vllenhGfTX7cPW+yG3eYhtFIpLZf5QixfVwROdQ4VT/1XiNrTR4PVeG7Z7VWGTwmfA27XBgH9tfgvUc8Xx8Cdy5XTbXlT0cph0PCyymjbcuZ0ZwUYy9nqHn/6keg7vzV9MD320/exd0Vqto1FDwqHyp+v00xXlj9YV1j8T/dZzwojYeaM277HGr3SzwrvZ32uh+WVRRDygDk4QXyMdhUHZM0+xd8x5rsepBDp3VyoXPq8Lgb9TKf3WUyZWO4MZ51RXuT41v89f6SAvX1egOJuLlmP8BdRxN0Inaw2SBPTO7s0Z5GRx+mUof7Vzd4KQQNUhEhkbbkNt2q24I2qEZhbXd+nWaDSsPJkZMF6qFOgXFtPFTT+86NoXrmdjNPUwSsE32vVGRTM0nbC+17eVoktcUCLF84sCmXhoW/Hy/ca2uxbhb5hwt1Otgm0R5BIMBQMdyWfjBX/e0q/jickOEqbpW10YaJyt/lTmKTeUy5txhnJ0Rwfl56QcRwnixyWxUZJtyP6kTmKUd4ReVi9AR+wU4dydhzJcTJ1S7i+arKxmy1NVU6ooOrKSUmyl93QUt1Zf7clf5vQGp3S4yXmBC2UbmdmPl6wTxW3bJW0jNS/355urtotTLTRZWRbsQBbx67/r4IFn0+yA2nyBEOYqNpj+rQJ4Dsh6l7HvhEz6ODd7crbJzS6d3Jb+4hnWrkz5bX4HdboSprcMsZsEPDq9rGYRmy8ZNbyvy5HsBpz3eDcwPMLEWedToE1TKL8PHiLeWpQBuuSKeNwfhllzhTRnllVYfe3hwdnMNFBG3qp6/rcFttrwMtmVYbAXvK+UHQn2Y715tsQasai7e5UyThPI2xDSjXQTmknnrdXEbVWRXDd1TXZSvg4Ipv0Bwkn4F302c0l2L4rXJ4G5yomSbtgGjNyU8v1xCMFPUilm4pJFDdUzK43ZP1oKFifC0ySkuvqgFerB0It4EerN6+ULXlIurRpeGJdQSqZzcTKL1fp7e5LeXXAY9Xgq0DgFXD1UeKO8lV9E8ms7Qw+D6VPbNp8992lpPxm4M6vm5rFG0g51w+zOGqMu6gxcdAO8u/gCAzEYBlV0QfXWVAbvTeSj1VaISbNUkDiZyXhRBKYvenD5BupVguTailqYLihAnat/skrNmP74hekHOEVDl+Ld9ekJcZqLbyN8W4H74TUHzwpPW7o77ZptNH/MpIEAmXUOcKgBbYWtUufXMnWaAbZ+uQ11laoAf/UKo5GPcjRp+zUZRSggoMtJxg7ICNwahJZuM8JuDKCZL8+Zt8m9F5cfPUeUSLFkFHtFbw6HC+XoFvHFGCsxWRZgiFKVu8xHxAybLvQHplS40WzCkMkgrO1Cey90pBtmyBR94iSCYaswVLEr62nc5bmEzg8orWi+YJRnOqxA5CcvjADshXEo2A0L1+nMeLZV2CaTa5A/udTHAwVUJFP/WvIXLs066V1tRZWrZXWiGuxidchNaYNaJcKH2cmoZViVqOnis6yVbwspgErdc9C+ro8a/56okEAt1HpxIBbNA7TuydwLVpCrDnZXK9QYjzLsAx3GQsPYmKXOcXLnthG79nlM1zw4qJ8zMyYHaxcOlZVSKYCW6X33mW+WFaPp6zGcA/IOiQ9cKMVsy14JnFODY7SmboSLMdfJq7HCv/5VpIR6/r7FHV8Y7qAQbIWOEjpZZN/Skcvty6mN7oWA/BF4XzPwvGtGcBpkmuJXXf3A2mA1gWYIqUrfuilnx0KLO2sXo99X0brj1fflbm+7OcrsreGThdPvX6or2eIXQTevMJxhzWLeaJvril3hQXCfctiqKC/tg/4V8dDp1wDyeFw3QAtJDNuKe4xCNvKh0TPGgrMRJq6kuwhq0FEeoGx4YVYfUiY7DFYigtE1DwDj+QoSDJe4PNMcBGz6eflQoKL88y4ZwylRIPNyKEuA+cvjIO5sxEg1/npFyOnwVaYYDwjLDMjxRxyRQWnESleZiG8YCgm6x0GHi2vQFQuSDKIX/AYiXQ1SEAlkVZgbngmomqbbIjI9l9XnbTA4CcwEdylTBATb/uPl4GwVGuLh1qy3MBpns6PY8P5AFYlEyf9334DeAmCXbFAUYWn5a6mWLXgI+Ojp8tatXSHxSr+TVypQg+IJ62T5YAzvxZM5nsLwj/CEexXvOwvJC6btrjO5pcLXdwC41Vl7ehC1ILcIF6ct/adVnuLnMv1kVZXqlR9MK0UGWWLiJmAZg+yNTs8o3O8k+mvFDSBlbVtC9wYba3KLWhTx7QP7G2wXw7FnBOUlgTxcIvjt00RkO2a6Cqapc4EEJdTIfuQKvn/I7TbCohoB85WpITTiFD4G2kaWEyv1taiygSvjJtwfVvYEaLcgu3P9eWUMUFJni6CNZcnSUlAWb/IeUTUsY59M2qT4NzO5E0Jjc5Jqj9Zf9Dj+t+miNrt+lgvTdK2lcrCyC5zMIbK0LJZwf85JxJUZmJfrs+pEkZNUqiNYCnwO/ftwEYuvaWKTvdV8ehgY70LRL7CLsJiWEUfCzcjwRvfjNCQKTxy9Sukvwo49SJlNLc8qx/6i7S+iha3KqwFgYK/veq7237vHWTRfxci8HyqL0yasM3m4E/43lmbfUN4ZHZmZjA8+75o1VrB7Y5DlIppt90dHqWp5jzi6uFipMyKX5UfJK8WzFTOAE7xl2mWa0qQvzJ+Joh1euuqmoPq7Aui/zAS+zoQblBq2YgqWX+/u/ZDW+HsS4lDsTl3xQMb2N9unk7Odtmdc7UPU5RzJn08B9iE/IBihXKJfK5m8ByhL8Q+mlTW7YglTrMzWUzjIF6lh6ToevyATbUGolTtAYrK3snUYDMEXtt3AumJgFb7hpmKdxUAjiAGNlJbzewx104GiFBF+GmLJ3G6ORkib9cbyNtSoavd9ryMHjVeWjOn1xThuX4gshviqVYnqeJJ6DzCK9ooZsbLU/GWlXiVtiba1FgTUWk4TwsJIF9StzMd97Sdbkz5yRt1OvLmVOB0U9vzg7YHbXPrBsy3bpwxwKiUNUFyQ41fpViJsRC5cTaqRJF/qqglegaV9lEPpXdkdpiRfTrJSpDWeq5Qt+K67Fx3eK2184unK6/tYfskkxvsoZVr/Q5E/c19SbJA54ZUC3kT9VK4tJ5ubHshdf2fRsviAoeaGsF48pVoC0oTtqatvGr9favoH6tdxF7kkYovZw0Uztci2GOV+F8cCKXwN9QP4uq9Dd/hYKyxM1Nn0mcO/uN0VeEPvz8sfn9UMJYeO7JHif/7A+UfK82q9hQ5hsB6LsTd3Az3GcTDcDu/H2IT1vnpaaNww4B7mmiLXsD2OVib7ASgzU4ZR/rL9VrrT6y0C7eu9V0nRMnpZUG4lcE21iR4aSYx5lSuQ6ssG2EuCT7EEmNDDvaGCutxn4itnOaf2WPsw1mK9relQpPZkebLCOwtrMnt1Uforo9HhmCeap6DSp0EzSO+UhsFT8xTfL63APjwLANvkoijOPn8+t126bxx5tRwaK4pu9wJYeZhW4Ax1HogNl5cNPCNqmab6n6aq3pwoN+oM4sepfoLB79RVe1hyHCwHS2eK7yXsj5fEp5mtXdSjnnchdfeMc0KT0dOsNq7Hh2356+dnGBGCs8z5lsJ6wBu+bkvk3fTQdyNVB9jZpN2xdWycOw0KuOjHEqPZcbMiD69wH27b5aYC0+gAFUweh5u2fQ9XAJj8/Wsm/irjvjxys59eni3NSt1kxFZewX2pE6A5xJ5TdmO5QuQ1yHmI0g/jUxxzz6RRBGhlj7AGDXInGfiBsZqu2EEYXFNSFvG6u4mDSxeS2WGdDfI2yVymtbV2oykNfN2cOYl+E8PtJ9vjnd9ZOJ1aw5++/i9z7t618hNXqYMpsTH5x12ao1MUE21FlyjqagnFshMVVE7bkobyZIBVWQdevzO8H7G7q7g2frI1dx6Egv4t5thTKHoQEkd62mGNQiDEtmOrcpZ2n+Zk+imTHsrgrTL6ZXTgkCgZkZ6Jf1ysCLX6TpjcdeNk0f8S3jz41Wp0M8r3XyczdTUAxTM9xI/Q3H6WTveYm2TX3fHO9QDTVovYg2/Qo7YoAsN0DQaaWlDl5zIKwSINTrPYFPdQdJ6+w5ggEVq5UmtncZirQrVSC+XI/l1QQ9vrEqv+ykvauWo26Yb9a7U2VFrs3MtRvs23Zb8JuzzB/QHScb2gl7HSYq6bgB6fdbaJYNdj0KNiSZEUzSrIVs4M1H1DGqY3Fqgcm7EksO/8lbYK/n5v5Q9hK5fVGD7anQ4OTy2Z+V4/qIu/a21uVHezsKflV3h0BIuleAu59U7SwUEuBCZYFMifskITGIYBTuF+DBfZO7QAz3Frl4bvyHWKtkMNfA3VrdJeGllEgWTi8l+ENX5apFTVylE+debx/Z6RAQcKZnZmqrsSyVIifbSGz+0iNIZqSdTOd9tvrtgznASTL5NIiUfXKIcxVeCnnOK2tg6WPZ+RwK3Fh0puDIrB/At+Od6pedb+KRksjCHHVrYt25dgjRR/nVS5C4i6vSS/SOp8XD0snvJArGIJH+4pi/Zl2Z1FAUA3Zh7tuJRqalOvWLZ08QPsLawwTQqtW/E3OuWS2Bu2bJHBKYGfUHlxcSFSvWKeuOIwLYWcyvhHlpmBR7idIY4wgZ+gZW5U5BfLwhSOBHghPHNksYEM+KnCAmC5SOsEHd5vTDAYXVWHLKy57kwko/Y/dXLAWJzgIoETSbffVWoynVuhbjN+O3hpYmlalCMzQyU8PnZhcWnF7H1ltwmPXoKrfQtwRgySxaDLYn9dQZ9vcSWAFW+OIt0NcOS9Olqa8s41qHDdPB4vC8OwzjOcvSh9sOqSQLfU0OllahRiBIVleGB8FFl03D5kBI/RNr/9uJcFMGeC6Rc/j3eXSZtxpgpMTG9L2waxYr8h+XxkaYptNT8UscLDsn8ig04v715SBdjILxijreqQdFBl4ehG2cETTuncySGo/JAmsIpF2BzEjwudaw8IvBOnGDeo7yOQc7FmYctvqcucwcR86cv5LmGPBIpeVoy51b/W4/zwupJ4lJbHRPTZlOOoI3zXfQLhes1lc2yixi2s5JCLpFgKzc8IEjmq8/JIkT88q4Tw8At/5Kwnpl68ZSs2d3VVjjpu030nmOdezfxgsCtW1JA13ZQpaGa8RkBC86FGTKdcWmok8ppnCKdEMIxo+1KbJzFxCbsqvFay7EHF9J2AJ+Lijq6w9mwtAliDC5ecHX94wNy1wk8TzW1uVQKg5aKqJMt1zxS0Vr2sWQO3GNohxLDjUk4VGPGYDaYhxpX4bESmpKtXlvF+I4aPXH3O3KEdeRS4hKVoK+APTMYBmvSaidBXL8JZP0Nu30tozhV9KQb4UV5T7nbFMM4Twtptx+QAUjB7Wy5FUIiuyE8ObRdCugCSCHtHLkD0thQxlw55O8RQZhwpMsu4iarfaBW7HnbADXDzXsMPlFvrdmO3+S6nLjMA4Wa+epqHNFYTedXh3iXk/JRGaLyddUEPMZUfiVARFQrSMwE3jKOcxgx3QIBpsdhGsdrMqE7zmet7FYmg/qnlbcHQmWW6GqR7WalsjwwPjHvAWImYbG5NknWBeC5l3Fn3FRTr5kvRqn79CY81vyJ9W47FxnYL2iV/vOh7qBIW2tGcvyHnJ+z5dqbpZEuul6R5lPwkDi6tvHKjEPrK2xG8o1X//ZXP3xO//zs8lC3hnM6UVE13f0R4///nuj9J/KKPqk/OarLFDNI3mIFKdN4vbPUXd0D7oGYGEfyAC2QBge/xLX946uBYTqNgX0tW3cWlOsyIhtLcywf6xFdjb5I/U+S1y1hJ9L+xs0R8xTUYz82FRgjaPTuhYbNjZv96UxaUR0SMVLFsl1D4+kt2n2yZLGYUR1SpIH0+dLmhnt1k7f8jM1+0wTUMdv15w598LFXw/ym+s2tt5JPFJphPiNSIqLv/CYx5vUSRUt4jMqw4taZwLw/T+G35d1aYEVMC5OyOw9+rPnrfTUzoc5oLrliJBlQFqJEcrMPqrKZwKDsVuqJ23y0bN/fa2zy/RdUKnU+vS5/LjltujO9/xgmY2EMGQhAO11uo74Y0hqZXm0VblrpOof30VHUJd2lpZXwpmtJuMovx7CYCA2uZTg+StGsh9qF+ABj4qORx/17+13qecaBuCgNEIeKNwAxUF0TM6/c8JFnsaqZWfMPBG7WqNNFQkwlB1ENonLRkSJRpbvStL0qwCX7mKLWLgfodeMlHjOakkxBTAiTgNFQoACEyqjAMJlIMPIUIIJUiRKPFKA8J40H+9zzbgHyz6SItgZQ5zZKWariqk6bkcHUCtcqk3pqDxju+MWQXoouhN2QE9w/iJhv0If6KLPom+U9VF0AOzYzsF9S26c+0Esllv9f9WBmDQBwNp9b52I3q4oJRVkt85X5+QhO4wrHZLx04/Rg6sQirVU1q26HdRDC4G+aKoXzpEyyP6nSuaRvT2VzDv22/DYpcwn58ElapLdxO3+Vtjvxu3DNA5IKjrYkpcksnNNLdpdalv0IvBKFHlMMET0h0oEwOUw66Ak+Loq2Uy6U+WRwxV2IniDp4H7SAU9ouHsPyQpjq8E9SrIK3M1WW2Hm1OqzzIB0O/PkbkhTOmDx7VaRleAe1owIchWlJEO+EEitefYZnceTNy81lGHLpF+q1Opg7OV0EBXCAymW47PgaxAFafW6SpOS0zwv6zbLrxdr9uAnfEt8U8vsefyKWqYMcAvMMmWUw9qP58Spa5oloDbxEnHXapZ0RSNt9WvaitfeGINvrCbiVOlAFWCjV1lKMuYL2OLg82QM+lIqGQ6Us5wGokG4IKU459migJjvNdh8hneywvW29Fd4jx8JRmqf/DT0PI67izeaswJ+RSS+vcHex5Wj0Bzp/6GVowvlCj0906x/DDWMin4puH7Xejxyoak/yT+Rk8SdL7h5o505IQuON36QauogfdJaulVukcAG/QmDLbdC4xsiXm51p0htvENyMI45eEXpSK+I60bdzVakak5K9FzNpCLVzdZwd1COlx/Gm4AHL4hWPlmvfghnrDz09WqNQwQz8NBdd8aPzS9qvbHsIBj5qCEduvv/g4cvdRGUUZxyOZe/I04HsZfDiOqyL8tk2FLD0maejAf67JmTrhBoyCeVKYk1d77JvLCOnFxfCJxlvJ6czMrOHiiYs7Ksp8KQCovQtdW6tZgBCeXtaZEUFaFbxvO+ydtPZaUWkcJ542nGQgob53eFDPJAcnvy8LPTPV5UjmxuZjB8YRxHLQsyhxNYUVDGcLPpu7Avr9ofTcnMDEsOf/eVpNTCNJf88wMfjk3L4kw3vBOoP3GsjLKFTq96F30rItW8hcH4eH6gz7PHmRTGHSj+l00In0Fl3Yaqq5U85kpn5Ppkpdcz17NT7FPMPLn8ykc9ZzeSRxemKosWhE2ts97WCc3oAgGtwi2gom+tJng5RlvGm4FZbPT1L2ZaGfbBA+0Jlg1Ym2hahuwj8v0zffTSdfLPxvcRbgaLj2jjWTGaLrY0Cd6pTVKOJcIHiN779zBHIwDH7nkAsg0HLxNWh4VH2kCLgjer6pRyToDIXqBmkC3xc6iGQu8MqJIGfKoxiHJ4zsS2fRg3Pj197R8/VLUfN5S4Skaml4eOe9NIoavQmtlIpjwkaedmoyYFP/AXXAurJpRtrFpkLfqof9dAvHn45WGOR6QN154dNzHbtys/6BnfavR03lmib4Q1d+MbAcjZTBmSuB5CKq7TBwbnK9gvK91HHkwvGwkW/uJ8saKpD3zpjz0YkmwL7wtdJ6wNi6srCnrgxoFW1QaIet+c6et/HCjtSEHLZZC0glG2o0I78sJXc0nx/6IPnU5fJGr361wzDvilBao+xHH7vQ6XzztrzmojDlUBGxlKCoZr9mjf7NvcduWNSXS6MbFnff2dNuKN3sI23a6eJbwjMnnVJl5PwMepum2Mb+4uH5fO36m5nRV2NdOoDiozAtqmw3GyyKH8YmqBqbOc3XpC3bmF8WnK14U+ou3qYAu9KAmxwVoxKBbb0QcNHQNsFfdVq0/i9ch+C3SXMBKkMJlBprgdut/q6VZ8LvD+yC5hu/Dj2YR3XPYcsuh62wFOQRfKRCdAEfRahHp5ko0tWsYbcg5lc5ErzsPPvGlXAMsbfwR33naqh+bTexX2Dw/rlOvQuJdtb23r+5vbzJ1HL5mB6x/YR0jclbKI/EKtFF+9UnPBCRTpR7mCx5rSSeE3/eWb3qo+scnjtnd7FqmtlD0dqb+tS+5+T3N+L+dvYwcvbXLjT0cGTwk7aOGlljIJbI6WfiMX4a5atQIEElNgntoz7sEdQp9tm9i7injey7u8EvxaEciPbM04xc1eGmBhfNC+9viWJsWqsK4M1VHmxvDxiqENwOHOrO4rXid7NBpPuBkqPaJLZMVqujiyZNWkOkE51hbeT3DXQ1FKc25tY6yVMuEDLgqkK+tkMnYQz1qgrqm8WFRtkTPbfU+rdGOV+mpbgwxe/m6zHkA5fZiYHBsef2XXqZEyzpcLnauvaBpTV9vPNlWtwKZhiYO0QKNSNLU+QFnd+wttzIFTu+dfqHDb1u+vAXrndtmMreaE9Peic1u1/6tu/8zBHXqsqZiS/GWMC6HH6z9KlV3TDDATAEe5Agqu1k8JUa3VQwW5oQm+fcq2DdT3Zkav4r11Z+KDpwQUwhn2V9747N2duWPoXyb69rhsS3sPEh3Kqdpet3hnMMNExTTKNFog7YCpJIgQy4jo0yr6wKqUs5GAfXB/b1x2dPvilpzLjbEAeZfbxtjWjgsUuD1uyc5AioGOa1QZkWSdMDUI9y62z6xYXa3yuVtySRODt5mnI+raQYO+HykfXE8CuFiREkk63Z2O/I/536BLT4JEfnI01uWYjWOyHycVoINPDtaeHOII/LEWuJL7T79dvKu97QnkzaG+q0WQTv57dOaSanECizjX/GucNAHGyMQRaTvx1vTDG9DOc+NQTz7/AtxtrjPP0+M47P+egZ5zYvinPnRT/yT9ZIg1tDLg/UU1Cmz/zXONvdbI2vN4+15QggsGfAMo/TucD56TJqi5ylDfBs16+lSEn+aL/az9N5OPmSzm8RMSkrVLlxawvh2t8FclTuFvrK6SPvRY0XjhG3HOoWQcfQ2C2TVzrZK9/XfWl+X2L150y1cvVwPs/Mzj0741INHO333YcQqP9xzy1tV1oWB8qzv+caZdRWF6/uzftf6S9DLRf7xiPeXYkj69EdTe/De1VT98je44R+yjzNX81bdWgO8zXPWfqV8dBW1SfwepgVREq5KOVH58rPBAAcYdeG66c+bHjCLAHN7SX3je/2JgOgNk+zqgmIvRUU50YGRPtWQ8GHidwWZ2qaphrmDemYwC98tKvCDunfGGy+XAAz3ENJUdmEwnnI7l+LIIIBPSJzM7qMictMiaGORs7klc3oyCLFAgBVGURappdyDHOGPFC2Tv8DOzBx5CQ8g7sQocsciK+SxTfmkj4ZmpRlWq3U9hGBvbbiMes3wlF9ne3u41wbzdR9AhSqCO8/t7i3/UCWfX5/SxwPjzUc0BOLPN2R9D6XOzVZu2lIsRq7R3atlXd6drM4iMB/u8dngqqprYdagOHtaWY1kql4XX0Wd8qq3JWR0tg3Evxnhf9i2w/NQWO7XHiSvH68qQ3K2RbGiaiL9yvGQPPOwNlfkdlZgfkssx9YHVAhdi6mBmOeAYtytMVuy+vVGLC8yilxf7+0ynX6vBnWNKP1mBHCMLnWZnNpA3Dv5zDF4Z1jZZO7nUFj9CK4fYnrX3e8opU40Asi9WF7H7LWiMzPSGTiGjo8zXSc4cowcCwpe8d3RfWUOKAzfs08kI+jeVFt4z696MC2CCQVfTmH5YTjaqOCZYbWbxxRoj3djcao2Rlj/uxnnhrDfubUHboEk3l4k76sN3SCoEOTprf2AdP1brJUZQ+6NcNVb6i1E3/ZtK1ZMYLKP7Q98d2FHe3GqtnBI34LeyAPiRi99KmzkG0hJHcF8t5cGBB6/jVL+Ju4oAlCIkvXKBA8ccwOeOph+bKUWw5Qp9vs2Z+LLAFfiiopND7o7Xkzu9JPjXcG5MN/woG7sxNU/YCwjX5M8ybBsOt6g0/EjF27s9R0C6sFjNIATFyhMPd8Jfnzit9IK0dQSZB9m6Ew/umVsdI3AfFP8FC/3+H/cG3JnZfnfSqILia5cullmK4zYruae/ehouVrPAn+88nrmem6cpN/+q21xnWzzEkjuw4dkQO1gv2k8k9L/eBPJPp8uOre6V92+NIvUtIXBTkL/ALPTgPNN4aOmMiIuraloxSAvnaR6DbGjupOz2LqurpDHMZPd8SxGefm5kqxJkq1TySm4vnygHlM04gfTbdcSwDCqg+GhPI4Ei4R5zyO19GbSf4ygPSqOzkXdQx3o58w5eDe3rbAlL9e9qynrbk1UAxTMy2fCOWU+aUYsp5EH130nzKZUtCy7EfeiU4iY8/fZmWO4ZaVAbHYFQKfsYuBSZVkK0D5e8Ud+Dokv6cQnNYA3OtRnPnuN4tdhTGTPzq2GechHef3MgN3Ej421S29BJrg0YRVOVTqyh4Vyu2n4XnsgDZlTu9penigRl9fYiaYHRuAbSHRsIBvFdcDryVDtnA94Axb35wyB/aAQ6Qfkr6RIod7jN7d09Hkwza7IZ7t/ZI05qvKvbaiGkm0howk2WmPQWunSrWbFpX8TWMByuxkF1mJMk7OzyuGq4c1IndVxbg3w8NYJC3Mp/VfN2Ht48ydr9+Q5uP1Ugf28DvHo/mT0n7Sb4k/afrpt04Mkwrz1pP4r7nuw6XWrpEjpvsXeugAWDh2K33ZxpeCr//cxNIyCdhjxlZKWj7yMDyK+vyxKdAsS367fYZUjqi+KzJw/9i9XU57KZBBp6T+ZXwZ7JPbq4FLEJJuRaCInsL3j4FVj4kwwEpf2ahzvJMo7CwPfovx88jNF9OYTaccEXG42w/D1xVxuerMK/aC0oxBjJVOQF7m5/IxShgZa+I/yxiRs0cIvZZfSTsuaofLi+Pux32yT2PQSVfrvgN18IZp20ohYDXRwIlPQy4IYd4nkALWNHxmM7VvdnVan9mYLbv046M+K9fEmlINu8TotAwLoHqJ1GWgcZ9688NbLwhIMBskhHVGg73B7raC4IsRpz8q+9Ebdf9z/7ZLxb35ck6RRZQ/1QF4pkIg0SiUSM6KSv8brY7xavtop3XzbiQX05m07qqqSJM3f2U7tjtKXfKXhJQvGrAUYK7MlgJhn6VuQ9cj8aNlsoi/bbMHF0y1TTjaSCQ4Ts0KLIdPx3r+CS+4ogPCjGFHkUpFb4grFYdJVOd+C+cRnIFmNaAOKe0c6U7RXwvSsYnfIR2FyAxEg4OriNhlPSw3lvCv4ik8IVBw6/bZYskSMiCpQho07vOt/fHvfTuu8q0mYqI4/V1oBXx0GtbaBc+FcBiHIwbd58NteW1OsSqZbISI8RQ7py4BIlQyRDxB/FfExahpDSj4u312Xh1MmVE0h60AcEIsrCKWF6rI+NDYSBHs3WIlNTHkgPO57nwyrb5/ugrfOLIh4DJR2kuoKI/Knbzfq84NvB3BTbX0BCFhoIF3bbtz59wc/n41AVo6xQk97ep3lU/xRphINwDmyMPgoy1EXWuv7WYSKP9U1thGrLBTbBJ+DNKkHv7ldndi4y11l0vCCXvt8unrX/6fr/L/lrs+KvUp1umRQATfToUNmvuKkD1K1EqOgEhT/co4E2OsxhfoGgIAHCjRm3Lkenx+MA7tFMZVR4HPvsaajYecAv4sSt/kISX0oLa7O/+1aZ9WdPS7gpHYbaVAuDKwVVvgoqD2GsCHGnADJyR8vWNRoke2RDwVV8wLIEO6/cIPFVmqmKqqNPXf/Crf9ftcvuMV7V+tiyUZHgYksA4niiVtJsVAI3EurS19xWMT9VFJrcejJa1riJnUM9q14PaPdRXXmlV4Q+2GF7pJqtj2mHWZhidIRb+AVuinlxuIp4DGLvEJXytna2zkrYZNatrwD14/pBausAs+cc8bupSUACPeHWdTbBxLeq0afKWR3lXimYoIz1TBwL0CH+4JilKUcawjN6isNph1ruOJSgy/HeUnhEpHUKBdth37opnZ5iMMjGKpL8ix7LGLeZqnbkcdJoIFtFRm1GPNxsIXwsQM0AGp5QJRjsDTpWSdEItjZENjEzpe1F1ENvZXXJW6OoAGKrISELhMMpLrj6mAHHdwSmtnhQMPEcFS5UrTPKBsjWIQ6eS+VKxlqf8TuLbdSEM4Jdq41XDWDXBajFATGRGiV1xXIv75ngXkQfiZDHBaZBXtfn591eHw/rq/bLy2+F+wpAQ7DgcV17EuOwAoQAVkn/IEMzl82zubAOhznN3JPUGq8LDRIq52+HORQOx3EzOTCdUROJBZsyjwfORWAgCw4jUFLHyLwhIiaG9aKWm3QHUz4lkKwETi3GXg9sNfAfR7TfqR4ncFXcY6R+bWPXgogx8tz+eIY1Ya8Afhtqhp8bHu63YpP40piFJxL59n7a5WWvLfItUajFRRlHQAazx2QVjJ4HBXdt/ReMw4PTYf04PVakbBu1Od+Kdp6bkw/eEyNMpwE4c/HzADA1ISbOpGN6PAnXKAGiWRIiO13C1OfStKfr+wqu3a9K5FRmofhMBMMbYV8QF5rLzsdDwS7YUPR8Hkeea8wy8IY82ui4GXSDuJc0PC0IgCqWtWN6HAJnENVCZKdLmPpcgnvzZjjofjMSXXZMqo+IN51rjvisxiNBr8zzoRgCDyNjhpWc2QVlfF/DdMjn1VsMRtlgAQaPwzZBIXPtunRh6jCGkFrkatbH41SNyLsdcZ4F+TiS0VLySAmwuzocgJs0gm1j8pW2CZBNE82ekJuBvCDPOH24aZgz+GTf7soIsFAeQAknvVjg1XguZnufPXxfun6HtplbmSqhBDRVkjfmPDyd9CKn2nuoQlCtDFd6FOZImwBgnsu9YaBhn2CwGvWlSf/P3g1iPtYkpDQQg4xnYrb7LOIeTLzJKCdMxFAGggp+YMMCkeTX5uwI7TnXcFlbYNSFGNv5ol0fI4c6QWnoKWUT0rE89LfNkqyW8aBY9kPEYUCDeonXTBPORXtAlpjT/Ghk9m0JRe+QZ3HfCA7/qZ7JGgZkgzcvzTiU5DGdjLmoLQruhi+s0rMKrd626cHeRgDwvgSOG4NpAjMrQqS2HEyNRBWjJ5hp2yvjQsNN/f2w36YKzKwIkdpyMGNx8rtFgRHJtQhRf4PIJbfqZPpjOz/SBMlgBRqUnHtbrru5GC25Rv1evdD15X736RxriIc0qY1I5N5AorMAqiVkwPoEDAYxnuJbWgKsYQJrGgiWVW/GYJkePCZ8bWWROlbNYgke1BIZrK4CuWXu0hPamXLg8rq0Z5lShJbCtcnu0k2t5px53sSriYB3T/2eyPm+6AwA2RrLN0rwfTpcumlXVyDY9rqiMnFcLSGw12cK+P10UuTijBjaW5/CyRFGC46Yw4URB904fAv7duZyfYPvEYsMLyvczrZ8Flt3qFYitgpAdpr8vZYKa3BmnL4eCJ4O5s5NIX1U/5myiuyZwFJxxnZCFXSzJnglanPUL//vbCuemT26uZ5FSbUVVDOLsq/PZOY7i/t5MCeVgp0spB1fmg++uXBB20+++f3b3z/+kH99+fp4uh67psx96iCtcCo/GhaDHQ5yhOPQBek2yxnCNfnDlsfgq2CPwFmaFRcEcWCkNK7xbBRQW7VlqtnfVoftKanmjjS5Df7qka6DEy5AVPNPG0CupIiZkus16fXpID/1+LBqh9trQQR4xKSHn3rqLYBUvJgQqHFkAdgfm+l1NXodhFwqT0cFD+OUTVRcu663Ue4jb6+wPo6vxohLt/SxGeT7RLi332dWEoy6PByXsVaV3cwCCtkeBMrUvDXd6FyKHXY+KcCNPjiAqKPKPDnIIi2Ub8oyzOBSgRoJ7fSwaFmmpjMWTlrX8p/mF75YT50W+Qyq9UzBHzBzk4+eEhklRwJR3McQPHH9/DvsRewlPkOup6Fbq3M6oZjFUXpM0Xki5svZqLOelgsZOztAO0W6KjJw0vNHDLW5Xlz9Eu2xmpWr6hGmwHsHOQ+ginUWs4Uevd4CTqxACCOOoM7s3Y8K4x0xUwsw0aae5jpazoPUZKB+Y8wtocLcfWWE+aUC6AUAyRJvCF8nGyAZzuiZjgM4Ms9HhLJoieKifEAMML1sq4DhR6p4J+p1HU6Z9bIADKVd5BNFvD27saUagm1EiGCg903wCc2FqHTaCV5G7tHr2cU/S5etQ554S+8+4Zaflej07rBbj21NCbTnNTbyM67bBY/i6Eqw5iER6uAo4KpCoHcWVlYAbtgpgL6E/a0AKalIhmlJB+OOu8cvExcHlEvRBSRi35nOxIBpNbGSKENMkrl9ZakJZ5D8frdIkuO+Pw2nZJV0ReId4cwQ0Zb4WWeQ0ZGxsBfjXcFls6mYgxsvu0PeMw+A5ViPXaFjUFi4NCPrrAFSuv7CDEQlKEckx2krMuPSF1JKMqmRunA3Iw1cu3EvaoFeR4g/0DooHlBEN61GDMbcCJAA1MbqSlvGPmwcoKqZyupIjex1kEgmEqBc8pQHwmSuFrudYAG1V1UEyF8MgCaWWtWlA/6DgMVB2GVhKPRiGwRYnD0tbWdR+FAVDQju2EjBBgYdJafYQO5J0wI1QDRrQnBmckM9VfZ+xRCiGYHQZE8ACX5TfLJqVPMgt6QCNOhRIjHu1elKzQt+WAoxbo5rb4GH3bciUb6UsVsI+uRMTh3KZMuY4XV5iFrNUdwmXuY+A9hy1+oAzadZ4i7d2Kdgq8UoagW+YQ/A4vYGAkhLwWQQZTQIoVF5ChsJ1YVmvazvUbDGWnqvUk2BrBiPHWx2wXKAVfazi82695gT8Ow/l88eBtclwOgbVQ3VJdpta7ZaXS+zw01i6bOcLpOamWJARJw3g9Gr3dXM69M7+JwKwxHMpM7TqpMH2f+Zvb+YlHjwZHMoVS43RS/WAriPyWSzJA8qpegyt2wbfmzGyw+6WVc6j6zieWlG0H9UbFvovbrrTn/h5sLXaLxCtST91q5pdnGziwa7rtnR5oYfAFDAMq6R8rWvZO+XFoOrG275VkWvLZt6oTH+ljyrpGC8HkvohPVWoUbqc1o7417hQICJZjRANEaUDF+gBohmTQjOTG7YeIEIWEoSDC6PINJhAI6xzilyBcoGPgXrnR8FZ/Rhpyz8rnjcETNrmUqllcmS/N0g6cccVo4e97x6cmw0R5pjx0zCWh+AiAzPEQoKN7S97snS8xoqOBEAoNxSs1d19nZBc/CoQF3JzdupJrkbiNOe/Mqy9+SfNBN2qW1l64lo7h1nUKtkZY3LLl2K+KhQHYx56/npY0xso+Ymzb1n2Mn17waQG3IrpnZbI+TONKvtSY+9w43D1KmoWRVWPVXam66u8A4CPB04yQEzmDDijJcZUDMKNifOp/NglR9R7RKqaun1fI6uMZOzySJzgOgmikq+sQqFHUTEv/fJ30wVZqhyURRoyBDfNrshCfMLVLrmDHLB3Xhc3QSk1BurQMQBmCjrcSquIPKMwpPxuk46W5oU/0D4PMzHfZbe4znOwnUDynOzfeoK4ooJKCETrI8nXUxV62MXapz5JS4oWHTqwe9ws/0wFNxHFchRQZuqAWHCPGgV5uqss1qCa66PMHNzxHTGhu42AxELXz5oS69BOW/NBOguwQSmyYv/KrS1fSDC7iJy6haZrFLx1vl0fkL8FAf7/apricumRs57aNpGASW0zdOWxazK0qmqmrDoAqTLiDgZ298btmJj1EW3YBWa2HlffiBUTrb/aLXbWyJntJJ7CmVPwOQ2kIHOT6EAoXMSPXx64fc3u800towg8F2+G1nlS3539R1JPHQ+E53TkR7AOmL4bUGwWfgFNTsn0en93e35OF0lkbWY1vhMPoXvo8bgIZ/YE88xANB0XdFVcg6msBNeKO24PMjM+jLjkUeD8+iLPo5o5mVdpdbd4g1cdJWtkyol2GkAu943FEuuy09WZ/RHmogyWIGGS8sgEhv7DZfWvZhPnFGi2nLg333MMUIwHgXETOn2kLubHcr751WgEbhox+Xp33GECP6FnCX+wUuxvzB3/T03Gqni/3LUWRaGuI8UG0EmrVzEi+sSoFkUikUIcO82NoJ7gZdGVrZldkeATF68oL6tMP5FxtJWEdJZt84Ai63xhvcGnl7pYnkRI9Zg/UyRAagakrmirobfJv7fL4R+8L2o/keaHzLSW5azenZQjzQPzxiZYzKbToY6M9SY1YNXdrzMUaEQwZ1is9bjyz//cfn98tuP33/2yfsvgnZSgIKqg3ant+FCLgzEwlNQY8e7snxl/BTMJtMd8+lJ2A6Q31FZeUOrGeZtXfPwbuzNOpWdFIrlU6oxJvUPqpgosK/OKsucB40obFE4qYG6OTnGh6554ifAf5jTHFy1TZFFoevYSxT5b3iJWfOyoQ7KLYCJTI8KJunYlL6lqw2txi1awtvjbL2fMQKPwX/3i0N6rMa/JuVKeoMUC08arcEltG4gJ79AZdkSCK83ExIMrn7RUEseljPDtaZwd8UW5UNfK4Ln+ErXzp7Fq9FcPzdoi3X3FABuvY+zxEhVaMPfYLZycpj9bjDad201GEMsgsvonVFGGLVPmbD+hRtCI7fOa01BHn7pWDZYIGH7CsBfyyDoe9FR30HWskocy6Gr2zgldrrBz0A+LpW6c3DcStGi/q3R/ws72fj1nfXcXMnIKqMa51lQLLKezCb1bFzsLEs7Dw6v15fXf69a4noT/SJ9rbbEXWnhOfRlOhK+3q/JsCmLE1k5mB0OrDUx/Ams7ehvYGPenw0Qb9vW3x8IaDQ0Ghyen5+V5V3PExw+uHdq12T/1ifYOD48tGZVoO8JujpSyVhE438Cr9tuMxlo6ieQS4UCDgtOfQJyA5GAQXOaaT+hYXkWh6dlnrZV2n6e53TmemW89D2ZU5uWZScHtJdncSSJxnQLGmW9WZkZNJwUu55NwNa5uirw8E3HK608zlN8s5NSDWA6tyBseaYyynfaVhtBbHr2neCPXcPEcst1pA2zPnLlApX29RQZrgy6nHVa3924dvofu5uGK5hZESK15aALWWsF0TiJ2H4pzz0PoWngtpXWjNlyHxr49dmEQ2DYFxad7rsDeNB7HDL9l1MYgtdopEV+fn1P7YZtdgaQUQMeIRAgZw/9UxtDQQ7n3F3uRmCy9aSpUsk+6YqwN9FJoXQTpKW30TZb6T3DNrvjGbOUglCUg/XbBVbVpdmQaV4PbvTeQDIBsQTpsdlXITxLeOEVz9SFFRxrMB4bvn+AdthhoPhfMk6WaTKLbEjBh5CfqfH0ob6UzhDn/mtuPr1As+wQHuX/xIzqZZ3pXvnmdpfOwoxwtRHrc+yErG+xYOjVh2ExEmtQnYwterlBH2CV2h12EWAo19JKrpTgc8kwL1AVwouopsFv4J7J8kdPzSZ0pH4gyUKLNrlsjrQM/5AwJe2P6MSVCAj4LF+o/1IBdbQa41+ikoGHM8YrdAv/kQN/2H8csBQqYqb4I35/c/LQoSTjY05yC8yktB2qDDDxNde9roJqvM1BY7x7cjGH6IXTTNiDZFhhCn9kMgWmZ4eEWUvCiFjvA5RP6g+luClaR/TB0dDnaRgQrPf1BpfPfGWSDyOWL4yJ5IgMnvXN2aj1nn84oX5FaM3VUtDbe+2u22VJ4DuI2ANfkdu4fWMQClR6Gq6X/FdjlIF266T+dtS1hXjmw2cgEnQ77tN5fiXnKhZTzqwgTMD7qOnOzPeIeVSUOqxESH6W8Dw26BeRgQbchvvt5fkPfba5pTqdeCxHy7EaQeJ5uWjWD+zaAL4ohn84h/w+pm7ucz6wnJIa60KRHgRfziaG/4e2o+IM391wx7eclQXKQQkL+y+siNqBYja3hc/w6lV2b7GnyYzfMX5TxXRw/mjCh+JwVwzFUw722EudiiH5vzOOilcGvvtPa/Flq8+c1DSOHJmhdhwzECnri1KCqra+0/WVew1KmvCMntY9ytG7tfO96ra5rDsffqGa5xCYvg/4sDsL1s5T7rPytAzV7exsNidOgRWC0sz7vKtVBSMQMCJX/8fc0hdoC5zbdxq3sa48G5DWIS5uq6n+CzRwcMsh3woIJW7teVq/xZs3Lq62iZUMMDfXGe/Sl++Rq0fXTts8Frx6iKqEmGTAd7a4oaqRtIT8g0X5fnEcOSnWXc4bA4eruk28hTPO2nAGntFqMJ6a89k1BRW2FkuqmHrq38egekhqGnGq3UL3eP0lNjatIJFs7cIKg4JMnShPNkGxq6QmuohNskELbvlpennp25nZ9xCvV7d1NSXngAgnd3211NoKFF65VWTiro44yy1pG04bakPtdYTaSD6qQy66VeMUQnjAqQrreuK5CcS9ZvCrjvXWz8G1fis4OTvMzjY++Oovh1Z2P+3wPyDVgfmo3/2ntDHgk899tWfS5L/+B6XrCFB/3pzLJVA78yYD1M/7Z+s/3b4zqSR6NF1cS9fSPyP6W802y+81zp3gyEw71HMOVrS0I1fOUUljxdnUGbwri8PhxaymFSwjqp2AHbjJPpgWr4twGl/25+LqmpOVz6Hl6/Ihxa2FuxqEnH6SemNE/ifhmDs7Wwg7V8KpnzhsBXOJ8NDQ23u5DxmEbaNtey7Otaf7He/5ebXpQ9XW94X3C5azXUP/onYa2tI/2PRrCv1KZM1qXDpMw9dAvpvvSoFknvY2U2M7QWWr2dXJDvZmkUeLbZ2YPztWVb1RXL0pW7MXh18+5ZV03L3miIzxow4eN8qhBMQdheTb5bI1RHsTYduaYLreUffqjqOJSz11syeVx152by9J/tpv/+GIe3qS3k+F1ksXW030inFh4YANJqdh97szl9yfPJw1w3DYWy2vsB4PmVc1i6tB504o1dTzZnFwY15zP8VAvh+LnGvuTQ3dwYHNLPKdNrcm2NUzXvuZXdltnrV9TWdPujnqbO7JKrp7QnTvFdPpLq3dGruE5aZTaAlg9klNrVW/8zT9GXLJbujWu/H+VkLnSXm7wztC0z6gdsSAvtEeeZi7S9infRhuZ8flhw4P7AGae6L/ampEKf5Rp5LLu0R1u2f81NYzy1r6Ha22pXjiYWLj4dXOVD2taq4W3ecBF1tV6hq1a/ZI7XPCe57KWmSoQmp3So3Tnm1Z2lBaHCln2kRCf5cFJh+3dA34/0I9nXUHy9dyTxwK3O4Mlb3HjXVabde4s/7xPzflVgdp2EcFjjuLS0rbvFF76bqxu3XkLOF0l6M7Tx97m8bP1WYpC+tbthhotjBr8cH2W6dRZ6eomXLcrpSkl+h3cikuL9Ltw3T95njx5VV3ckfF/baQtwXIHC1Rq83Mt4W00RqocWglDbHcNrF77eIuQUbaMrLX0CraHpB/YzNayyBp2QulbFumbpVBloA4ffAyj9sBCv6QI8RDppBoWYfbSXUeIh9sHJcjJKR50WqyLyFnlAG5QmK4VfqgU86hNbR0Ga9cyR7BGGLqaUEB+cOMY4RsJ0ijruVtHXIEX6D/+Fn2iMpY9obKV15G4EFrIFsGl8qVvPwg/bqvjAkzagDeAsV6/a+MVdWT+W/c389g+UEopyPkG+DRLtNr7WSvoY3RdoGzkO+/ANIHyiEgXUyA5iwcVIDfpAHfPD52Xq9Hh4u5FsTRlUKnJr4odpzB0eKcDH0ukDlwyZAHV8hSuEbdKa6HV8eNxLRwE1kCbmbsCbfQt2gdeb6EgRQkAEtLGQ2E7RQBRomlOMbQrATGUqgixgmvK4yncGDOEDge6SqkgSyKxVGPvUymfXBYQvRRzxQhx3/tUlQ6bin0hx43Cg4VwXL7nykmhQfmWHkYD0fTNzas/Pq14jKuF23rewzeve/LZyFuYNwf+uRqOdz83Nq6VTXgt3Kiy7jr5GfUn/ZHpzF0WcZ/nQQQNKPzNeYSOPwKYv+H8s6HLdc3KZMoYQOrfs1nFW5eyfpGvIPvxvkMmjxctWildD59AcRuSqrtejD4deK1PgaU9DnHQRXURgZpeXtD5fymnIU1sYKBWDmHNWYbl7MHQ6mI1+3xxNhBybpbnbEcA60Wjgxqu/eYWFBgUPUkf2NSlL18qFQ5I1EvJZiFIiM8vPV6ddAaMsNbGpOcyxpPQj0TLqS8RlstJJwdWwuSqy/ChELMG52ZNSWNTFmH0++xSMvdWwq6WKhHWiZO3p7z0z0c0uiU8FrLwflgiTQWISCVfLszEJ2LHeXigcwsQoN5GI9RQ8h2yySch1vgDRaYHwuRoFJXgiLv6tLEkIJ3qXuhvjUdjVbtBFw6UySfZYQi5zf8ht6c7jDj2ReXld2FYDEOHgGx120m3t023FEpKpcCyLNMfgfbtGD6XYsUK1GqTLkKwP+WUCNIb+KvDwsH36H4yciaNKNQad2KU1a8aw6XxxcIRb2LU3k8XKlSa7RdjH96RpPZYh3yWS6eOp/maFiRjyBPv5l0IE56DNZwL+LUjaLXWzDqKZjGEfYMbKk38cRw1Z94cBpWOhxP5+ubbsXfv/uHR07tWjzO5fUBTLoXp5JIZZEphoRa00Ow0Ms47DQ4YbV1NE6dMef2eFVxqz8Q7FN4zUg0Fm9LJFP/JNz/mZmOzq7uaMwUTyRT6Uw2ly8US+VKtVZvNFvtTrfXHzzRMIqTNMuLsqqbtuuHcZqXdduP87rdH8/X+/P9/WfzxXK13mx3+8PxdL5chVT6dn88X+/P9/dPs7wowaB1PlR10xIvLi2vrK6t//nX3//8+9//jm6g0PT2QIp+QjCL4lEC+rtHvqm/UTFUHCWjEoCt/SG+GxoOIT+x6RetHybwPjbWNfYktCUR2nFfvrZCQvc9p0AzkUrf3kEkjIvElBiEcSHVxBrrQgWXSWHCuFDa2KSuEAjjQiptrAsorSaUTmgNADGhjItoxo6NdclZJ4UJVdpYl1QNAESYUCakdUktZVMQ3RwktgWAhDIuQqEtoGJ8yiRnhxXhid3FOQi1vsLH3rdnFjGYj+zvTb6riqyO6/j2S2Iud/h9/LWFE7uQc4HqggZ3mGOAcQBhKhNzcCd2nwIQJUUZ5rFlVAUUxAmtIvC4GBcmqUFhsaBj8+PIuIy+UsXVKmh3e2cgukOIz1p7lgllXEltrEvOHilMKONCBr2GsS65+gAQYUIDr2+Q1M3CcI6WYRK6rdqs2LTqNibHGtaxhtjtg5dYsZbrSoVdYk5UdCeVslEdxVBfwHDqHqnpM0MgMv2z5LGXH9v/SXSa9+8u47MqXubbNyCs/B0eL5RL1L896YtifmV/6VxyJ5b4oyfz57rNtuoUiK/8W6ur0QG/eO3/9QFUnKQfs+UHpMpycPnVFMn66P8JrH34meWaK53+swXZwvHDHz7xFC321T/OC8a223LpXfInlqz/x/RVw86R+ysDl9/Y2A0urwI="

/***/ }),
/* 58 */
/***/ (function(module, exports) {

module.exports = "data:application/font-woff;base64,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"

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "../Views/ded0d357b4d0a53375d188883d326d37.ttf";

/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = "data:application/font-woff2;base64,d09GMgABAAAAAGpMABEAAAAA68QAAGnqAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGhYbwHQcUAZgAIQoCIEeCZdiEQgKgsEsgqImATYCJAOLWAuFbgAEIAWJLQeWYwyBMRsi2Gewdtv1BIHuREOfftXKT1SwYwe4W2pcSgv5CnZsJ9zO5LMc/8Vl////f3LSGGNtB+xOEFXVqrLvg+Bih6zAgIo2ttq4O2kKBM8L9RhVuYdjNYTNlLWSlzv6Zu3FLYd53miie/qjbUbAzZio+ra3IekpPm90iOaW6+Wm3BTeaa+kIfucEuZ4nXB2CGJnsViiCYGPfSbUpCveMgVxdYUucrjpg9s90x/vufdSWi32nvcSffHUN9jJ84REKwkHC6OcRLIlFouFEYLL0n+3fuZmPuGWVNRg9ebLh37pp6kCzm7PMqVClhi7xmTYc0UneZTwmGN8vaRJu8BAbvcIxgODZ31Cfcrw/Nx6/++vYAwY9EbHiAkjoowJKpFijVBQsLAQR7SkEgbi6ehhgUGehzesYREV1gBsU9w+Y2k1IiKioiIpIFWSIiJKhQqIYgBWL5zOxE2dOv10pevjv0339aPW7148kihae/Crb2f2XghkJBsXtiQTjUbFRklmo6IM/883/+fm//8eGDQQGGRICCHIYEEifnSuaJ7oVyuav37TvK4652n7iur/OfaaZ5Mi8uglcSOUQFF253dVA1X+DIGCHDzifv/mBJr2PvoA3LFEYVrhJ+wCwKQ5c5+UpC0LhTymKjmIR/XdPTXL/onzS3ME2Cmti1JFWRFlYmJemaCIdqsp8E9q+eb4/TmQH6riIPf5ldBucc4Jo2r0lbqyixqgsAeAtkuGCDdW4wgwcs32qEAg7Eu2N750qkZGmHKmLqqoOpHvKeP/OQ+UuXtqgH/bg/D/zNZrRZk4zSUvYkwXnxhrUYEo7O7/RZ2ipqsOEy+A/wTw//f/1dknGQLvSlb8gfpdbqkqTBOaYU/GHziWX+O08dkSEQIFEGC2qdGO83UMP8MDXQkLylL1KTmkjAEVsE3lG/aOAVSY3q47l63t453m7j6SDAdk68guEOVSSlKVIKO4pHPp60aT/P/06BzN/CIx32h+/dqGDK0TInOhEAulizazeqrs/oeIzdiGY08lKzed1uoyaEw1kFKn73VXjMECYnG2SO5/3nRVaZUwgl7HrM+81pxzMe68DTKb67//65d+/Sqpq0oSXZJoEAJmBPT2ycC0MDNVJcFKBY3vW1jjLUKw3cAYa6JzxoTnk/gu2yC9MLsgjQ/+v5b9bB9yE6IwNGQ5wmLVTO/+cGnSFGoISe0jD3lqvflNnlrV9RXk1QiH8BIFZHXqXh7owPAnlIYqVO78z6X2J2VHJCSgUPR8nfx3xVwJUwKSALxNGLQB0/L/w9wwubEDYHVq6PbmVjs5L1K3Tc23XzZ7O8mq3B2lfkdTAot0W/pLaC3UqpBNLw4JkXBhIJ1aAHFjOVusF0QLbw9lS5Zt/3pHCHEKPhQe3SvGs7tWalFfhDgOpVZE1/y6uXZSliv5LtMv4HSYej/foPOpxnWFEUKYSbJ9H4y2YfmrxmoUpt3bHYr/+s28+KmTNAHW7K2ySDv/vXynfeXYSfE1PczcFAySTCijYNfw7uuKEQD1iDMViJe6QMT1q4MsbdC0F913g0AQAMRfMit734g9fqCC7HqBAAMwiPnJjfNAJEhmcK3nj6vTQdzG0locomuel5dz35TQ3s2EmutKRBMRyspLedTYxtpoxpp7gBe03Ma9CVQdWH/saLi5+4JBSZYCrVZ5tRlY07eAEKKIJbVECqrmIfU28oYvrNxoVuYSgvGBO1ECNtZZ4rUdrGEv1ykoeBm+kjmK7vSytBxENyI65VopGVLgVGJGiQEvN9Cknu6jAvctpeowsw7BCgU0AYEGKOV1o74KrJjJtFcoxAVk4MQe3Aqlk0ITK/TfEMXb/CiHgEeYEmUqVKlRp0mLDl169FEZoDFhis6MOTsYsOHAQ4QYCYUUUUIpZVTjpJY66mnAhRsPjTTRTCvtLkpx2RVXpbouzQ0smfLkK1CkWKky5SpVua9WsxYcvf711jtcUxYsWmaFNdbZYJMtttnhF7/5IwDSv0MliVUEgqSysGLNhkOPhrMky1lRVnWzbIfVZrvb395xGp3BZLE5AqFIIpUVlylVap3BaK60VStgGkeYJlmepnVil13NFBZ3IrL9YFZfjDo0ziCjFF+SZrDFdexxJPkMfMD04KF3CaOkN74Mk/QwyDyzZw9yTTOZ0P+H9C2a4kdkDAyhpSulijzXf3SRrnjFwLIAIh3yQ2toKcwkaWNfxilTNOQIPZ89jBpjdQsYY9waYZm0yMCqQ9x6TbPsy/TnLYyQLiVjmjOzTLYo6kH1ZIQowuyWbKlhaX6CibaPja6R5uAorbUoOeYJ7h3ha8J7c2U0p4UZOmLI+6he5aPCSpJGVG6aXU0UXNO/yDMvovm1TnXTOahDSQeml3TLFx9KEvdw3vPdvxWmyCG3TFglfZHOvsA5Q8Os65QGdY8Ah5ntS8xO1RObt8+JIx8ZlDI1ain+MffJ0qCtfjtDzvS58t2NEQ+GvNrzyjTPF99EJele5rISI57WJs4u5B2D4ibGTN1GxZu7gKkf3Z21LmHrtN2QO+/MTWKcXbnoBj30TGrwum7zSjJXMc9R/yboqB5nFtyTS5mYxnwmbZHynusTT4d/k5anZV367SwDr+eL71y6/EmuQUWtxzhZSF+DLBPPTbmg05wIJsoS0fowbGHtOk5Yc+aEh66IueFPPSCSor1yoRC4rHiT/GsX5Hxp4jOmFVfvTD+hmxwuCh2OsRBZ1PRVmTLO9QcBgUa8dD3Su6kd2me08nQk+qo8DYKQhAAoaHLGLM5JCSedoCaHgg91hoxY9PsB0OaAacTDdQM+sPNrDsdNiDJFYkZcC9FIc1SReJiNGjHEhShTGibz2qIRZRc3DhFwTDjhgg9+1X0hMYILCEzCxSsfKqx2mAsuDnqG2s24RPFgQKujN94MFhjRIPEj6GiDFfDGF1MhCCKIQ4YiBaRUpL5GGnFpOlrSQ1SVATJHlsga7OVoOJf6CUeENlsm82E6yGyumLXisZb54Pr6AD7wUHo+UZxr/FTMyJgAtAEmQ8xmgVkUL7SIixtoA1snPbSCBTBcQKE9oV2werY4BCH4uw7BXaddnFou4Ed+qtAJXuN4PuiE1yFqEMeHH+LRExUZ6POWw0HQvfG7WznOuk+GLBwmx7kluSbqQJM6tVc2Zb/YS3dgipZdN+mbye3u7dfXxFXv8qAYBSqqqbulXvfQcQtN15aarenxlC9XoZ0oh0COhhMu+JFPBc9odzwfNHgIiENBAT2oGDjLu9D45PVmfLCYO+sKGGJcJhQ1BMGadV92da3N1VBGY5hw6DYzllfNO+E7ZAT/LMCN2YinLPGW/HN+lFZjZRkoE7LJIZcCblJEKeVUjbd0OIHL+EAbgFFNMb7x6wLTDbsP9EAahgDDwKNFKZSulZdQ6pYNa+NeJe9UziOYUtd02P3txT4MGDIaHY9n9fl9kd9e9m6b+5aDjss6m93qd+Ghp+gtfN+FWsLRKAyFampQNcbJuL4+gC8EHXiaMjg9BoxKthXVaMBERTeZMfQ/MEM8SmzLkv/Ob1iHlhUXDFC28e8CdMMchrG0xpLIGkq8I6gbUV8Z2ng777GwbdwXDjqis+pe8xhDK8OUEkpFowFUDANNYGJmPKYPYzaxesUXJRGdoSxC4aAy3N3U0hRaBq16qnoObYEr+MzAbJNQf2g7LbggLKmKGlSxPkPo4IK+NbGjkTYZbomG6eTRNF2wn97xtw+jnkw0g4nt9ZxgHmIf8RJ9raQSki8txjUM2Gzj6mLiSZXkOla8Fn2mbl99ZRh9pG0keid65cO/Jyp0UkrQXAcfMcFYxZYJ3hVIYjwZnF9kEVS4qXTVklqmZcXsF/DbJGh46yACHJoipifOxGNdSB+G98fLieGNTMxuXMc2nfBaeTG8Ef3s3p+JrKhTLqMrzBBmIVbxTqKSGCbvst4qLXBlA7ONvYtMN5RYSqp41O2pbww1r7VdZq+78Fv0f0eJdDRRye5GgkjQduKpqSFtT6TYCToXQSQIguyByIeWzczC9BTfjKd7uqzDrhX5J7qo55V5g++4f5GWsYqMLDORTQ65FHCTIkopp4oPjLop30fAwiCjrhTkA1UKUoo0mN1dlJfL9kG46eE89UZf7ScLAkisgLfAiIIAx/HChwhklLDH0TlXQCgciisM518hxSFiHHHCZfr2pIvJh4r4NsSeTUw7jucFPX2r0S0JAcShoIAeVAymbyW2xAPaEATAU7WLGIcAjjjhYj6x4+fGYBsBVLNGlT+gQpUl3zw7HPw8G9CO410NIgI2n/rs8MEv9RwRWkCmnRRESkW9NWmJAwCAHdDfxd42maHMenRwVNhDbEvci+vEwgD/3AnByBzYjmPCCRf8yrNIykegcCoqEKgk6RkC7cnxvDi1qUcL2tGZgQxmCBO6OVMd1uA/f0I0MYzI3XckIHLLmoxKAmdy4YtukoiLLEnpdjgNsi9y1OR8q0uxi6KDcida667SmX0S1PjEultnb/6rbw0TztctoKkKrX1nSl2/eOq1T59/XaSalXvEacahTNV8W63yxUNZrtJGU2jMbwBt2gGbMdyvdOaPUGbn17z4tNDlGR2peuLlQ5uH/osM7/lQ+O+cyZ8bp37KxCVWfCMxTUepA6pk/Q0l516amXX7VsgZO6Hg51DsWfy5fZVfpqNYwjTib/voQhrmrl2tq8ZLS5sbp1wYxbtKX0nTJUwrsY52vOGSoLTtDUBM8z4Any1c0gdz9IiDgczdLx/HqYdzTpAfOevARNysmXPVeqci/VDmSIXCJiAH4qu+lkuqdXhu/vKTUGYXu9VZtF/r3Y1+G7RJSr7BsdQ0E6VSNB31dpv+7byXtuzkuSC2peZ2WZGP4Ap5OW+gDC7hcSGyUIc/tQu8ZzsU94Lpn9qL/RfdIhE6cQfGTl7G9cUge9Q+y8sr4rlIrFlA7htYgXm2SbBz3Pd2T63MitBvyJsvWAZL/sSeltwt+T2t8hmqZ7Q3LPnj2Mr+vYT3OMD+icyHxXlh4Q4SZ2mZl8hPukr+13st9Rzu6Poj6pv92rJXdLitUDvU7D6O7v85+azEMrfDPt+PrmVhXpxuXwAIeT/zv5WI0ALgpQ1euxbG3C4DTcqt9bh/1h9Op9Kw5P8M/zxPZ78Ki9devlAVlimI7Jcg2p60Duu88foJCCjQAECBIYCHD4dR8AO/WxkCAgghIvj24+qaEiMK0AIAWj6wltMsSWIAbeAfQq0B2pJC8cA6UgRQADeSUwoMace1RFb6Na/V3vUzf3PeKTjyWnm6oviT2IoAUvZrDgsOANQOCwSkhsBWB2vEfnhIAAIWNHE0CkBdEDAQESEO6PyBRUkhE2/CW/OJMbUMcLAhShApMETIYIDStyPc2azFBLQjDiQk9bg0oDkSqZUC8DW8OVrOKbCyTTHbEqDjtk0lamkjgIZAIHKoROsosqacs4jY3xjwNU0272m+jrfGB+bHaB+AhIioON4GoPnF4aHJ0IoknLsbtQWoCwyghVkL8EV/HdC/1kwiuQ2p8vb3VdIQ1FrZON6KJGQjBnBJS/yS5Ik3L9uGplq4xskODgFgiIileYqnvQh3KXxiXZ8c74gRXo0ktfg4HyTSoxGdkzDiWYTcToOHJKf++sDSycKJpWQT4kNz6ZUAsVITo22a9aPBja/hREXgNSkIqkz4hKvxtQbapVSBDmQdgEDeGM/n9xv88H3vRAZzJAVwQJDuKMI0GDf8gHBms91JFjTAn25DQDo+fID0uwgFce4/4PCW9Do49m73odOxcYACIH5n8AewoxQfQB70wksQADam2Rw6nTMTgGZQQGkmos0AepA/ju4JgCKAgnOmUnrlUF4VUifqdF2tvvpcw7Vef4UDcG6dPMUCSI/SL8fyrtBi1plKrXfFq5HaSAYkP1uZC2IEqFpl4iJxujYx15brojHCLekEsAsAjwDeAPgCkHkAsg6AK5HjEbWAyc9i+AW4dfIHNHouYjY4ye+cCp4lRG4B/W+OpKT7KH83RDIt6dNvQA+6w9NlBEOmLNlygiXXgdtBXvjID7+0CIHbEaAiRGkojSIsxw2rDikSEXHHXfcSGslIaSIE63DFMqHo1JWoHE6IW3o0mZGwhHtDHwT3h2zk4hVvb/k/EYn0jv74xNd7Pvjok894giT9stuQBDMxUNxgj3zJvjC875vvCfaRwQQmyJQ7achwjueEz4wmOkeyP/45mmO+CDX6tBQah2bchCaFbnH3tSlS8FaITZzI3p+EwmvUbMDGADWbjOILoL8aLM80LrfMUU77a0Xvyedg4nP3Q0np8d8I1bZzaOt7EOgEfJsWWXr6D8a3T5HvPyX2x9Sv5VDt2xcEr//VEj+DxhtbO++B3wOvbD4BKioxgCDJw4CAtuJXMbj+NNWVrsVmgdwkj+j5zefkzbv2uwu+uHk7j786cX6aOL9mdWa6bqlFyiyx3jBYs4Rfma5JyXfjBfpNKo2S0Ir+5DsKx+Ml69o4UORswBfpIOeAiEZY2Ou1qivpVUKyiGzxNpRmUAYwdpCvbZdGUSSIVV132ErBudggDn2JHSek5twnRl/PFgZei9epvHL1TU6WfRb8PrUrzixJ9l4BCRRdmUAAicnHt8WiCchjRRgdgsagRBoGFKTmtJE2/3AZiXoInrnbLPP1+VQmZbloES972NfRCIOqczgMhQGvwF60aHkbEgyVATM4LZJjBemuCNGtztkvZUSqwyhWwcwsx61ggDHpabTU9fRtdebzZR8w6UKn4V/tPDAGlBKGnpCi7zGLGfNE/Eo0CwMWwnZHVv9wGct8wBirqP3tgrFFC9g8fZc6nszzWcyp/QgQnr5OT99e0J2/aXJf0qGDpfchqw4HtRErMvAKwWM33kUzC9oz2ZB4lbrjsmCPLbQgcsrQG6htVNcH6Kbg9yxbwVa6s1WLi58q8d4FOoBrc5CAhwkJh+lngctOdwjNu4RlUQtGFtENnFEF1P62N3ZhrVzH9rc/Z67lf+HO5IBHB/dKwKeL8Eu45ZOw8pmw9rnQ+UK47Uvhjq+Eu75GuOdrTz5H7zDILeQEN880gD6zY2tg2eGnzT+dW3/Z/PtRHbNDNGwTF2IsJhCgWQrAMgCWAzAGwAoAVgKwCoDVAJkOjSjEqNDnFuzUzI75zI9DKOnS9M/NAH3QDwMrpJUCOGT1plXDyntRDA4E1n6th/ZYDbtU7S7SIAbG1WxAKdOV2aJrun4IO3ZwNgJeNSgEQ9sQ0F/w/Ofn9T272beVfzmwR6NWuv5FAl7Vm4EDw4kxcERLg7RBPeREF8reOQ1aAXlBXPK4fXdstqrS5HAtM8jidKzQ7tHLgTMABfsr7q6LpisHbTBpbHyqLl2mhsOYwBYxLij+dpMEv00/hYv9xNUR9X6YYzShSi3H/CBtWcDKwYkiUIwVdQSVrSGqbrvSgqprlFK7XPFLq0ng2pbhY8Y9vUTwTyxhw6KtalXSwipfaSSvb64IiBtYw10B9KG+qo42OUM5cGN/SOpHqlcFNt4M3F5Ko1psDy0BQRAofucuUF4CsxS+SYNG8+6M3iBGNnfrsp/UPB7FiZfKJq8UFKRff+Beelh+Ucok72oe9ePYA6YBsKtbvkka89CHyrsSeLzU5ZUHxyzf/65fwDkY5ryESzShEClI0zLr84A1METgVXJRYCGysqZRQ4YQVh/dr+nqjMc4/IJYJR6oDrVFH234sIc65rN+yhtHUNt9b2PedpINsrniO9XPTGOCEvy0HBnYDwPv2y75QAd06By26Y9w+hSupUAXpkHLpoG0Nz4hFnWuEA7C+33KtLzIvplIiYsmCYZ0ySVDyQtSYCiXVCqUuiANhnbJpEPpCzJgGJe8TChzQVYY1ks6G5RtQXaYbx+y9pN9Fz+H433y53OcoKfn0pUJOXMhIk5QuYDh1xngN+Al3P2u8nhj+FMB/gIQ3n5P+bwx/KsA/wFMWbR/sBBNKHV9HlutJzP8c638cuJyUqwDEFD8xVCOyYk2/b9NDuW1e59Av1/Ng8sC1gkY/RRcmb4lIdAmras9UA0nWNMo4DiRd3CpRnFcKwn2ForATaqhJ0dtxXXkvBgKHI1dyWpUOFvUEBVwvSGhjnEdFw1VzRA4Clw7MJzYOBVq5KKVvSc2RN7jDMOCxQVm/48GhwZlBpEupQDdqV2O8Euqg3hlufuSyDIMfB1AqVI8jnCb+QrzvHwrMVZK4wtXFX1z1I3Hhr428MSULZ1Sy5xavQc1VFxD01WsnvOS3qK0G4clxnRJJ9iwDRO3ExoP8JyHaKKYRqQ3uC0vqB62xXti4MygmHtAVhOtZKuFGZiRQUyi0Fvdi2LTNELDJqZl4rv+EFHbbKmvKTLRlhqZnmmoauk4Bi0/CZvGdmgxmBh9Xxc87g3RkDzRkxrMcI8j51G71+joND3yA3xrYbVeUEOOq73nFIWnUlmmsUVSgu8cnesCuholvm9Z43Gc7Z37Wtk2DjENe7My5mkU5kZRhTcl65gPXbBjjMef2MhxsOE+xhkNJLY3/ZrazJLUA2XHkD0NgnQad07wTIgJGbQwA9OkhFguCYUz6JwymtQM4zpoSE1kUJD8RAXUCdbgUlQXQ2Oxhre4Owh57Oh5o39uXL8DORO+GJ1bHk0sXk88tpVwPMCN3/tKM0IF2+ctRPvvYwphTMkXXBo8a/Do4P4/6PczKu/+o2aevh5evQ+z/qUpUY92i7LJKKhD5+M/SF8TUS+MOYw+E1cGTFkHOXQm+RvuDuRsae1R+ilf3T7CO+l2H9luvLUR9bOEtVAOuUpqF7saPTtZA9j07I+XzmasiUkd0XnCicGm2s3QEogFHXGcWRcMdbfkJRzvyeJ4lQMEDwJg+P6eYfQlzDojO16TQZYeCcMsMQSp/8cNJKPU/t2bm0YE2efUmGatwL5wTpHz21lIWxfXiMQ2dFCGfes0CHG/K6ok7smQa8JfSWBbs+/lqm82y/SLPT5XXrzXSBb25EKHBMlB7zrDki7/wwVRSRaaMO+tlK9KK0qZr59Prn89g1PMdF2zhT+rs8BG1TMi+udCyH+SXGeSvcNFXINy0fVS8sg1LhZaJ/vjT6gOPNpbuV65/6w5mJtvCy6DGWk3PpMYvGToeiUqyIhh6aYeg7UWdui2HHk6MOGd5k1RxYuIexanlV+EJVPC7WlVB2RXlwPPiB6HInBMo9GP9grnrrc9PDf96rSrpGHy6XLgGR/661UzOkmZmEYORn5a4LqlXaEJsDW9jr9ZUjXyiFk3cMbbdcH1XH7zquYmpzoJVlBVmTSVIVLs4aOknuN2tMNGn6qdpZvD3sKJCIlj41JNSdR4UNp58JK0H34bSlliJY9zC5YtbbQOx9uXQC7IRx6nDPuOTvQkWt0WcIHDCR0dUnGEaYHSI7/CbiiOyQifLpgshGLtxpdkbZUE52ZUYEK27xMzHSB8rLLplWKMMpTAmoSnrtR1ah4UOw1cvl52vIzUnDXVzRBR4NyNfplnwHkzXiuXPjbRjNh0ix7tyeUP8oEPS0mqTE7nh923lBSy54XBNSWCJU6+jN8grX/sE2gk+1OsTRJoptQqsilEQFBL2GqeRuez1tIv15X/KNDFH2bBeR75M5Fr+R1gixiauugPGojz74jOjS754og1gG47f5P+ha00x96EMkWN9SnDd3tGNwh51V2OhW+quznyyjbZIpR6sv2h1238pROeHu9VOSl7R0w9fVguXvdfS/axl8Z6EH4fol7Js34qU7DCxxO/+RZbyRTg2X299D/WIcireyfOGzGrxQudU32ScPmfEwNebM5mDWQbHdrNHc6f8CNYoxhkzbF+xvKL/Ak5oaYuqpIPwspy42kZoYEoiBhEr6yiDJRMyQbxlpLxLwlrEsI7xsbs7kOn/g5sFBK/yNq9dMndmaxhYoIhcyvbHIEvOayPRC5JLL763EZYIFVzklS/aJBa0wxjj7jXnyz++KEINowIRqbSYzsX4o2ipnskVUtW3jxjcly6P37BO+BfTdaukV7SqBISZxDTVZxQTSIuzQjz1RI9yetw7jsPHFKjEs+oXMz7ElfPg9KlfWRU0QH2fywOrPom05d1nNfPOIwg9WKH3FVYS43hbVxjlC3okbewTq+WAm8uWCnu0104b8iB8/GEnqRJQ4IzRfWG3/lMnAxhtT9tYU9zGgtYDRfjUpRkz5pNOz3rbLR2oJJJ0aW/L3CG2hi5RUfVsmDNG154Ihyn0DXhdQ4zLbnHHBrjdQWODC2qxRxNVzF55NM4oU+gyKcVBQ4tcbPUXCLOI/8WUZIMS92SGB22xIHlp6eM8p2COpE+2BAEXH+/fl3NAXhDEiRHnlXIZnpvjzZacA5xgI7MPCSvz/9AL8nH6CErfbb6Gt5WVdwAATr1MuGqveF8Z/s68Fy6aUZfX75MCVSOsjOrcRlpn1vLC5ikFbQ4CgOlotmHFfoqbNRFSW2rywntKyRPVd9VuZjJlz/D+QFtDG/fqcY1OFOseh/rzjD9P7YfOGh/KN3BA6lZhli1qGvSr+0bGpgW/oZIOzQonnQ9oIXOdGbQXnK95D5cOMg7JjTF/4otkppRlFubWVPj6aqjQ+2cLlo5OZ8SN8YtUZUt8o+l9/XLwSU8Vqk3juPkKlxdu43SVlkJFR9pKxlOW0zSzePzkIzmdXJHE5Xhn9A6Wi/qLlJ7YPWb3e35+RhhtHRqfoKM3F5I7g9xiPaZbR/cid4GOlW3wcjotEZncFq11f7KQH4l5GqKdqWbZZtF2VfjrT05i8uX75BUUs+INv6goxNDt4TJImFqh1yVUZ6G6azuZfeiK2T6lMOJDNsw25FyfyugvTD5aCAJCaEXhekWLdRuPaMAW+3UMXAS3BtO4H0HrXWB+gF95VEX/XZdXZZNkmacfYeH3HiXZ4bycnRLFx33uBytyx4iHrcU72p13i1P4Ahp4PRmgiTUjhz6VLTy8FDpeORwIR5UagoKdyC9GOxc5BgpYXl3pH1WX3uff6D7SVToP1rfLTFQjvs76HGuC4KjUSasb4RleDinTaK7PfLPQSDoK/rPYFiSUnkAqSp1EO5JSyqVXKczLOop5hxRYKBMCHNdTZtvQXiEk9EzjtQwkhqPCWdnYrbPiduU1MgKOWP9JyMno50AktqWefu8uG8KkVFfomjgRj5bHGeF5+78FZi7/Gbb6+Hq+n6/NZC9pd7kMuDV/TkJDx38jNW05Mc4Va/msnsimg/PfzdomEOba+Tl9MLe6KEmnXtuWSYX9vty5YY3ZV+2qwYIGYTu/Qbzc+Ff5XHZFnz0jvsxmAPBnKTzqGFJmnuzy18DJETd9SQ6ou/WaXV1j/aRhyiEwAQUcO7ilPON/rNOhrESJO1oIXEs25VRQ7MybsVAz/q4QuFAJiTCrgEhaMAirBN/15F93KMSSWqSWFQNFy4rT57TlGT12CCOqiRNIKqZuBicjbajeHz6rqe/fpJ9j543ej7s+XIFKfW81/NI3zpZTr06VcS6V05vi53yxI7c5tMQb93yzFayO761n27YW+DeNaxUxZjiBaG2HJXf7Ogg3UOZUNBy7RrWCSah/SSNC2mL6d8bBo7JwugcCrF7BzWAyTpVmHwNw+AQlrCJijnmwkHh0nRAZKo8CYGcAxNKGqOg7foN5M3a76nElTB+mCdisqB5VTciZ0TFWhITosVV+kLUsmrb0UkHdSqotTmsEXm0zfGN3KyZTxsQQ9dfvouYe15ZjAimYD19YDX/b6YoIyr964VCdUwM9LRKkJL37jH5yM0OdilgcasGvh4YnvbpMO1Um1sKCNbwDFb1ptLB7vgF0uofprThC6HgfM67a/yLF3aANzHF9WVrvZpquuxEWPJWGMX1tgodFgeFFW0J3LJ5gmhwniEiQt/ZAjIswEBH8jJQ0NxjwSS45L0tjNeQkqRQ7MUB951mHn0mHMWI7CcXSLNPPnZFlmNyOlDIIHj5YbsLhnpuUyT0S0kCXYuhhjrfYECqme8K/TXh6GuyK/oAVhAolsQBG1mkeIA80lhSgjwEkqAFe0lUmBQoYSkKDJ4Nl2BCndEX5ciXHRJlH05jOelEz32AjQH2kFOFEqriLI1L/+gnmByAgOF9O/puDKF79hFfm8SJJgcH08+78Qzdpr0JksODAQLBUL3X904ydJ/u/vlHBoamkwMZusA6dIcLnlBAo1ZiBTHq+HF+hQXbp5Ai+pXGLlJh0Ptj346Kr33/BscO6CBJlHAiuQz0SoIMlRPHp5LtuMJYTeIY32xC95TI0buNhv0EeeCV0St8//3YqgrqvNMnQzjEVH1MLt2SxCZCipn+o15Smo0vqcpmspK3QJJmIwnyoTa+2P7JUCBGzd8DJte8AVO/pA2lgAXgMIrujTSNS7puDgafRean2fliTgjcUfnCmNqfIkl7qH2fCB0hBFp4UNWk/B8bUdTMOueURZKxl5ZWyVNbZO/zCZJ0caQkQ4bs0ih6sgrFbQiFNNtBQscXI/kc2qxdTO/8RylLerSF8B5pz1t//AhyShS52iRTMMJ+iuixUcbvLzvvzlvUL83ISbz/ISF0sprFsqZteTq+y6oBTS3nfhEExKXKWu5QY9MzqYnXIx3rdt07IOroAAS2jcG7hQfg/7k/MJ629dk0f0JOn3BPG74i6V3eeTlQDV+751Yg1d/aNbZ+4wr/Afx3DgZjP7wUrKut2Prtmm9TmSc8s/pvSdQ7dzSk6VvXbFmqSZ/xdP6fbEx4FZLsh4/DHYHyySBlmh0+kVt6fWeTygc8G91cGg/7fMf4yvjra29tsZbXUpEseKQuU0OWHyhnZ1Fz90gmzgdvT5yamIrO1OYM5uWt5GSdDPEGxKvNh1P94eVhlHn7WfKzU+NL1MqKZaprnPrs7I+z1r+6RpbIFZXL5F6B/GsDJ7Ep+Tiz0pxNp+V/L0Yl+HhTbCP4FMthRtIYJiTDATrVCHy0xq3rXwq5kUBGrvV8EGLDKXbkKsPE6RiQmsxUpeXzbBlsAdhG8ymJR1ye06x6yzy22kwYlFMyOrjthlZb79H3syQNud0cK4RNA5diWlo6OwjaZAYFoszzFZEP1NsWSCbDHMppJk+aYbEKjKyY9xI7UsvLK4syIczMmSbrUZxBcxTVYuaM69byIEo2zQSmUExJbDrExGBkGMSUGiC7m4nTfXunsLdwrXDCnvbqrx1qq10dvfsy3njkcu+7Wo+MfeZGqMQ4y3C0Es46KnCrNe0nOPUlUzkeg2Ai0LQS3DzY2kAzwVmylEY+A1LPLbYhWNn07fKr3eaoL0+XhfT4RK7u/OMBZQTGLEllnyo09eYcLy3PO1fTfZTvaFjR1c3k3TTJzdF38jnmmYN1d6n7Ph2kKhJ5aBznW4Y+a1RoNCGxFEMOowTs4VKT3FSlAYunyTiQ85yrkPzocO9DoOU11DHnsi7bVcqmlCZb842syebyJbRev4xuKt9CjPkgK6lMwXZpsx3LNg15tMY0jVapptBOUwgKqvXPVzdxOWYoiWyCsjmppnwyRMdmmMFUCkLYjFQd6DOMYhmFpoBgMIpkCiVZiccll5EpRGCxRJAp3Cdo2sHxDXF1L/zUZlUeY1aqtU0VGftzTirK8y5W9y8JHS0rRsci8l0HXRN6FdWsPjzZ8AFjInTq5y/09iVw0Xh2DM8A9/ItRjSWakAySsFNXCqwkaLR5zGCgrCXav65ZqjQNAxy4zX//Kos2hyNQpulJSPO7BnddBmtaxyO66Zp3d84CXAKMUGlFOEvoQtZtnECZIW9oSJTHPkJxBXlA+wm99iVozly7SjKpEftkzNg9axKhfofPaSNt07UsWEwzXB4Y/2BVV6z1fyWKdYCq6UYS3i16Ry1Wx4tQhftKeTxbCRGTcxsoH5bl+i9+pEhkQBTGEyL7zmPhG3hhJXqkqKJKhLFljKySRq4Rk+dfuOvo6em/z117qEFHnAhcI0Pm3/72YnZzNKtxeGC+E9TYiGKJH2kaWvWi7T2W78GlwTeD3y9TfnBfwaZr6ynplz95aCccjp9x4B4oiS2vgrBQ/lv0tlgtYExWmyBA7n4OZHbrO9vupHcsXo/+d5qxxmpn3+/r7IMQLM/qF7JbFRTDpjNtVOG9HU1laIAOfLNjKmWytNoO3Fpe75DZQqXlqolEoE6Br3iuqmZk8kkE5BDgBZj3Xttg/EkQceb28z81b72VzldHe9oRlfFv0/mTEr+mGA/1PY1XWJ3twvObLVubC2Ae8QyF7xIN8zT9yIu145aM18u2zcg1ilbMgoL4e5tfExumA4Nfa9ZOq38d2bvzJTkGPvpoYnti6H1d+pWePW78RtuRQvham3vUaYtk7RpzvXCh9Nl7KwjM+/dTYARr3aFdq2/l7535saTULBg/YoHl+Mmr2Q09Xykml1VAKpij/D/l+seqQZaXqZ1NQiO7NCuH9MtlwhzpBHzCFezO+vVprpWwnXbbi9bJbSF8xLv/uwkmQrOE7cDXlb8mIu36rrzI+cGKOHPhQ3TP7+6EWCjv9joWMozmo7mesrpM9Z1JtTApOgSCXm6FDYbamUnxy6cfukHZoy3yx5/A5wipqQegX8FPDx1ZrrWo8FGjHTEasK1hW+qbQpurLAh4YtDuQl3vSQtlkcFTbtQ54Nev8GIAF+LtFxJFA8vLxRumjj/QNPTkSIfOi/btKA8Inth8vwDbUfPQ633fOELRy77daJumvqGmSrFAaa5D3uz81AX7qal/4hQqGls7Efe7JIrz8NHv1PGNF+itjfQ5nUVtIV2xyV8c8mUosgN4/PAZhIOXM4XubOLFBni0OX3evTdss2vdSbmPnUKESdLTpJXCKMPtWLIg7lQ8zK/WFCaXemz33CD91NzbndSZRXb3zwwDfWsSxdwUvV55BSzgOuCSkEZhJBqZKJASOnBmROsiaeEjWZql0zGGuqoPE+obrrC7fTQD8s28lUtogIXrFBQA+aSwDJkVmqBhNyOVkQ3JZ8tqrPiemQK9mC3aQ1TS++JbkSUcwW6DA93owBfqWe2J7G9c01Ibn3oXYAltZ1Wfj8TEcdbXH3cJLs45LlCrHQEyj6P+GLT48tfZDnN8sJGaAG/CdpXIbtZ9hiU9p80cvpdUMfqA9D51XciRu6Q29JOhG7+o1J45A+1x4mv7gSPbYiLra6EXoOIV7kgrA6yEtnMEoDU6Z1K+GevcT99HwvHWrCfP/j+ljssF3a36fFjudADwHXgTyk+iDeZok6nDCG+6BSe+T1dI+n8N1cAJvWK1wPAcjzJm3pWV2fiCuwwQMGFxi90o3cjgNoQuJVevvTpCc37bbD7x8l57ROjlqmkhIWHhyHIYIz6yCs5Byk5/BRFeK60F6GWIevocnp3q+Is3PGSTFfrrEHJ4t5MUFzDE2scpTM4fcloZkUpoa/sdyzJnRH8jGUgj2Nncn/6qPjWcb0RGkOn8OMZtE0hCdhb1uFDEqP1EA/NDGw+BsCAEws0bYJtMU+JKoewd5p9koT9NKuVJERKYijwf1EfwgSWiJIYZEFFPr0CuF8yn9+JUAAZ2HQ+cWUzm9VZq/fiixvPFbtG8K/a0+0TfoSeLW7UHCRUl5MHNxeuIFKLqZRSCK64ms6oitvDSueAQ7fX0AlqSDPxjmNoSqQzjNDUI7pcYcAxrhZNnWBaNFMSxzDxlssnSdrPrLDmFyAEkd8GhS4LbU55RObwbSSmNWm/ZA8/rOaCoGMP84ozvVv4Vlf6Mk9Zd1RsG0BuOKUf+vEyOwo1dVievk+US62WT3B5enxbsn/XHdzBNK4gpzaQl7gTQqkgSjVIytfHawePO+U5vWVlXVlSyidBY3RGbKmuXO/8evD3DbFLA2nG36kamhYZLBNsND3QtQy20l70OI8SzOm20Kp0ExulqYphYzkg3k6ITUUKjwutZKtVo1SjbkpSNUy45VorhQ7DrTDq2z9JC8Fb07rWUx8Ml17MY82JjKK2dIU6Z7Tyuq+LTC6xiGPQpX0aiGBzxax44iHz4X03E3XsGEwLHN5UZ2MFhp/Dvzy+d3ow9s/IUdRnIZYUmvTl0MTMKnRg1TKs71mcu5mXv0LfIDZ8uvD63slHTNmXX2nqYQv4F1xY6gy3smK2ML0ULTihaZD3ZCo12SPmm75uRpLivCwclScH/5DiK3xzrYssX3KxKAZtcMkSGJE+fE3YOfyWvjzOkUJzphHxxtLUBsat1pHz0praC9K2EfqthsiGWa5t+Hyh05mwBTNuNaxJIIN8m5Ms4NeSC2ypg5JIceoQ31ZLEfBrKFEJMiQGUj8TW7JyPbOXbAvyAdBflnEuDP2QbWodwqgH2s+22kn8bH7Eg9/k0MCNTx4ROQU2MtsKGpLoOxuV14Ish0VmwxhVHWA7xs/pQxQj+VrTjMQ+jBc1XNAQ22ojFyg9Ek1o1uZ7vAg4305h23j/VhphtaO1nbFatzSBBWiln9vUDKO1CErDcaPsHBAwMVyog4qCFaGDSCMHbaBTcE5L8Uhumc6LqizDNrLWQAm0UWkSFi+OJboTE8kN2iR+sD7yQJ6Gn2WgsfH1dulkltq2QHDo81rpvrQcPjdbHpaZJ4tafoiUrKf43xnsPayZu20pKirt3fE9zB25hqXxdDq0SjJzfbDDH23Qbs04RKsSd2SqtLle28u+S1yQuoEdnlrTLwOyw3z4VeUvfwm9Jj+PZuAHorvxlyIYs/9rlFlr8zUYD65FBW9GFQgC2ks7pOm7Xk3PT/rt0eIeni7Slnz/zzwHfW640+8D53f+fvgzOuOMPv1a7yBfbMVwt713Ny94POftT9qRbKcQdxrdL+1YdErWHYjpuGeirB8ijeFPorpgLrspvl8lcSUPCt/ESMjhYhDuQLWhzf6WKHm/xN2vNMVDnPMiek5peFX+WybhnDyrOEs0b3yTJGrPKRXR56H0HWMAzIuxsNC/Kr1pGOykN8tlc+oMdXoVVbyVL1pFIiHOJOwrC92g/aK3QFI6TgyCP3cM5k0haLDQ1a8yxcOET4M8svtkpgYCO5MXwgIxkHpSUW6uUFqpnvUTZvXIdPVYTgY/lJXMRFKWvrj4NAb6000J92yHv6lMqlT2u4En04dgBgQFATXOP0ySyPX/hvgh+TH11YC4nVrU69rPsOjVi96zYfeFE5yI0A1ZiPtW4jeC5yfh166ryUXtAkpl7u7EouIuuEKa5eJNf3by+8d7rPbGcpwi8amiPfRiKCu/oVo2naOtXSlEFJKEJ4srbAt0RyvubHXDw038tB6x3oOTEtThBYnX2636tj9UpbbEYWbHU0XhPPC/UT9+aKMHUtEgJjRlIIEfkwtGEbVZLGlmdQA1FpgXZyQW6DL1sjX8WhjwmVf1OVHbIONGQ6ar4HrrwFFhKeDEIsvehl6t9LyRzNUqMFThuNjS4IL4Bz3OzX3MbDWkIcpf+hpqP5wlyrIHUXbE0hIMpAJNJh3e84CgrhOwqqBMZjIJWDAdYSLxufo12BAH91xWF3Lv/78jWTW2rOuPdAsgwC++qKEGffofvuA5vg9ityX0BQClzFHQFiMOBtwiSX2WUv3ZhURxCP023lYPWWbO2leyc2NnG//WnswrRc6tlRuVjq0+Wc8g71brzvWdcvheibmWzNq2sJGEDxPuSr0Udc7v0dpQ1Ou/nlMQ1/D1xh17i4obIAPsTT0sP9SZq3aYPak9bFhqz7vVWf6OeWLbTV9Pw7bL0p4x9uPhibUpR85csd1DYm89ncplhm69iXcP4W1j+SeeNNBTx1quKs9faK7xEZv9xorrYGw+0ErzG5gfm+cNRTIiX8z+ftyaqfxYsKGCg2xP/gTrulkvX3uAo+tG+gBM/DR+kxqOQhWZVtEa90VaSwN5XqelzDc37Eg3MB1qG9W+Fp25ilWXTys7cqfTBDYaYyTpO78XNy9jne9RNGJnDkcMKsdiQWaOyJktxkeB8950revjYSY2V1EmlSrKVHPNRXIkTb05Jc1m4Eb+B8+1SOdwQBoUEqTisJ0wsYZnCg1eZYfMRJTXXcxpraQfb7q50bUHUs2jVcfxyxYihGFX13NScHOmHLEtggyAFen77qtgY1g2LG+CbSNCL5/TuF8iNjsoU5mnD7c4E1QlNTp96WdwWgVwjgBkzCKt5XAIdrayxnTFFGFeB6iEvexy2jLiCXIXyLXEJ84LXO7toD+jDQWV1+t/ynDt9E551713Dk38Mv33+9PRzoRF97p7Zj06n736SPaI388IlafGvvVgLiW5BIOClAkYHmgR2Z4ipmQp0Osq4ViP5QzWVH8J1VPOmTSbmharspthXcfazaKZAes13En1xZwDZsXh6nWsjq6I0wDjFLZB5Sy4Ft+31DL/4oyQ/ny1fMn6zLu6QKQ+sZWUXxQVcX3igvm3dOYomi7PKz3o6TSWhk4YTvxuy4uRy9ApffhTj4+TjC7pUWohtyZDtv3TjVjqlglx9exQYHranguvQRjAFzCfQbt6gHGtD2QzB0vvd6aUPpgp2ZVa4677OhJcjCcVD3QVKya84fto1E+QLDWoWb0BdbjrT+TrEyw+S4IO1+Ya9KxBjz5sXqSjbX3eOByCRSH/nwyEgfk9eebZKDskC1PuKPfPb2MPNJaCisvxpdEXsqMimCJF1r8TbaErFq2vBvzsHuLTSDIv5Le7gdqcQEO439CKwm5AARmmKyqRk2mjwGrGadjrv9hJ6CftbTFH2eJIjmsIk76xjQ93Fxa2ZCi1+0TK3Zk+wOH8mfza3Ff0vcNcbZELLpbBPVsLNrZaBWe62y+xm/oeaidWJX8O5pMR/z7KfkfT0fUqp6+dv7rNTLXP64F8Le8oJpdKn24peqclR2+rqf/9Dhf/d7DurrpdI8QNPIIVZ2LekFj70UPXD0Sz5nscr+S53o1MTATyTyu1SqGwPkMYRQoRu1NFXKgFmVr7T+Uit7aLeKYiqoay3rzvjMjpTNjyTl2viQpgvsQKa79y1mELnyyLooDDoV49scZI7kxk7KTvdCM1cnrXThWFd0YtmOA7MBxlciM9ip/czzU7iAJ+NZFjBvfzo+jgRq6yGoObxr9oWQTXcvId/AKFWw4kiHOw1DhRhiDPaS2YTNUhHrNy65wyocBZVIcY+fkF77T/jySj2rmnFU/wJ2M6x/2JPog68GKAe9eY78jeez7Lp5atgA/dhBcOxU6ltSPND59seSBJp+93fvJx3+ne+y5FTxX0SWRb27qvvTX6yifqrZ1Z3yGE6/GCiD9cwEmN+ZI4Qk5hzEf5yi/xqA3VhWOZRerRNIsQU8/nyj1isAqoblEL8l1VkoMZatEk1CPhtSleSgUznpUCsfiS+JWPwQE2Ya1vSojqxvucEQFERvyqEJn4wevX/ps1b5Q7HuvtT2qxbyFmodYoPH5tzrEdjZlM/VpysE9gwWxeqMYwcmG28ONb3GFvQnfWJFDMr/GtYRGfh12IlKak+PC/yIPWvl/7Yml479ePrQp+vrknlXBVTXGEzQvWBd+Ccbw/zhDYjrirnxyW6WT/vNX6Mdg7BKEbkeknEXfbxZy5V/S7D/C1OgbwuG/pX9edmYFfD5B+d+4VJ2M9Yl/8IXKdgcECl3J2sd1glj6PZIjvFYwIYnoJBk0eKymPHYJNS2JrGYS6mENydtA1/JMjT6paj3SEPHjRJgt8aa1/vyeYrT2YYzXiveVEH7HX5a5hNQbvj12DRRjxR/axNdx7ZA1fRAHQCz0k4NPOMe8NebhoUygG0Hu/L/A7J8MM4yiTEtnOL0B2mjTjWMPr8zZ/1k6EEaUgaCQ7NSWSmyFNIWbLrlEV4Ftpo/iamZI2vJ3VG/DOWXBhSV0XsooTGTiYIGuVy+yqM4zjC2tWtFWSRJDg8ROuKZskOMpJ+6WruSlyKqUEgmKZ8UxNStML1HHvqBpay1AY0Zziqk1BkfyVltZj7HJNhs16ktvayTsbUOn3MLOjeynNnKE1xDph+Z4Xo/6r7t61boFUzVSyMe5yuReh/6QA5AC4JWJAlq3E3cDCGCoyFeVL3KQffgP/A3K7MzoKS1yZBUnFt3eO6M+9O4ejssyqJO3rHeBbnFhc9a0m8jkm+7UQWHEMJdhFHvOObaYkuxhlNiwn/xm9NEw/jjCVoNwcNqrRVDaO1L8x5405CP265OCg0Euy6WA7pgCdUx1xyvPWVcOYMGIhCBNJTwY5EIWJRLxs9tei1umWy0CY5MjQOkgIvfVXvmrrcpn1ICCgo5dRAdpx48uDE4PHfcdReZ1S0YFvILzU6DMq8DCLbBVcQZqqtkzmltqPFeeUIEtOF9fIR3OtFuJUBXgDbAvU4Sh8YBZaAaRQwDoa+CbYFqTLpxQCcxFSIJEC+nyt4aV38QMa3F6jsh8uUY9wMnnZvIMcvbALrlGi92oe+QZwUtIHlNhUeEGsCyjFPVobwFGkUFZsOowZC40/Y8I1jHiqONQwjjHpUb1iEWq3yTSeJ6o/rLaJK8w1JpXS+nIoUZoCjxSkQyNFuRQplIiN6qLe3HxA9uP4vbtl3Rjty1fvZ+rb0Gc22RK9ibGqYdcbamaS9M3l5eb1vOVrWfc3UFcbuk7wnY1tecF7oRuh0LA5TxY0dFFX/A3rbzfX1diDO3Dh2IVXLsxMnL+e9HG1Nom5el2rGLnBgf2QdhLmgzU3pF2KW8AfjruLf/HVut55fFSJq8J2K/rD6MWUcWNNvFkzHKEvi3SKX/FLFWT9+q5NiVzhnmgy3GnvwFKMveV+vL+QQNNywHt9V2KcZ7Oay6lHPTUbNVKwjU2xx/DctIqNhuv9rrYYDgVsk9as13ioR5vLz2Q50/p63q/vCY75mkkZX6jHHaksn0ToNiX+uCL3kfqFMWR5OWbeubC2UASsIlO1sTTk/GnfyyUk2nN0FGpiVdHCXFngBWZ93o0abdpg7exYfg+Rbv/ervcx2UgCSdNTbtC7oEkZQDZeL86+++gd2e8v6lJiwVhpQzKPkqzAIJJlbLIdUpDrzS1fQbcaWQeUivrvK5KolDLWmdZ/osvMnm63ruAsaAmdlJsWt71VwW16V0ngCbON22hwjYzUlCCAM+3QAjZUT9h9rHthYCL4yOLY8uzWf4Vj/grhmxZPlnNMkRTY4xS5Bw8PRFHgk3D1YVitiOLk8Ez1peByoN1dIqC66iSzGeqcFEDjh8EIqmhKZjxENiIeHJjYHiZjj1I0j5ozcmNK9tPMnXnrfs3h46OLWTd2DtG2jA5duP1/e1UU5SH4LK0DFCzsxPjDgIMVVVCW2bSFpQMu+KxsRb1ARzLKkbwSeIM/XR1A5wYsKKlEYmn1SR3J7cFhsGgB1sFiFifh3gb8E4hJT3rwjaR93zHg2Orb1McEcUO0YSoxnIop+5MVk5qAaQ8foRl3Atv+IeXyB6Lu4p+XIYxnfZ3Y22H+ynfD9/mx7QFtXZsexvJV+wBonVaHj5kFtQn4SnB+RT6CtVYTl50EJ3HJWj2ClVefLkLKXbhSVC0fdSeXwDIY3X4miw/GcYH2AkIBsArH4YPHUrYTGydsU3QUigKIDrbFcoBVJnYsF9uy0ZYh7021ZytT4ahrOFJ7SlWrtYpo+SJGY6p4syMA7JiqnTYnvHbOrbmCkcIQduVqzOiDluRy9KTGdNQTGg5xs3lZvFLp3VlM6MnyZAv6oMZ8x+BNpQA/jgmmJdNm6scU4KSc/r1vFrfq9BXEwlP/96v0/601N9oycwGyLDJR7xEOE2t2k0NPQLIjVDOjjc8Ae722DMCRgpalFhTlm4VFC7ZH9zBtGZusgraltu+3LjHSdFOpzVds1h2r5pZ5xr2Wv/q8Px+++7qqpek6fU9rwTnAiQ1Ayvw/lJpohRfJejnqFsSS9h89YlnV0sOR1UrnWnzVql1DWv3+3DMGuUjHDbygwq5oJRdSGcm30ZlVSTA+nIiMKhtdYJLKLyUdpzcmL5+nLH0yIH/sWSnl2Os20DFmc/Kxl3mLX02carM9wGVoNhrcsggAU2RwZAHAO4+RjYuaoNYsC5ToaPUGKe2h2LsobWUbIPWmyjNbsbDFD5rO7sPX8imxSc/FCwFfC7jR1BSTZnwKozAkgjgEIjfWxTNg1eFHrOK4OIp1JPzDcHezHITQuiZ8pImMNeL8RuoooyEkMnokHOVP3MmGK3HpYJLKQMfGVi4PZwNKaHFd9u7YoxLCSU+hlqndvDB/ySPRMjXxP73m3qRXsDirhNu/L3kbp+TIXjo95WbOe2cw2ctgQG6mj/qNMCmM6+nGT2WgUQaV9Wr6PpgpmpolbSBz+ne5zXtlY+0lNTxM/fqHUp6gk2w3VY3YzP8ba45nYGg5u+xmbn2+Ihl7Afop5TR09CZ/9K/kltgHRCHn/tCHhv6weALEBe+Ld86nfyCYHBXf608h3mnYs8qp8xsWV+HoloThUkDvv+/7mm6FehTaMpGfz62S4x1r5D4Pf7UGEiKHKAmKogIHjrU9J5sZoiHmiaI0aH5OnUzUkMap+0L3PDxDAFkdPP3Kv8sHB8TPRtei9sdy/Tc6ogB5wIPWns9cwEv8GrDfh7/NfTX6yqT77W66N/oxHb5NMN20//R+SOPgL97izvF/Li5mvCz68Xsd6twbOuLrVR7yyi6lcPEu0kdOkreFUV6xngt1Nf56T7eofs4QfE+goqdUTynXnj4MjJ4vi6zvXaq9SmZ5hGVtkjVlX4QTRc/NrSsTtaTxl74wMh/V7NKkeMc1yJ5kBnAKVLLvi8r5l0v+HXnYQ/3SvbyktQCqLfUsRhN4yXDKib9atX9abGA1u7Vd4cc+r8OvI/7/yLhUpZyQWA8Q7niezRwPMqktMZ5OpNf1Qx1Xx7Z8NbC9J2EAZxBjUUhxHs6UsLcQyV3fXjYdz4gb7ADxqs4r2mdYD1rw5twTyrZ2tmgm9c0Mv8haBlEJmxHWVlM5WWsqof5Re5Q6Y0pSXUficusZha6MI5oKJ+0q0VUYrvtlKVr8ogCXhp7W2IjB5SBBfFJSQJJjsI6AjD0f7fL6vB1NkNZvIyMs7Eio95p3i2DmfjZkIGpIY5fGVs9hXZ9eZ88XY7SxCGSccdxn3RPP92F7eYCQ8Ev/fDZpKHL8y7LpRfGXu8OEQa58kQ7aIfSWipqLw7bsLvpypPp6mbP3jqrvBOP5ZEyrSpe9bG6d5TjzzbuKoujxl7L2b6MkaRM7IoDvlV4GqVLmJa4epq6ok6NoyVrSFr6yPfpPgmBXvOtU7xgz25C3q7zkSHO1N0+yVmoWGnvFo1/TA2B+FuDybL0i6x5m3mlrI9xxDZwtcPlNSKryaJb4IbnfnVvcHiHdVkPJjhFahS1vXJsSIoWUEIqKOA40a5tIfoVdalweL7okt9BWxmgB8o8PqPusbPftTzQkIKvDrw+3AxyyN7NTqvDA+UD2ox2TzoVXD+CobLPy3usXs8AIoAPgJtcp99ix095E9u2dw/pzVw9gaWyLEtqPfuUR0rZcO7wWedQn8zuoPqTym3/psall7BOl9zj/uTf5WQATeb16eKWomWrdpYhmJ3yQlRFHB5mA/ZFBW+gBg1xLO2HF34hIVqXP69yHGHTEvdC0GSsgefTTSv+jFGc1Ydpo5s502s7hrPKjOT1mySwqvLOajsMxw8icKiifBY1bNb04MDMwQcx5dS5x0gQ4OfBTRcACpaYKf9Bg4vA9+yyusvg+6bZIDjvWcGk6Ls+STuFWQwXsND1BlFEtZTeCRAMTFYFBvRvUt1KtxAyYtMMIJbc/mROTeGjDDeS4yiut6g8Hvx93qblrk59zZm/zRLN/UsQa4ImkeeLXBzWVcjT29o4p/cLVOSyVrVL+ClMcGKtWsdfP/zvU8EEHOJSg63+LXQQoGg33HZ8U3Df5A3EoeRcqiPjHJxDw74H4rYl3t9t75udUceBlx7Jbrcd3KL235dHEKXvbzOW3dkATPkoZXBucKZy5drLoqZYyFFP358M+nXj5s/URaMIvqAVM2n+r9b+djTcL+5Zal54Xroes2WewpNCg64H0kKBPg9aD3p/Ii30q9M3zeCcKul2XYhhqdttXY0/GPphoi3j66HnIU9V1r70i3jvVnWFOm1k4Ob1/pc6pstmJA6ONn6rhh1qCPWs8G7nxaYP1J5u8QUqOFc7ANu7Ppa3+BvltH9UrPXgU8EHs1fYx6Z66gxszhEAqoX8AqCA0VYoD1RHhvlswEOsBejgybdtl5iNrCMucJTIz7aX9Ez7OePYwoJYawPOCuRbb9aQjU6GS5Ri0iqy1FzOMtD0zT5oO8yQp+hUlf47icewODEocKCOObFDj0xmPEiqD9EiTqDiKZEAqRCM62cGpCWcE5ofIh3wpAP646ASALpiZVpom9po3BoX2wI20iAGn2ExwR868FrMJqigg4TJqEaTYjC1/6xkUOVZ0+2/LdYFuy0dAx+gEtTxHm6kdZc5S+jBr8Kn3AMuyTKm45xdq6PTybErHsHSYshszVsE4HTu0vjgGs744vhWmWqIN0da5KlaGdC2LIisFnskus8PLSRC9FsyfQusAzLRG2NYPd5dHcaWDOWXYXR+PfXwvogeGSK5F7tFX5MQ9+a2rsbLLnEEV1oK5mH3bZHobHPYeIojM0T/hMuT4GunBQmvFGcJRo54fyDE59E/A5Bho2tAsjpuCqMeCmwP9KPGVKQFZpWVyjs6B2fAQTgIHHHVVSQ/mY0jJ+OuWXx4WPUirUxad7XwX4AGFrRaDt805vl++D4CetKq1OHg/sFuKmIswTRwbF/R2M3PrnvpncjTpvHfuSmmmSWiRvRVEqyZIpVoO0EWmyWHFeZJOpv9dn3tdzB7jw3QAHIIVwi8L2HD8kazzkUOL851nmx/9nYHsYGZJU/THaGFh4pkOwo8DirYDg+tBNaTnl2Ah2oVxHZMR2aGTgaTLhaZOtJsZ50i6xHriX3G22B9xEh3jrIKG6eoIgX9qpa5cfffv1DYRo30UwI0p5FjZg10/2OMu8ZebxDeb2SpcUHQ1gM04sdSlpEGn9eGDf7LZswN044nFeHC9bbZ6wNtD1DyflwE8Iqh/T2kUKtJu4dvCP9ebQUVEQUxeAkZeq+qpwMb7Vy11JdI+c0OWEFi8XqAC9hhTfmmelb01U55UwqpNASYRBURlVNu+K0hkVZG3CbZpAOkHJtwNu0MxkGb2jMDw66kNALLrfjcH0Oki93P9yw37ccvUxJ5uEWueNpr1CJp1K+1P7yAX8gfgnZstsEY97IrOtQLszz01HcDq+ucCatxM68t6bkONm6X/ErxrfCS6DkaNLz8sD64aRg0daJ3nItldAPtQpupeQTxYdCsOQAbK8FOaGJAtSimsffQkahNtXv6k/XOnjkkBZWWzeYa+kyGjaNIjKDzIadIeEFKnpssr3Wp39oL9/3XegRV9UjCC1sPu0KKYHQ3uVW0Omw/R163dz9XWpNE20vs7VuX58IRDD8t9XjtlhBEN5d5KRxcWKCdPpYCyJKeNA1Vu/wUFgH2XjwSQPu469UAeRCgD/OLnTC83jeiv0bjchFJ07l43255QehXVxZM1V1HXUOmoE++tqzPxkkxJW7WHigqzXoDvCCIPHyqzvdXt13Pq4gyoGDmpI/szxYn5bfF2q2uP9rxfz/ViSKh3e0D6e4M1VtL1p/R1sJJq6jfXSZ/D00r6abKkGiUaJRtZmQOE9DD7vsSOkmq5td/qYC6jAtmnp/yL33FTCcigIR/IDNGd04D8fLYjMShAfJ1/dlRCcFv361MQv7eqeiVbSKBh9GR+NKxF7jGUqYjDZEIeMEgpPgD6TVj4wwqJUz/zsI3n0SycTgL6S6hjDomltq1dd/7SWdJff6+vBAv1UC76hIc8HgEUoT1hFqdE2ICFff14fz5t1lFIfWLL7Ubntz//IKgNUko9Al3c46j02mOGHeBtgszYEXFk5w5ce6a2u527L0NrjDd+ZDPsfAp16wDoxOloRgThlZDaaaSDIePeMHWBR4IQH9jm2g6zI239Eda3r59eVw/r+8KLB8XN4BtjJFuNrWmzVdhytvv+6BCh3eo/3FB49eMoPq03i/msbSpNXMwqb9sDzLG0m53nBBQ/G2CkwJEIXVKhr8HukNvtjFlCNObf5b2nL9MY9PfK9X+vEPWiO4K9LT0ZfzYdeY4xnJ2hrMSPLOO1N7cRwQXkR0z24zxChRX/PPnIeIdnFJaKu/CJMRnInmDWAPAIc0yVbRXwiw1Ep3yCBBrxGHbHgFayvO61ttS6CMvEknhCjyHwx43KipwARaD2lNc103e4H5n5eL/fDn1TMa9MVE1eol4E3oxCvQW38CHuHw1Igr7B8O7OXCyp5/FUj2ekx4SQrty7mEERj0iO+2N71atzQpR2p/NTgfMZwtXDpAd9D0DDBIIOl47UXFsduuyYH2d1maZTAY+AchSOQAoW0qie2Fadb2eiKh5+DwKy0B532I0Pb23OW9ZJ3MmRkX5RieNfhcX5RYGDcO4VGPk8yWilH5guUSSHeovYJVriMXRfC3O/Z/J/Lv7v2md8J34IxfEOCwA0MRJ5sp8x05lbpCq29wkOicIjC4CBNjnMYT4wEAWS4F7S8YOIz/kixo9s5C4E14VgiKJ9B24jx8OyhmenmdcpjreuT56Um+c+Q027Sq39gMCHqIT3oaVzo2bkaQ2K1tSGSai8qo+Gyk4XdrsliMgdmb2zQ6yVHXLXZgCaZlsB2XnihoSrfH8zL3xkYO743+9yu6lfE6zUq/hRWYWLPQ6I42HyqWL9R3cqKcLn3VaYfz4vmtxGInJhQuLgcK/FZAKyv2SZn/rJhMIRHCaRcbObdtUWppgc4Rb+CLP0fbL7mYA96A3zhqLIa2tsjUloNkfVW6C+s73Yt2SJxWOpfgUlAUhgxN2GfKMD+mqdFVRLbNTGmOVCcto5dNwDzZw/c2RpyolEeMaocGwwUVa4E43JssRoER4XKGEquNoeDJsHsxcoDLLJRIl9wZHM9XGRSbvyqCo0kL2C0hTZZYYj4nSF6XARlzMjuF0zdmVV0gj21sU3Kar6BgG12XVan9w2K/Ig9hoeGuIcGziC51Hlp9dYUDBBvpqDabuDMCWWXMLysX3ZyI5KQxRZ0jHD5krtTQ/US2QktCXkyPZKmTrTc73oiEvjua1C73J/ezyseuYNskvebqIA4oMEnRjaERsD7SUOJB3zGzgv/EKi8zl2EgxxR7xYRD3RoJJuobG5m0qZqCzmBa4pTYF9KYcqbjl86kwkjniRNyZXUZbInIR6pBxLigekrw2z3XiBAWIYoSQRCFolTsdYRonyQuaQxU4Q9HC1IyL1MxIHKHIMP+dfb7gmnSuAv8XNPCc+c69E/pCD+JhPwZZdb3d8sZXIF0wR6jFRxgkigzkiLeEjJ0lBMTv4HV8dHhx2/e1wy7y8rtTqJAren9za0O2xOyG8IcL68EWkmqkmz1A9GKDUJU4SRGsKjhrkOc+Ff4o8YFGxUaDNh1SSi9Ug/55r7+85cZlQFp7xYHixRoN4JIr8ZNmlasDhIo8n0SzwjSUDL6CeCnHWqgyUYKvHUp09PQM+SGzbhwSSLC2Amz/ykctjHumTzZLV3WqwXU6Xug+hYJI7+scCp/nEdDjXbaVD8nSRtGk7oQ4xFmzQbS1F7n4B05I/9u4RjLK9BZjEDzpMCpkHZQLmcJZeuiBEfSBlvS6eJ/HWXoh8DI9bx4L5ggtu3VJq4+GEko2K25cog5kEZlUtfDIUIiNRzLI0bCtzfRpKNYU7pu+jC4XrCEk3O01xfzBBhD9MSTxMw7amIdobci3OvxC38LORgKaBDQ7tcKKMra8NUH3vT1OKoPomuSWfJwnpMAGJXwGf+AosTzwHdjbefBxZ+S/zQ1i6o0pEADikhWJGiAEQw3unJ9IhpUWEmjU4nBQCPlCZPJ5/1C6gnusa0PBMpJhMTQLvW0tqCk6X7rGdT9prv+wyuopDT9Vh8iNNRZ+xBHacXaPKCmKxXKt8EhPTiYkbLcDDu2aXEuJuteN5zt4YH0JgcT9sptLMTQEzOE0imsuznLQIkb4tzcDyCSaVak0z9JH2wKrDcaAgAfmJ9DTs5TLm2AOdw0wazwoqA5u435vmBH3pTJnQ6avqw9ANJwFvXjimCWcgStX/ui8frQglRKhMzyEIUjWaPh8kk0E78dLzz1HwrHoqWoa7fPght9f73fXd1pjYFyTy3EBisACNRZk/MSDAJfGLicHSDzlFCUEg76qcJB1N6dskzYzysUhdtrkfzO+OgYmfu4tj8ypEW7RIXLqFwSKEdB+flzVj1WURCHHS0Qt9arrrU5Sb5Xs+TLAW8R04nQicbIscQ0BOsT9NOyD4drCssaPobwzBfjQU5GRXOAZCnJr7afDbDupRBJMPLdpEhxGyQx0uTC5koBv372N+qvpelcG3ITaOMFpwYlwK58aZjwVswHPNnFK+l6WE9lDtRpwqANlp8hJal5pJIAujaHRA8M3ItvOQ++L1O8omcqQBq6GO8AZVGOR0eFA0reg++mseQlHtkyttle8iZX0PtcxSjvUiM99ZJJUGZlUVdrLWw33z7bOHByTHRKlQIVIw6fkCkgCJgLMwdlWRLqhHrFb4EP3eLY3V9vgvtdAsPhfDXaTzZTJcJgeZZ/s+pNnXPBKTfdKzVdbn/YJLCdTDleTGRPEcAepU0H9nCt8CJnDMPCapcFLVR36GHGug/lGKcgCkg4xHiiBPCM+lyOeNELF2TGDPAbPnhgCwC/K2WAvmz21TvOeglzBChWbiNMghGfv2m1+GKMfz9cBD4cYhMQBOw9hHs4MNBbOpxKDreh66h/nIpuoK0hXCjb53AMVA1Wrmn2KR1opDVE4T3ygCMd+Yvt7dhjEPHIhYSyXiBl3/pfDR/r5bkklhq3m38wfU3OSTpyKjcsIR5bpq5L6sE2oZBBw6URBPY23X8nqdkJLlqBEpBk/ECgLFQ/CCXDPbFqRtF8ssgZt7TlqQOtWzg5xv31yBtpEXfHSQqwFVdmYxW1uRfr9oy8bVjAAGK3PS2Dl5kGWERJwgtl6qokFhvDkIJggTJcdZbiBzNXDVGoPB4m3YSimuLsHNLxTA7Apk1JL2LeZ+HSTDGSMaIKIz3QUWx5QlcxJl6aPYhO561goYvqfKB9xXQw6ZTcfiOjEmNFau5nTmSFUE+4KZIi8w+iL6pGZiFCbIVpzXDj3vbXyd45pRj9M6+u8Lm7sm8t5ps2qXJaOeba1avI9+trzR+ax0zT9NM209Y/gyH+iDJS8NwAw7BTAXhNDIqDUNItNcHDdIw1MFSNhkpn/ekDgijyD1Fc/bmWUh954yUoUsEsD60L29Rdye2uPQNVW8XCzbc7hOjIReUvQf2ud3KkLGGRHruJuYI5NpDJaBlyDHXTq5GpBhrI+re5KfuTAjC3wBwJzhvvYJ6BlHiBtx1pJA/OCTaVesAtwZmeviDC/h8tUrHgz2DiJhT5WTwg4p6CbUOIeWGQmufWNpt32Sti53F6xGouZ1uETsYwRbw6ZUPnnaA24y16B+LsEC0y9DJBiyRMQEsJ6xKSR0YAREMdaz4USUoCMXOFjOkUzbWYQ9WtX8QjsQYhWIvaWVFhRvSlrTcWwr85EirBMSNRb2jdcWognSIueBJqBezQrP7qLkqvPDNnJ7KYLOLQBjZTC7dMPc30PyzqE+f1/G+Lmx4Hn0kXkDeezUNK+/znqWxP7cj8SUlyRES4YEsiAreWuDqL4txTQi17B5ylhb3ksmAYU92CNXg2oNXUkf/8btvmG3PTRTKmDsYSDRxLohhFXD3mWbCHrdxeZe5sXp9IsqB6z1skM6m7o1c+jF8pzv8CG5tAFwtvaQ3O/Yaz2V+DiuDnHmvQvBynoInpdk5rOou6pUCbKwqet+x+fbV81GkzvfOKtz2yjTq6a9HHUVqS7yqI/WZhVcSml8+YbpvoG7Xje+5UgGsj1PQATNOjRScuHGi6aZqEVyjC697S7/BogCa9rmEmu0cvToVGT7JGzer8hzdVViVYmX0OcOSaeYlxB0wi6qokkK80ntjHQTqQIzEd2g4dgp9zUdx4Yphj2fUw2zydMLiAUNkW02uO4mkydduhr7IGzDXdEtLG6i5n1JJfdlSWPNB94OaJoY1CvhcevkmNwPV1Wb996D3oBHhucEC8ULy18ns8ZqAUGU6grlvKIaKqtiff07kIKc8lXXrpzS1Ol4eU8GwYQsqGxD9mlQnaSLopVzZonJLlwogRGgzmjcO7paau2J4jbZ21AcIl+G9o2hG150RkT5ZNjXp9trT3icO9w4p+zNlk2xGanSWd+wFRdegRA19PgGJsGECTl4jgEto3CJ9XCmNbuKptlUxVycLfXA9Ybz+WrI0TbOn6Z4CZOazdaEYzfMv+fOxX633ayZp4hbzDZqnwyjeZdh+bbZ8Hc9bA3u3EdXg9wgvezHy5p09qRE55T7akgLnKQjY5l7/XKJqufuuespEjasQIVMsIelHsDVTrF9rfOAiTLKwIbrGX2vu/r3U1dQY1/A4BO3DdH2oVRnECPiua5KXmxLtoinge859mgJw7PC6zJEC45hIpgbmzzHUAiL5f1J3dAyTC4Y3Crh0YOuU/gYvl609P16KlyuqLdYWwINe+bzQTZ5NYylSZeJjONVh9ergtNIX0hT3Mz05rp52K7d4H4LbzbzLGHZSn8aSNg3fWdbsGNPVp5TqvMSwDpiD/b7V3hEv17Hb1+/esHv7w7bNB6v5y0O0N9KMD/14/r2bG120zX8/PXLF4+Pt5fdehHdIaADkxl7DOEWMrLUJ2IKm6hCe91WVwJasLTJmmhGkyBpmJq3eC4dMIWNbH3dNbS5wfpRqjJtszbzE6m9VNoMCy/CTgMotEyJ6iu6BDOTvfLyz8RPKxWEhGofrcYWlIgxwocW88zRdu38XafuSW4h0n/GASL4D3CW+A+rsn+Qu/6Vv4er/Fd5UA3j2xL6EJvQhY1TiPLc1m0ib2ZaPaLmWcKHuZeTs5zNY+5PLayOZbZHmFXqKp6IpsavRGzC8lyFCHIO+egJRr6aNYHszu8J5w0K6MqMSNmTZ356nPh/rmgz+1qkfSiOS4z0nuWsnS3bifTwjIk5Zsv5bF+zQItFu/ddkZjJMxQiuFNcDnj54k9/fPGbF99+9cWHd69faqn5DZmyxraGZ9pJqCXSsmljkIq63B2bFu0SaeE0xOVvg9lsvmM+vz9eumleaYg3vJDV1rbr0u351c08fB376SrKHEKid41LlEn9B3omChwXlsYyw9Co5JhF4NSK6lxycs7MPPYV8G9a/9rjmDsms9B3rQ0KdVUJM1dpP9mrpYazRq2cxOnZpd7azI9tvi/kuFoQcR6eY232ZV3at2YE2NaSg3THt8hvNMxWGXhzqO1csovuG2DbdatztghW2zsM1cuH78jqe2jO2zdjIW8h+2z+uhP1D9CGf2FgWH2OnRmM9k0PjkQUG+DC/nDEGUqdB0zKv+eGoA5XSwk1f4LOAhNOIT2sJZRA34rccKxh9/HScRMdl7zBU2SFG3z/4+sNJG96ToxDNLvraOT/QjekHuKNmZ8qEdlkNNNmmGajaGeLWbuYttp5bsXy0pXt5sp/NhL2D8h/968eNBa/RQnP/Vzqber1Gs32z2R9n+1ycWnPFcexfwtX1ok/Au6keU1EBw92d1dVlZTQaJmZkZEAUPzYX+H48uLC7Ez35FcYGxncv6e/qusrtLV43HXOEvtXqLAY9GolTW5JJYIDfMczqXyFfAIWk5uDLmiL1gv6kyhE679prdT9JO2oaHrmYT4J2pxZWdlxtqQ9/RzNsNCYraBRNhrAvs+wYfJTbAC29bObgseulboy41HpllXtYg1gBocXxqv00jJq9wjfad22Qo7rUSCK2B1gfHPtu/jA9+99Ocnfbn+AXE89ierhCyJIwrdU/Z2vbb3j77y3gZTw2sCfEmGyc/jHvzLJGmpw8XNHIq6+AXjQRwwy/QH4TKGE4ZJM0sej676ldgwho/YAwBhZWF7EO6mHpqktFTzvRmDSMGtopJJj1RQBuGLYf6AbGI8ZGcMRuXJHufU8cxZTEEoRVP68znIBrxuWbMADq2WISFLVK6LssRtlCIADQeOITkix98poeuzEluCCcwWKfxCxHmLKIC9Ah2qdJ3N3SVdvpGNgqUBGowOVgLtrbKXbxW4ESUe/Sr6+2ixENyNcfcEGDL8fr2yUJvabZg6U8IcK6Hu7Ha8pluAT2etCqmJynVG1zoIugdD1srusfkWwaLGRdcMZeDhjAlqG/wgYwv4qNh6oOupR0GysyRnM3HKF7hkh64qTmnhbPG1JWDKWkhPVgYnSY6+YgyaRuY6w0Rb/gJ3GuN7swUu2Jhls8k48Ak7GPrdydVOewe1ZxL33BMzDRiwpeX8AjgEt1FykDw+QHCXLXoZLnuoLhZ6xwovoEz5zPT83SQYtH78X3KyHkcHDn4KN2Og5PF27jS29vYVka/eobb1dzKcTl+gNT6MX0tb6vxaxR0goRwIe/odmVNyyOQj16HeyuBaPsVsONu2+iQmVoiw611gsa8kC5jEzFkW2G5Ql7Z045lbQlh/CeQGLOV+nzv/rRQ2ct+RtPN4E7m1Ld3ohbIz1NQysIB/YMA3I0OPooT5/ahcD+CSKw/XSQYeaFeB4anPdq52amTlygk9H5jjsR1T4cccnHSqIfKhbMtIRwaVX2oqhpwJN5gVgm8YJo2K+GFZ/1GtB4fxnQK89zT77bb03c+dD43QTStrgCFvyhqgTw6sDDURqDI6qiPq78YMC0KC/1IBFoEp1t5e5IElK2uPl65JPY8JP5JiqHLDfNN4/AaU06Rnwe7HNOL5VdiSnpkMd247HrodtGUFY/9atXftQZYccO3XqqWMU2yw8x4gEODzFqAa3Na+lCE5COeKv/YezdR02LG/zy+JG3vVnRdRdJ5Jcm4JraWwOT1X0JOWsFa6CS/Gk7IvF1drE5JQQl8+EsdVsEX/tETYvRhTrvnazy5xInGH+0sqQAW0qaXycm+hvyI2AViyJVIy2vlx4BOX2pGKKbfE1dW+AE5aj6an1uKGDABYum51FS9LNAv4a2qgFxWniIaf/YZdcCZxvGTlji2MOaw+7SF5PLWB/gQCwKOjH6A8+YA9XxVl2HV3hlb43rvjYvizsLcpVtzZt5ZXW6enanlxWVZ2KbNsh2mTC/0lSeh10prY5+54W4DlnKxkZah3blmE/IY5UUZbWF9Jja6J2hMUmz8j43XrxCevoTDmf+Ix1YKaSUJVwILAm3Hw4VvrHAncHEz743w4UNP8b4GtxvdFf/Sb8BQD88doQ2kn//8emf4sDoPa/XFhPAGXfRQCg9uwAgSf/E36StmFETuTnk1q5Pmr6UGr95GjnVPk3h21buISz6DNXjm6qK1Z8XecpOWQOYyoHWdZyFxqFrVo4hgo1aDtYZ3W5BFD95UZZcjV1NEqYs4Xxlq6rq4tb0RPtJiiXm6tpYwlupaZYuKMFHafRG9UcOloqGrqRnvNs969+w3N9wSknpOUes3n3q423daK2PlZLoJxSLBrBtPoI2g/2qpyc5Swt5fBpFUoqhejpJfmvLTlrX+k7YJcEmoWD2sW8HdNalH1Zlp7p8Yuow2WlJ4obFR29niWgxlgCtUmQLy2Dt9361xCFjUJrbdJYPcSTGMtmLase83eIdIyuxWBODyRqiqRyZtL8kqfsKKldQlK0juOXQwCqenqc092kvq/zNxjdLhbof4Fmh2mqVYR6q1a3U1h2I3bzU7kRDE47cVo07TLquoZeY/HIOvx8wOM+Y/y8hn22Y28S4T07tkNTNWpZI6ealpa0347SWY6yFeBgfaC75YmVEIaVKy1fG96m3ovKqqw0bbt4dfhPmD2f7WfJiWT2Ldm1SXbTImKYeTDmVB+Gya6o+ZenWA+1PRa/dn2GFu2JW7NcLRdr71xObZzeVlT91MvRrlKP3k3g2ebK7WEFd6BpObn31WaVeaev3D2WxVgCnA/xQqGbp+t3rf3SrexcwXuJtott4KQ5Mdpv8QCqdlo4TIDqHeFVoOL++Vd7f1WT3a80rAozv7Jk11d1hSG78VT5u3CzOPhlluc797tR9o2KvdeWShfE2HvHig6jPgDYTON1RJfP79l6rOrFXOudf6/r1VVqvH/NQbsvyr7tsLWgLxeEOg64CmQmW6T8Gq2V1c+F4gQ16HGFmQimObu5QH29ET2JxWOWMIez5qS2bl7ARyph1vCsaIj/0XMeW0s93a/vgG8VDRr7ICkvcBaSO+PMAxIo0x60HnyKPYptaBA/a+1XVttFw3wmhTD6wqzBXCYU3THAr+AxeMHy0fWhic4GHh2Nx1qh1wistEZuCxKgP03o9sI4sjdoQM918CPoBfLdE3qNYB+j1wb4FzQCHbAF3Lc1r/E+uv8w0JJUQxNYALpRidR+OFaGGh0f1voVZ3NaO72b4Lf/Jd4uH7fH1qHXGswxzB3VjPZ7UADQhtwGAeSEVeIS2QKMN1pcAPjvrpH/EyZv+5OkJKodbxR4Y5iKnAIKFpVAgkQ7YBCxDDja3AMZIomBgryrgdpguBuoCx8PA/UQ0Ryoj66eQAM0bfImffZDAVltABOiAAEIgmwMwBBlbwCFck4HECgpC6BhSGsAA+UQDmCxVp0AHoLuH+VH9GgRIKB6pAcEOKANDzyR3UnwVvrYCaQoCJrrf0+5FbhnzisDgzgZffGKhb9M3lToKXWxr1p8TIP3O/0ZH4gdDFSszHwWL799sEpFMmyELV3MrNYmUSOVtKta+lKLK6cACOIxNWv0JXD2/VDVN9Kr+prX19ZTEEIHeuuMl8DuhbRxwaTQuNR4EGvgskYtErm6B9LOsCL1Ioq2MhUyihT7PKpYdUL08nh9+/Z9208H7tyxE0hR7GjQXP97ym3BumfJ5pXZLh3EyegLtjq0hAszfOCmQr/ULjiLLyq9YLH+TE4GkgbdmNqGy/ufz+KlAHhhIuMZNo36LQ1U2tokamTbk3a/7vouUiwKmWNb5rfGU7PmsPLglXGmSK3KXEhQc3x9bRcWSBKORPrBmEy2Aeq9kDYu5MIUGteZexncqm9d1mg6c+GLvQq0AxtzpV5EU9N2q8I2uYp9vlBbtWOhqffyeH1LHIRIswZH6ZWnWN9VRDOyJ+QEgOhqhWgwYMGBxJxfIoZhQmsmiQhRYsTtYSY1f1IyChmy5MhToPjNymIa0PI7M2TE2Frez4IlK9ZQoYnLjNX5OXDhUQAfAUJ4mUmbK6MYOSUo9OVCFWo0aG+7Hf1Fuiy3fQ6KrwaDHPlcbGUJUzVDApaZWIoEpIoRVUYJ0NSKoOWk9qutp5Yj6xodjqfz5UZc/uTuHx45VV1OcHk8qiQvM3GsMF5UUl6Cp1KAGTzVpE5vMDNT45byCuSw0GavcvznVv8P7Kytq29wuT2NTc0trW3twZC/EI5EY/FEMpXOZHP5QrFUrlRr9Uaz1e50e/3BcDSeTGfzxXK13mx3+8PxdL5cb/fH8/X+fH9/WVE13TAt23E9PwijOJkRC8wXy9V6s93tD8fT+XK93R/P1/vz/f2TNMuLsqqbtuuHEeQvDGBRoa8QoS/lp7MW/RUHWa2jdfUP0B8JUn4Ri6M4hvyCtlvMrsMQ3neP6zXufdD+R6DD/F1mvw70sQv6jIASkUq/3iASxkVqSgyEcSHV1hrrIgWXCTFhXChtbFpXCAjjQiptrAtQWk1QOtwaAMSEMi4SGBsb69KzTogJVdpYl1YNAIgwoUxI69JayqZAQnMgtS0ASCjjIhLaAlRsSZn07DASntpbmINI6yv42Sfacwgr9Of6/ctvVZGW8Vy8/GGZy8Nnhb/McGoPeh5IPQjgDXsEGAcQpjI1g7u19xBAlBZlSJvLYAUQ4nCrCHgpxoVJa1BYOAjJ+TgyLhOexFCtAu1ebwYSOgQpWWtnmVDGldTGuvTsEWJCGRcy0Gsw1qVXHwBEmNCA1zeQ1s2C1Rwdgwn3GtuMbGf1GrbHGZzDGSRvH3ipFWe9nkTsUjNRCZ1EZYMdhZV+AKupAyet0zEQZPgXm63uVxmfmWcP/kla8n9x3eFQHdgp3+A8LAlF82Xfp/k8Y3ZTu4mdSK0PvpoXZqZu2c7jn/LLyPP8t8mVS/9DfNQIgiHEJ10wljCwf30dUl/571LN1O+Zb9N64i98NJ2e9N6f3e8ww57/455o7G3Jv2ncJE6kXp/v8ffK50j6FzCwf9OGbWA/DQA="

/***/ }),
/* 61 */
/***/ (function(module, exports) {

module.exports = "data:application/font-woff;base64,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"

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__.p + "../Views/cf55a1d7e6ac44f8abad4edf7c5ca20d.ttf";

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {!function(t,e){ true?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.Vuetable=e():t.Vuetable=e()}(this,function(){return function(t){function e(i){if(n[i])return n[i].exports;var r=n[i]={i:i,l:!1,exports:{}};return t[i].call(r.exports,r,r.exports,e),r.l=!0,r.exports}var n={};return e.m=t,e.c=n,e.i=function(t){return t},e.d=function(t,n,i){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:i})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="/",e(e.s=40)}([function(t,e,n){"use strict";function i(t){return"[object Array]"===x.call(t)}function r(t){return"[object ArrayBuffer]"===x.call(t)}function a(t){return"undefined"!=typeof FormData&&t instanceof FormData}function o(t){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(t):t&&t.buffer&&t.buffer instanceof ArrayBuffer}function s(t){return"string"==typeof t}function l(t){return"number"==typeof t}function c(t){return void 0===t}function u(t){return null!==t&&"object"==typeof t}function f(t){return"[object Date]"===x.call(t)}function d(t){return"[object File]"===x.call(t)}function h(t){return"[object Blob]"===x.call(t)}function p(t){return"[object Function]"===x.call(t)}function g(t){return u(t)&&p(t.pipe)}function m(t){return"undefined"!=typeof URLSearchParams&&t instanceof URLSearchParams}function v(t){return t.replace(/^\s*/,"").replace(/\s*$/,"")}function b(){return"undefined"!=typeof window&&"undefined"!=typeof document&&"function"==typeof document.createElement}function y(t,e){if(null!==t&&void 0!==t)if("object"==typeof t||i(t)||(t=[t]),i(t))for(var n=0,r=t.length;n<r;n++)e.call(null,t[n],n,t);else for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&e.call(null,t[a],a,t)}function w(){function t(t,n){"object"==typeof e[n]&&"object"==typeof t?e[n]=w(e[n],t):e[n]=t}for(var e={},n=0,i=arguments.length;n<i;n++)y(arguments[n],t);return e}function _(t,e,n){return y(e,function(e,i){t[i]=n&&"function"==typeof e?P(e,n):e}),t}var P=n(9),x=Object.prototype.toString;t.exports={isArray:i,isArrayBuffer:r,isFormData:a,isArrayBufferView:o,isString:s,isNumber:l,isObject:u,isUndefined:c,isDate:f,isFile:d,isBlob:h,isFunction:p,isStream:g,isURLSearchParams:m,isStandardBrowserEnv:b,forEach:y,merge:w,extend:_,trim:v}},function(t,e){t.exports=function(t,e,n,i,r){var a,o=t=t||{},s=typeof t.default;"object"!==s&&"function"!==s||(a=t,o=t.default);var l="function"==typeof o?o.options:o;e&&(l.render=e.render,l.staticRenderFns=e.staticRenderFns),i&&(l._scopeId=i);var c;if(r?(c=function(t){t=t||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext,t||"undefined"==typeof __VUE_SSR_CONTEXT__||(t=__VUE_SSR_CONTEXT__),n&&n.call(this,t),t&&t._registeredComponents&&t._registeredComponents.add(r)},l._ssrRegister=c):n&&(c=n),c){var u=l.functional,f=u?l.render:l.beforeCreate;u?l.render=function(t,e){return c.call(e),f(t,e)}:l.beforeCreate=f?[].concat(f,c):[c]}return{esModule:a,exports:o,options:l}}},function(t,e,n){var i=n(1)(n(39),null,null,null,null);t.exports=i.exports},function(t,e,n){"use strict";(function(e){function i(t,e){!r.isUndefined(t)&&r.isUndefined(t["Content-Type"])&&(t["Content-Type"]=e)}var r=n(0),a=n(31),o=/^\)\]\}',?\n/,s={"Content-Type":"application/x-www-form-urlencoded"},l={adapter:function(){var t;return"undefined"!=typeof XMLHttpRequest?t=n(5):void 0!==e&&(t=n(5)),t}(),transformRequest:[function(t,e){return a(e,"Content-Type"),r.isFormData(t)||r.isArrayBuffer(t)||r.isStream(t)||r.isFile(t)||r.isBlob(t)?t:r.isArrayBufferView(t)?t.buffer:r.isURLSearchParams(t)?(i(e,"application/x-www-form-urlencoded;charset=utf-8"),t.toString()):r.isObject(t)?(i(e,"application/json;charset=utf-8"),JSON.stringify(t)):t}],transformResponse:[function(t){if("string"==typeof t){t=t.replace(o,"");try{t=JSON.parse(t)}catch(t){}}return t}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,validateStatus:function(t){return t>=200&&t<300}};l.headers={common:{Accept:"application/json, text/plain, */*"}},r.forEach(["delete","get","head"],function(t){l.headers[t]={}}),r.forEach(["post","put","patch"],function(t){l.headers[t]=r.merge(s)}),t.exports=l}).call(e,n(10))},function(t,e,n){var i=n(1)(n(38),null,null,null,null);t.exports=i.exports},function(t,e,n){"use strict";var i=n(0),r=n(23),a=n(26),o=n(32),s=n(30),l=n(8),c="undefined"!=typeof window&&window.btoa&&window.btoa.bind(window)||n(25);t.exports=function(t){return new Promise(function(e,u){var f=t.data,d=t.headers;i.isFormData(f)&&delete d["Content-Type"];var h=new XMLHttpRequest,p="onreadystatechange",g=!1;if("undefined"==typeof window||!window.XDomainRequest||"withCredentials"in h||s(t.url)||(h=new window.XDomainRequest,p="onload",g=!0,h.onprogress=function(){},h.ontimeout=function(){}),t.auth){var m=t.auth.username||"",v=t.auth.password||"";d.Authorization="Basic "+c(m+":"+v)}if(h.open(t.method.toUpperCase(),a(t.url,t.params,t.paramsSerializer),!0),h.timeout=t.timeout,h[p]=function(){if(h&&(4===h.readyState||g)&&(0!==h.status||h.responseURL&&0===h.responseURL.indexOf("file:"))){var n="getAllResponseHeaders"in h?o(h.getAllResponseHeaders()):null,i=t.responseType&&"text"!==t.responseType?h.response:h.responseText,a={data:i,status:1223===h.status?204:h.status,statusText:1223===h.status?"No Content":h.statusText,headers:n,config:t,request:h};r(e,u,a),h=null}},h.onerror=function(){u(l("Network Error",t)),h=null},h.ontimeout=function(){u(l("timeout of "+t.timeout+"ms exceeded",t,"ECONNABORTED")),h=null},i.isStandardBrowserEnv()){var b=n(28),y=(t.withCredentials||s(t.url))&&t.xsrfCookieName?b.read(t.xsrfCookieName):void 0;y&&(d[t.xsrfHeaderName]=y)}if("setRequestHeader"in h&&i.forEach(d,function(t,e){void 0===f&&"content-type"===e.toLowerCase()?delete d[e]:h.setRequestHeader(e,t)}),t.withCredentials&&(h.withCredentials=!0),t.responseType)try{h.responseType=t.responseType}catch(t){if("json"!==h.responseType)throw t}"function"==typeof t.onDownloadProgress&&h.addEventListener("progress",t.onDownloadProgress),"function"==typeof t.onUploadProgress&&h.upload&&h.upload.addEventListener("progress",t.onUploadProgress),t.cancelToken&&t.cancelToken.promise.then(function(t){h&&(h.abort(),u(t),h=null)}),void 0===f&&(f=null),h.send(f)})}},function(t,e,n){"use strict";function i(t){this.message=t}i.prototype.toString=function(){return"Cancel"+(this.message?": "+this.message:"")},i.prototype.__CANCEL__=!0,t.exports=i},function(t,e,n){"use strict";t.exports=function(t){return!(!t||!t.__CANCEL__)}},function(t,e,n){"use strict";var i=n(22);t.exports=function(t,e,n,r){var a=new Error(t);return i(a,e,n,r)}},function(t,e,n){"use strict";t.exports=function(t,e){return function(){for(var n=new Array(arguments.length),i=0;i<n.length;i++)n[i]=arguments[i];return t.apply(e,n)}}},function(t,e){function n(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}function r(t){if(u===setTimeout)return setTimeout(t,0);if((u===n||!u)&&setTimeout)return u=setTimeout,setTimeout(t,0);try{return u(t,0)}catch(e){try{return u.call(null,t,0)}catch(e){return u.call(this,t,0)}}}function a(t){if(f===clearTimeout)return clearTimeout(t);if((f===i||!f)&&clearTimeout)return f=clearTimeout,clearTimeout(t);try{return f(t)}catch(e){try{return f.call(null,t)}catch(e){return f.call(this,t)}}}function o(){g&&h&&(g=!1,h.length?p=h.concat(p):m=-1,p.length&&s())}function s(){if(!g){var t=r(o);g=!0;for(var e=p.length;e;){for(h=p,p=[];++m<e;)h&&h[m].run();m=-1,e=p.length}h=null,g=!1,a(t)}}function l(t,e){this.fun=t,this.array=e}function c(){}var u,f,d=t.exports={};!function(){try{u="function"==typeof setTimeout?setTimeout:n}catch(t){u=n}try{f="function"==typeof clearTimeout?clearTimeout:i}catch(t){f=i}}();var h,p=[],g=!1,m=-1;d.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var n=1;n<arguments.length;n++)e[n-1]=arguments[n];p.push(new l(t,e)),1!==p.length||g||r(s)},l.prototype.run=function(){this.fun.apply(null,this.array)},d.title="browser",d.browser=!0,d.env={},d.argv=[],d.version="",d.versions={},d.on=c,d.addListener=c,d.once=c,d.off=c,d.removeListener=c,d.removeAllListeners=c,d.emit=c,d.prependListener=c,d.prependOnceListener=c,d.listeners=function(t){return[]},d.binding=function(t){throw new Error("process.binding is not supported")},d.cwd=function(){return"/"},d.chdir=function(t){throw new Error("process.chdir is not supported")},d.umask=function(){return 0}},function(t,e,n){(function(e){!function(n){function i(){}function r(t,e){return function(){t.apply(e,arguments)}}function a(t){if("object"!=typeof this)throw new TypeError("Promises must be constructed via new");if("function"!=typeof t)throw new TypeError("not a function");this._state=0,this._handled=!1,this._value=void 0,this._deferreds=[],f(t,this)}function o(t,e){for(;3===t._state;)t=t._value;if(0===t._state)return void t._deferreds.push(e);t._handled=!0,a._immediateFn(function(){var n=1===t._state?e.onFulfilled:e.onRejected;if(null===n)return void(1===t._state?s:l)(e.promise,t._value);var i;try{i=n(t._value)}catch(t){return void l(e.promise,t)}s(e.promise,i)})}function s(t,e){try{if(e===t)throw new TypeError("A promise cannot be resolved with itself.");if(e&&("object"==typeof e||"function"==typeof e)){var n=e.then;if(e instanceof a)return t._state=3,t._value=e,void c(t);if("function"==typeof n)return void f(r(n,e),t)}t._state=1,t._value=e,c(t)}catch(e){l(t,e)}}function l(t,e){t._state=2,t._value=e,c(t)}function c(t){2===t._state&&0===t._deferreds.length&&a._immediateFn(function(){t._handled||a._unhandledRejectionFn(t._value)});for(var e=0,n=t._deferreds.length;e<n;e++)o(t,t._deferreds[e]);t._deferreds=null}function u(t,e,n){this.onFulfilled="function"==typeof t?t:null,this.onRejected="function"==typeof e?e:null,this.promise=n}function f(t,e){var n=!1;try{t(function(t){n||(n=!0,s(e,t))},function(t){n||(n=!0,l(e,t))})}catch(t){if(n)return;n=!0,l(e,t)}}var d=setTimeout;a.prototype.catch=function(t){return this.then(null,t)},a.prototype.then=function(t,e){var n=new this.constructor(i);return o(this,new u(t,e,n)),n},a.all=function(t){var e=Array.prototype.slice.call(t);return new a(function(t,n){function i(a,o){try{if(o&&("object"==typeof o||"function"==typeof o)){var s=o.then;if("function"==typeof s)return void s.call(o,function(t){i(a,t)},n)}e[a]=o,0==--r&&t(e)}catch(t){n(t)}}if(0===e.length)return t([]);for(var r=e.length,a=0;a<e.length;a++)i(a,e[a])})},a.resolve=function(t){return t&&"object"==typeof t&&t.constructor===a?t:new a(function(e){e(t)})},a.reject=function(t){return new a(function(e,n){n(t)})},a.race=function(t){return new a(function(e,n){for(var i=0,r=t.length;i<r;i++)t[i].then(e,n)})},a._immediateFn="function"==typeof e&&function(t){e(t)}||function(t){d(t,0)},a._unhandledRejectionFn=function(t){"undefined"!=typeof console&&console&&console.warn("Possible Unhandled Promise Rejection:",t)},a._setImmediateFn=function(t){a._immediateFn=t},a._setUnhandledRejectionFn=function(t){a._unhandledRejectionFn=t},void 0!==t&&t.exports?t.exports=a:n.Promise||(n.Promise=a)}(this)}).call(e,n(44).setImmediate)},function(t,e,n){function i(t){n(49)}var r=n(1)(n(34),n(46),i,"data-v-5cc42bfc",null);t.exports=r.exports},function(t,e,n){var i=n(1)(n(35),n(47),null,null,null);t.exports=i.exports},function(t,e,n){var i=n(1)(n(36),n(45),null,null,null);t.exports=i.exports},function(t,e,n){var i=n(1)(n(37),n(48),null,null,null);t.exports=i.exports},function(t,e,n){t.exports=n(17)},function(t,e,n){"use strict";function i(t){var e=new o(t),n=a(o.prototype.request,e);return r.extend(n,o.prototype,e),r.extend(n,e),n}var r=n(0),a=n(9),o=n(19),s=n(3),l=i(s);l.Axios=o,l.create=function(t){return i(r.merge(s,t))},l.Cancel=n(6),l.CancelToken=n(18),l.isCancel=n(7),l.all=function(t){return Promise.all(t)},l.spread=n(33),t.exports=l,t.exports.default=l},function(t,e,n){"use strict";function i(t){if("function"!=typeof t)throw new TypeError("executor must be a function.");var e;this.promise=new Promise(function(t){e=t});var n=this;t(function(t){n.reason||(n.reason=new r(t),e(n.reason))})}var r=n(6);i.prototype.throwIfRequested=function(){if(this.reason)throw this.reason},i.source=function(){var t;return{token:new i(function(e){t=e}),cancel:t}},t.exports=i},function(t,e,n){"use strict";function i(t){this.defaults=t,this.interceptors={request:new o,response:new o}}var r=n(3),a=n(0),o=n(20),s=n(21),l=n(29),c=n(27);i.prototype.request=function(t){"string"==typeof t&&(t=a.merge({url:arguments[0]},arguments[1])),t=a.merge(r,this.defaults,{method:"get"},t),t.baseURL&&!l(t.url)&&(t.url=c(t.baseURL,t.url));var e=[s,void 0],n=Promise.resolve(t);for(this.interceptors.request.forEach(function(t){e.unshift(t.fulfilled,t.rejected)}),this.interceptors.response.forEach(function(t){e.push(t.fulfilled,t.rejected)});e.length;)n=n.then(e.shift(),e.shift());return n},a.forEach(["delete","get","head"],function(t){i.prototype[t]=function(e,n){return this.request(a.merge(n||{},{method:t,url:e}))}}),a.forEach(["post","put","patch"],function(t){i.prototype[t]=function(e,n,i){return this.request(a.merge(i||{},{method:t,url:e,data:n}))}}),t.exports=i},function(t,e,n){"use strict";function i(){this.handlers=[]}var r=n(0);i.prototype.use=function(t,e){return this.handlers.push({fulfilled:t,rejected:e}),this.handlers.length-1},i.prototype.eject=function(t){this.handlers[t]&&(this.handlers[t]=null)},i.prototype.forEach=function(t){r.forEach(this.handlers,function(e){null!==e&&t(e)})},t.exports=i},function(t,e,n){"use strict";function i(t){t.cancelToken&&t.cancelToken.throwIfRequested()}var r=n(0),a=n(24),o=n(7),s=n(3);t.exports=function(t){return i(t),t.headers=t.headers||{},t.data=a(t.data,t.headers,t.transformRequest),t.headers=r.merge(t.headers.common||{},t.headers[t.method]||{},t.headers||{}),r.forEach(["delete","get","head","post","put","patch","common"],function(e){delete t.headers[e]}),(t.adapter||s.adapter)(t).then(function(e){return i(t),e.data=a(e.data,e.headers,t.transformResponse),e},function(e){return o(e)||(i(t),e&&e.response&&(e.response.data=a(e.response.data,e.response.headers,t.transformResponse))),Promise.reject(e)})}},function(t,e,n){"use strict";t.exports=function(t,e,n,i){return t.config=e,n&&(t.code=n),t.response=i,t}},function(t,e,n){"use strict";var i=n(8);t.exports=function(t,e,n){var r=n.config.validateStatus;n.status&&r&&!r(n.status)?e(i("Request failed with status code "+n.status,n.config,null,n)):t(n)}},function(t,e,n){"use strict";var i=n(0);t.exports=function(t,e,n){return i.forEach(n,function(n){t=n(t,e)}),t}},function(t,e,n){"use strict";function i(){this.message="String contains an invalid character"}function r(t){for(var e,n,r=String(t),o="",s=0,l=a;r.charAt(0|s)||(l="=",s%1);o+=l.charAt(63&e>>8-s%1*8)){if((n=r.charCodeAt(s+=.75))>255)throw new i;e=e<<8|n}return o}var a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";i.prototype=new Error,i.prototype.code=5,i.prototype.name="InvalidCharacterError",t.exports=r},function(t,e,n){"use strict";function i(t){return encodeURIComponent(t).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}var r=n(0);t.exports=function(t,e,n){if(!e)return t;var a;if(n)a=n(e);else if(r.isURLSearchParams(e))a=e.toString();else{var o=[];r.forEach(e,function(t,e){null!==t&&void 0!==t&&(r.isArray(t)&&(e+="[]"),r.isArray(t)||(t=[t]),r.forEach(t,function(t){r.isDate(t)?t=t.toISOString():r.isObject(t)&&(t=JSON.stringify(t)),o.push(i(e)+"="+i(t))}))}),a=o.join("&")}return a&&(t+=(-1===t.indexOf("?")?"?":"&")+a),t}},function(t,e,n){"use strict";t.exports=function(t,e){return t.replace(/\/+$/,"")+"/"+e.replace(/^\/+/,"")}},function(t,e,n){"use strict";var i=n(0);t.exports=i.isStandardBrowserEnv()?function(){return{write:function(t,e,n,r,a,o){var s=[];s.push(t+"="+encodeURIComponent(e)),i.isNumber(n)&&s.push("expires="+new Date(n).toGMTString()),i.isString(r)&&s.push("path="+r),i.isString(a)&&s.push("domain="+a),!0===o&&s.push("secure"),document.cookie=s.join("; ")},read:function(t){var e=document.cookie.match(new RegExp("(^|;\\s*)("+t+")=([^;]*)"));return e?decodeURIComponent(e[3]):null},remove:function(t){this.write(t,"",Date.now()-864e5)}}}():function(){return{write:function(){},read:function(){return null},remove:function(){}}}()},function(t,e,n){"use strict";t.exports=function(t){return/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(t)}},function(t,e,n){"use strict";var i=n(0);t.exports=i.isStandardBrowserEnv()?function(){function t(t){var e=t;return n&&(r.setAttribute("href",e),e=r.href),r.setAttribute("href",e),{href:r.href,protocol:r.protocol?r.protocol.replace(/:$/,""):"",host:r.host,search:r.search?r.search.replace(/^\?/,""):"",hash:r.hash?r.hash.replace(/^#/,""):"",hostname:r.hostname,port:r.port,pathname:"/"===r.pathname.charAt(0)?r.pathname:"/"+r.pathname}}var e,n=/(msie|trident)/i.test(navigator.userAgent),r=document.createElement("a");return e=t(window.location.href),function(n){var r=i.isString(n)?t(n):n;return r.protocol===e.protocol&&r.host===e.host}}():function(){return function(){return!0}}()},function(t,e,n){"use strict";var i=n(0);t.exports=function(t,e){i.forEach(t,function(n,i){i!==e&&i.toUpperCase()===e.toUpperCase()&&(t[e]=n,delete t[i])})}},function(t,e,n){"use strict";var i=n(0);t.exports=function(t){var e,n,r,a={};return t?(i.forEach(t.split("\n"),function(t){r=t.indexOf(":"),e=i.trim(t.substr(0,r)).toLowerCase(),n=i.trim(t.substr(r+1)),e&&(a[e]=a[e]?a[e]+", "+n:n)}),a):a}},function(t,e,n){"use strict";t.exports=function(t){return function(e){return t.apply(null,e)}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(16),r=function(t){return t&&t.__esModule?t:{default:t}}(i);e.default={props:{fields:{type:Array,required:!0},loadOnStart:{type:Boolean,default:!0},apiUrl:{type:String,default:""},httpMethod:{type:String,default:"get",validator:function(t){return["get","post"].indexOf(t)>-1}},reactiveApiUrl:{type:Boolean,default:!0},apiMode:{type:Boolean,default:!0},data:{type:[Array,Object],default:function(){return null}},dataTotal:{type:Number,default:0},dataManager:{type:Function,default:function(){return null}},dataPath:{type:String,default:"data"},paginationPath:{type:[String],default:"links.pagination"},queryParams:{type:Object,default:function(){return{sort:"sort",page:"page",perPage:"per_page"}}},appendParams:{type:Object,default:function(){return{}}},httpOptions:{type:Object,default:function(){return{}}},perPage:{type:Number,default:function(){return 10}},sortOrder:{type:Array,default:function(){return[]}},multiSort:{type:Boolean,default:function(){return!1}},multiSortKey:{type:String,default:"alt"},rowClassCallback:{type:[String,Function],default:""},rowClass:{type:[String,Function],default:""},detailRowComponent:{type:String,default:""},detailRowTransition:{type:String,default:""},trackBy:{type:String,default:"id"},css:{type:Object,default:function(){return{tableClass:"ui blue selectable celled stackable attached table",loadingClass:"loading",ascendingIcon:"blue chevron up icon",descendingIcon:"blue chevron down icon",detailRowClass:"vuetable-detail-row",handleIcon:"grey sidebar icon"}}},minRows:{type:Number,default:0},silent:{type:Boolean,default:!1},noDataTemplate:{type:String,default:function(){return"No Data Available"}}},data:function(){return{eventPrefix:"vuetable:",tableFields:[],tableData:null,tablePagination:null,currentPage:1,selectedTo:[],visibleDetailRows:[]}},mounted:function(){this.normalizeFields(),this.$nextTick(function(){this.fireEvent("initialized",this.tableFields)}),this.loadOnStart&&this.loadData()},computed:{useDetailRow:function(){return this.tableData&&this.tableData[0]&&""!==this.detailRowComponent&&void 0===this.tableData[0][this.trackBy]?(this.warn("You need to define unique row identifier in order for detail-row feature to work. Use `track-by` prop to define one!"),!1):""!==this.detailRowComponent},countVisibleFields:function(){return this.tableFields.filter(function(t){return t.visible}).length},countTableData:function(){return null===this.tableData?0:this.tableData.length},displayEmptyDataRow:function(){return 0===this.countTableData&&this.noDataTemplate.length>0},lessThanMinRows:function(){return null===this.tableData||0===this.tableData.length||this.tableData.length<this.minRows},blankRows:function(){return null===this.tableData||0===this.tableData.length?this.minRows:this.tableData.length>=this.minRows?0:this.minRows-this.tableData.length},isApiMode:function(){return this.apiMode},isDataMode:function(){return!this.apiMode}},methods:{normalizeFields:function(){if(void 0===this.fields)return void this.warn('You need to provide "fields" prop.');this.tableFields=[];var t=this,e=void 0;this.fields.forEach(function(n,i){e="string"==typeof n?{name:n,title:t.setTitle(n),titleClass:"",dataClass:"",callback:null,visible:!0}:{name:n.name,title:void 0===n.title?t.setTitle(n.name):n.title,sortField:n.sortField,titleClass:void 0===n.titleClass?"":n.titleClass,dataClass:void 0===n.dataClass?"":n.dataClass,callback:void 0===n.callback?"":n.callback,visible:void 0===n.visible||n.visible},t.tableFields.push(e)})},setData:function(t){if(this.apiMode=!1,Array.isArray(t))return void(this.tableData=t);this.fireEvent("loading"),this.tableData=this.getObjectValue(t,this.dataPath,null),this.tablePagination=this.getObjectValue(t,this.paginationPath,null),this.$nextTick(function(){this.fireEvent("pagination-data",this.tablePagination),this.fireEvent("loaded")})},setTitle:function(t){return this.isSpecialField(t)?"":this.titleCase(t)},renderTitle:function(t){var e=void 0===t.title?t.name.replace("."," "):t.title;if(e.length>0&&this.isInCurrentSortGroup(t)){var n="opacity:"+this.sortIconOpacity(t)+";position:relative;float:right";return e+" "+this.renderIconTag(["sort-icon",this.sortIcon(t)],'style="'+n+'"')}return e},renderSequence:function(t){return this.tablePagination?this.tablePagination.from+t:t},isSpecialField:function(t){return"__"===t.slice(0,2)},titleCase:function(t){return t.replace(/\w+/g,function(t){return t.charAt(0).toUpperCase()+t.substr(1).toLowerCase()})},camelCase:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"_",n=this;return t.split(e).map(function(t){return n.titleCase(t)}).join("")},notIn:function(t,e){return-1===e.indexOf(t)},loadData:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.loadSuccess,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.loadFailed;if(this.isDataMode)return void this.callDataManager();this.fireEvent("loading"),this.httpOptions.params=this.getAllQueryParams(),r.default[this.httpMethod](this.apiUrl,this.httpOptions).then(t,e).catch(function(){return e()})},loadSuccess:function(t){this.fireEvent("load-success",t);var e=this.transform(t.data);this.tableData=this.getObjectValue(e,this.dataPath,null),this.tablePagination=this.getObjectValue(e,this.paginationPath,null),null===this.tablePagination&&this.warn('vuetable: pagination-path "'+this.paginationPath+'" not found. It looks like the data returned from the sever does not have pagination information or you may have set it incorrectly.\nYou can explicitly suppress this warning by setting pagination-path="".'),this.$nextTick(function(){this.fireEvent("pagination-data",this.tablePagination),this.fireEvent("loaded")})},loadFailed:function(t){console.error("load-error",t),this.fireEvent("load-error",t),this.fireEvent("loaded")},transform:function(t){return this.parentFunctionExists("transform")?this.$parent.transform.call(this.$parent,t):t},parentFunctionExists:function(t){return""!==t&&"function"==typeof this.$parent[t]},callParentFunction:function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;return this.parentFunctionExists(t)?this.$parent[t].call(this.$parent,e):n},fireEvent:function(t,e){this.$emit(this.eventPrefix+t,e)},warn:function(t){this.silent||console.warn(t)},getAllQueryParams:function(){var t={};t[this.queryParams.sort]=this.getSortParam(),t[this.queryParams.page]=this.currentPage,t[this.queryParams.perPage]=this.perPage;for(var e in this.appendParams)t[e]=this.appendParams[e];return t},getSortParam:function(){return this.sortOrder&&""!=this.sortOrder.field?"function"==typeof this.$parent.getSortParam?this.$parent.getSortParam.call(this.$parent,this.sortOrder):this.getDefaultSortParam():""},getDefaultSortParam:function(){for(var t="",e=0;e<this.sortOrder.length;e++){t+=(void 0===this.sortOrder[e].sortField?this.sortOrder[e].field:this.sortOrder[e].sortField)+"|"+this.sortOrder[e].direction+(e+1<this.sortOrder.length?",":"")}return t},extractName:function(t){return t.split(":")[0].trim()},extractArgs:function(t){return t.split(":")[1]},isSortable:function(t){return!(void 0===t.sortField)},isInCurrentSortGroup:function(t){return!1!==this.currentSortOrderPosition(t)},currentSortOrderPosition:function(t){if(!this.isSortable(t))return!1;for(var e=0;e<this.sortOrder.length;e++)if(this.fieldIsInSortOrderPosition(t,e))return e;return!1},fieldIsInSortOrderPosition:function(t,e){return this.sortOrder[e].field===t.name&&this.sortOrder[e].sortField===t.sortField},orderBy:function(t,e){if(this.isSortable(t)){var n=this.multiSortKey.toLowerCase()+"Key";this.multiSort&&e[n]?this.multiColumnSort(t):this.singleColumnSort(t),this.currentPage=1,this.loadData()}},multiColumnSort:function(t){var e=this.currentSortOrderPosition(t);!1===e?this.sortOrder.push({field:t.name,sortField:t.sortField,direction:"asc"}):"asc"===this.sortOrder[e].direction?this.sortOrder[e].direction="desc":this.sortOrder.splice(e,1)},singleColumnSort:function(t){0===this.sortOrder.length&&this.clearSortOrder(),this.sortOrder.splice(1),this.fieldIsInSortOrderPosition(t,0)?this.sortOrder[0].direction="asc"===this.sortOrder[0].direction?"desc":"asc":this.sortOrder[0].direction="asc",this.sortOrder[0].field=t.name,this.sortOrder[0].sortField=t.sortField},clearSortOrder:function(){this.sortOrder.push({field:"",sortField:"",direction:"asc"})},sortIcon:function(t){var e="",n=this.currentSortOrderPosition(t);return!1!==n&&(e="asc"==this.sortOrder[n].direction?this.css.ascendingIcon:this.css.descendingIcon),e},sortIconOpacity:function(t){var e=.3,n=this.sortOrder.length,i=this.currentSortOrderPosition(t);return 1-n*e<.3&&(e=.7/(n-1)),1-i*e},hasCallback:function(t){return!!t.callback},callCallback:function(t,e){if(this.hasCallback(t)){if("function"==typeof t.callback)return t.callback(this.getObjectValue(e,t.name));var n=t.callback.split("|"),i=n.shift();if("function"==typeof this.$parent[i]){var r=this.getObjectValue(e,t.name);return n.length>0?this.$parent[i].apply(this.$parent,[r].concat(n)):this.$parent[i].call(this.$parent,r)}return null}},getObjectValue:function(t,e,n){n=void 0===n?null:n;var i=t;if(""!=e.trim()){e.split(".").forEach(function(t){if(null===i||void 0===i[t]||null===i[t])return void(i=n);i=i[t]})}return i},toggleCheckbox:function(t,e,n){var i=n.target.checked,r=this.trackBy;if(void 0===t[r])return void this.warn('__checkbox field: The "'+this.trackBy+'" field does not exist! Make sure the field you specify in "track-by" prop does exist.');var a=t[r];i?this.selectId(a):this.unselectId(a),this.$emit("vuetable:checkbox-toggled",i,t)},selectId:function(t){this.isSelectedRow(t)||this.selectedTo.push(t)},unselectId:function(t){this.selectedTo=this.selectedTo.filter(function(e){return e!==t})},isSelectedRow:function(t){return this.selectedTo.indexOf(t)>=0},rowSelected:function(t,e){var n=this.trackBy,i=t[n];return this.isSelectedRow(i)},checkCheckboxesState:function(t){if(this.tableData){var e=this,n=this.trackBy,i="th.vuetable-th-checkbox-"+n+" input[type=checkbox]",r=document.querySelectorAll(i);void 0===r.forEach&&(r.forEach=function(t){[].forEach.call(r,t)});var a=this.tableData.filter(function(t){return e.selectedTo.indexOf(t[n])>=0});return a.length<=0?(r.forEach(function(t){t.indeterminate=!1}),!1):a.length<this.perPage?(r.forEach(function(t){t.indeterminate=!0}),!0):(r.forEach(function(t){t.indeterminate=!1}),!0)}},toggleAllCheckboxes:function(t,e){var n=this,i=e.target.checked,r=this.trackBy;i?this.tableData.forEach(function(t){n.selectId(t[r])}):this.tableData.forEach(function(t){n.unselectId(t[r])}),this.$emit("vuetable:checkbox-toggled-all",i)},gotoPreviousPage:function(){this.currentPage>1&&(this.currentPage--,this.loadData())},gotoNextPage:function(){this.currentPage<this.tablePagination.last_page&&(this.currentPage++,this.loadData())},gotoPage:function(t){t!=this.currentPage&&t>0&&t<=this.tablePagination.last_page&&(this.currentPage=t,this.loadData())},isVisibleDetailRow:function(t){return this.visibleDetailRows.indexOf(t)>=0},showDetailRow:function(t){this.isVisibleDetailRow(t)||this.visibleDetailRows.push(t)},hideDetailRow:function(t){this.isVisibleDetailRow(t)&&this.visibleDetailRows.splice(this.visibleDetailRows.indexOf(t),1)},toggleDetailRow:function(t){this.isVisibleDetailRow(t)?this.hideDetailRow(t):this.showDetailRow(t)},showField:function(t){t<0||t>this.tableFields.length||(this.tableFields[t].visible=!0)},hideField:function(t){t<0||t>this.tableFields.length||(this.tableFields[t].visible=!1)},toggleField:function(t){t<0||t>this.tableFields.length||(this.tableFields[t].visible=!this.tableFields[t].visible)},renderIconTag:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return void 0===this.css.renderIcon?'<i class="'+t.join(" ")+'" '+e+"></i>":this.css.renderIcon(t,e)},makePagination:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;return t=null===t?this.dataTotal:t,e=null===e?this.perPage:e,n=null===n?this.currentPage:n,{total:t,per_page:e,current_page:n,last_page:Math.ceil(t/e)||0,next_page_url:"",prev_page_url:"",from:(n-1)*e+1,to:Math.min(n*e,t)}},normalizeSortOrder:function(){this.sortOrder.forEach(function(t){t.sortField=t.sortField||t.field})},callDataManager:function(){null===this.dataManager&&null===this.data||(Array.isArray(this.data)?(console.log("data mode: array"),this.setData(this.data)):(this.normalizeSortOrder(),this.setData(this.dataManager(this.sortOrder,this.makePagination()))))},onRowClass:function(t,e){return""!==this.rowClassCallback?void this.warn('"row-class-callback" prop is deprecated, please use "row-class" prop instead.'):"function"==typeof this.rowClass?this.rowClass(t,e):this.rowClass},onRowChanged:function(t){return this.fireEvent("row-changed",t),!0},onRowClicked:function(t,e){return this.$emit(this.eventPrefix+"row-clicked",t,e),!0},onRowDoubleClicked:function(t,e){this.$emit(this.eventPrefix+"row-dblclicked",t,e)},onDetailRowClick:function(t,e){this.$emit(this.eventPrefix+"detail-row-clicked",t,e)},onCellClicked:function(t,e,n){this.$emit(this.eventPrefix+"cell-clicked",t,e,n)},onCellDoubleClicked:function(t,e,n){this.$emit(this.eventPrefix+"cell-dblclicked",t,e,n)},changePage:function(t){"prev"===t?this.gotoPreviousPage():"next"===t?this.gotoNextPage():this.gotoPage(t)},reload:function(){this.loadData()},refresh:function(){this.currentPage=1,this.loadData()},resetData:function(){this.tableData=null,this.tablePagination=null,this.fireEvent("data-reset")}},watch:{multiSort:function(t,e){!1===t&&this.sortOrder.length>1&&(this.sortOrder.splice(1),this.loadData())},apiUrl:function(t,e){this.reactiveApiUrl&&t!==e&&this.refresh()}}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(2),r=function(t){return t&&t.__esModule?t:{default:t}}(i);e.default={mixins:[r.default]}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(2),r=function(t){return t&&t.__esModule?t:{default:t}}(i);e.default={mixins:[r.default],props:{pageText:{type:String,default:function(){return"Page"}}},methods:{registerEvents:function(){var t=this;this.$on("vuetable:pagination-data",function(e){t.setPaginationData(e)})}},created:function(){this.registerEvents()}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var i=n(4),r=function(t){return t&&t.__esModule?t:{default:t}}(i);e.default={mixins:[r.default]}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default={props:{css:{type:Object,default:function(){return{infoClass:"left floated left aligned six wide column"}}},infoTemplate:{type:String,default:function(){return"Displaying {from} to {to} of {total} items"}},noDataTemplate:{type:String,default:function(){return"No relevant data"}}},data:function(){return{tablePagination:null}},computed:{paginationInfo:function(){return null==this.tablePagination||0==this.tablePagination.total?this.noDataTemplate:this.infoTemplate.replace("{from}",this.tablePagination.from||0).replace("{to}",this.tablePagination.to||0).replace("{total}",this.tablePagination.total||0)}},methods:{setPaginationData:function(t){this.tablePagination=t},resetData:function(){this.tablePagination=null}}}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.default={props:{css:{type:Object,default:function(){return{wrapperClass:"ui right floated pagination menu",activeClass:"active large",disabledClass:"disabled",pageClass:"item",linkClass:"icon item",paginationClass:"ui bottom attached segment grid",paginationInfoClass:"left floated left aligned six wide column",dropdownClass:"ui search dropdown",icons:{first:"angle double left icon",prev:"left chevron icon",next:"right chevron icon",last:"angle double right icon"}}}},onEachSide:{type:Number,default:function(){return 2}}},data:function(){return{eventPrefix:"vuetable-pagination:",tablePagination:null}},computed:{totalPage:function(){return null===this.tablePagination?0:this.tablePagination.last_page},isOnFirstPage:function(){return null!==this.tablePagination&&1===this.tablePagination.current_page},isOnLastPage:function(){return null!==this.tablePagination&&this.tablePagination.current_page===this.tablePagination.last_page},notEnoughPages:function(){return this.totalPage<2*this.onEachSide+4},windowSize:function(){return 2*this.onEachSide+1},windowStart:function(){return!this.tablePagination||this.tablePagination.current_page<=this.onEachSide?1:this.tablePagination.current_page>=this.totalPage-this.onEachSide?this.totalPage-2*this.onEachSide:this.tablePagination.current_page-this.onEachSide}},methods:{loadPage:function(t){this.$emit(this.eventPrefix+"change-page",t)},isCurrentPage:function(t){return t===this.tablePagination.current_page},setPaginationData:function(t){this.tablePagination=t},resetData:function(){this.tablePagination=null}}}},function(t,e,n){"use strict";function i(t){return t&&t.__esModule?t:{default:t}}function r(t){t.component("vuetable",o.default),t.component("vuetable-pagination",l.default),t.component("vuetable-pagination-dropdown",u.default),t.component("vuetable-pagination-info",d.default)}Object.defineProperty(e,"__esModule",{value:!0}),e.install=e.VuetablePaginationInfoMixin=e.VuetablePaginationMixin=e.VuetablePaginationInfo=e.VuetablePaginationDropDown=e.VuetablePagination=e.Vuetable=void 0;var a=n(12),o=i(a),s=n(13),l=i(s),c=n(14),u=i(c),f=n(15),d=i(f),h=n(2),p=i(h),g=n(4),m=i(g),v=n(11),b=i(v);window.Promise||(window.Promise=b.default),e.Vuetable=o.default,e.VuetablePagination=l.default,e.VuetablePaginationDropDown=u.default,e.VuetablePaginationInfo=d.default,e.VuetablePaginationMixin=p.default,e.VuetablePaginationInfoMixin=m.default,e.install=r,e.default=o.default},function(t,e,n){e=t.exports=n(42)(!1),e.push([t.i,"\n[v-cloak][data-v-5cc42bfc] {\n  display: none;\n}\n.vuetable th.sortable[data-v-5cc42bfc]:hover {\n  color: #2185d0;\n  cursor: pointer;\n}\n.vuetable-actions[data-v-5cc42bfc] {\n  width: 15%;\n  padding: 12px 0px;\n  text-align: center;\n}\n.vuetable-pagination[data-v-5cc42bfc] {\n  background: #f9fafb !important;\n}\n.vuetable-pagination-info[data-v-5cc42bfc] {\n  margin-top: auto;\n  margin-bottom: auto;\n}\n.vuetable-empty-result[data-v-5cc42bfc] {\n  text-align: center;\n}\n",""])},function(t,e){function n(t,e){var n=t[1]||"",r=t[3];if(!r)return n;if(e&&"function"==typeof btoa){var a=i(r);return[n].concat(r.sources.map(function(t){return"/*# sourceURL="+r.sourceRoot+t+" */"})).concat([a]).join("\n")}return[n].join("\n")}function i(t){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(t))))+" */"}t.exports=function(t){var e=[];return e.toString=function(){return this.map(function(e){var i=n(e,t);return e[2]?"@media "+e[2]+"{"+i+"}":i}).join("")},e.i=function(t,n){"string"==typeof t&&(t=[[null,t,""]]);for(var i={},r=0;r<this.length;r++){var a=this[r][0];"number"==typeof a&&(i[a]=!0)}for(r=0;r<t.length;r++){var o=t[r];"number"==typeof o[0]&&i[o[0]]||(n&&!o[2]?o[2]=n:n&&(o[2]="("+o[2]+") and ("+n+")"),e.push(o))}},e}},function(t,e,n){(function(t,e){!function(t,n){"use strict";function i(t){"function"!=typeof t&&(t=new Function(""+t));for(var e=new Array(arguments.length-1),n=0;n<e.length;n++)e[n]=arguments[n+1];var i={callback:t,args:e};return c[l]=i,s(l),l++}function r(t){delete c[t]}function a(t){var e=t.callback,i=t.args;switch(i.length){case 0:e();break;case 1:e(i[0]);break;case 2:e(i[0],i[1]);break;case 3:e(i[0],i[1],i[2]);break;default:e.apply(n,i)}}function o(t){if(u)setTimeout(o,0,t);else{var e=c[t];if(e){u=!0;try{a(e)}finally{r(t),u=!1}}}}if(!t.setImmediate){var s,l=1,c={},u=!1,f=t.document,d=Object.getPrototypeOf&&Object.getPrototypeOf(t);d=d&&d.setTimeout?d:t,"[object process]"==={}.toString.call(t.process)?function(){s=function(t){e.nextTick(function(){o(t)})}}():function(){if(t.postMessage&&!t.importScripts){var e=!0,n=t.onmessage;return t.onmessage=function(){e=!1},t.postMessage("","*"),t.onmessage=n,e}}()?function(){var e="setImmediate$"+Math.random()+"$",n=function(n){n.source===t&&"string"==typeof n.data&&0===n.data.indexOf(e)&&o(+n.data.slice(e.length))};t.addEventListener?t.addEventListener("message",n,!1):t.attachEvent("onmessage",n),s=function(n){t.postMessage(e+n,"*")}}():t.MessageChannel?function(){var t=new MessageChannel;t.port1.onmessage=function(t){o(t.data)},s=function(e){t.port2.postMessage(e)}}():f&&"onreadystatechange"in f.createElement("script")?function(){var t=f.documentElement;s=function(e){var n=f.createElement("script");n.onreadystatechange=function(){o(e),n.onreadystatechange=null,t.removeChild(n),n=null},t.appendChild(n)}}():function(){s=function(t){setTimeout(o,0,t)}}(),d.setImmediate=i,d.clearImmediate=r}}("undefined"==typeof self?void 0===t?this:t:self)}).call(e,n(52),n(10))},function(t,e,n){function i(t,e){this._id=t,this._clearFn=e}var r=Function.prototype.apply;e.setTimeout=function(){return new i(r.call(setTimeout,window,arguments),clearTimeout)},e.setInterval=function(){return new i(r.call(setInterval,window,arguments),clearInterval)},e.clearTimeout=e.clearInterval=function(t){t&&t.close()},i.prototype.unref=i.prototype.ref=function(){},i.prototype.close=function(){this._clearFn.call(window,this._id)},e.enroll=function(t,e){clearTimeout(t._idleTimeoutId),t._idleTimeout=e},e.unenroll=function(t){clearTimeout(t._idleTimeoutId),t._idleTimeout=-1},e._unrefActive=e.active=function(t){clearTimeout(t._idleTimeoutId);var e=t._idleTimeout;e>=0&&(t._idleTimeoutId=setTimeout(function(){t._onTimeout&&t._onTimeout()},e))},n(43),e.setImmediate=setImmediate,e.clearImmediate=clearImmediate},function(t,e){t.exports={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("div",{class:[t.css.wrapperClass]},[n("a",{class:[t.css.linkClass,(i={},i[t.css.disabledClass]=t.isOnFirstPage,i)],on:{click:function(e){t.loadPage("prev")}}},[n("i",{class:t.css.icons.prev})]),t._v(" "),n("select",{class:["vuetable-pagination-dropdown",t.css.dropdownClass],on:{change:function(e){t.loadPage(e.target.selectedIndex+1)}}},t._l(t.totalPage,function(e){return n("option",{class:[t.css.pageClass],domProps:{value:e,selected:t.isCurrentPage(e)}},[t._v("\n      "+t._s(t.pageText)+" "+t._s(e)+"\n    ")])})),t._v(" "),n("a",{class:[t.css.linkClass,(r={},r[t.css.disabledClass]=t.isOnLastPage,r)],on:{click:function(e){t.loadPage("next")}}},[n("i",{class:t.css.icons.next})])]);var i,r},staticRenderFns:[]}},function(t,e){t.exports={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("table",{class:["vuetable",t.css.tableClass]},[n("thead",[n("tr",[t._l(t.tableFields,function(e){return[e.visible?[t.isSpecialField(e.name)?["__checkbox"==t.extractName(e.name)?n("th",{class:["vuetable-th-checkbox-"+t.trackBy,e.titleClass]},[n("input",{attrs:{type:"checkbox"},domProps:{checked:t.checkCheckboxesState(e.name)},on:{change:function(n){t.toggleAllCheckboxes(e.name,n)}}})]):t._e(),t._v(" "),"__component"==t.extractName(e.name)?n("th",{class:["vuetable-th-component-"+t.trackBy,e.titleClass,{sortable:t.isSortable(e)}],domProps:{innerHTML:t._s(t.renderTitle(e))},on:{click:function(n){t.orderBy(e,n)}}}):t._e(),t._v(" "),"__slot"==t.extractName(e.name)?n("th",{class:["vuetable-th-slot-"+t.extractArgs(e.name),e.titleClass,{sortable:t.isSortable(e)}],domProps:{innerHTML:t._s(t.renderTitle(e))},on:{click:function(n){t.orderBy(e,n)}}}):t._e(),t._v(" "),"__sequence"==t.extractName(e.name)?n("th",{class:["vuetable-th-sequence",e.titleClass||""],domProps:{innerHTML:t._s(t.renderTitle(e))}}):t._e(),t._v(" "),t.notIn(t.extractName(e.name),["__sequence","__checkbox","__component","__slot"])?n("th",{class:["vuetable-th-"+e.name,e.titleClass||""],domProps:{innerHTML:t._s(t.renderTitle(e))}}):t._e()]:[n("th",{class:["vuetable-th-"+e.name,e.titleClass,{sortable:t.isSortable(e)}],attrs:{id:"_"+e.name},domProps:{innerHTML:t._s(t.renderTitle(e))},on:{click:function(n){t.orderBy(e,n)}}})]]:t._e()]})],2)]),t._v(" "),n("tbody",{staticClass:"vuetable-body"},[t._l(t.tableData,function(e,i){return[n("tr",{class:t.onRowClass(e,i),attrs:{"item-index":i,render:t.onRowChanged(e)},on:{dblclick:function(n){t.onRowDoubleClicked(e,n)},click:function(n){t.onRowClicked(e,n)}}},[t._l(t.tableFields,function(r){return[r.visible?[t.isSpecialField(r.name)?["__sequence"==t.extractName(r.name)?n("td",{class:["vuetable-sequence",r.dataClass],domProps:{innerHTML:t._s(t.renderSequence(i))}}):t._e(),t._v(" "),"__handle"==t.extractName(r.name)?n("td",{class:["vuetable-handle",r.dataClass],domProps:{innerHTML:t._s(t.renderIconTag(["handle-icon",t.css.handleIcon]))}}):t._e(),t._v(" "),"__checkbox"==t.extractName(r.name)?n("td",{class:["vuetable-checkboxes",r.dataClass]},[n("input",{attrs:{type:"checkbox"},domProps:{checked:t.rowSelected(e,r.name)},on:{change:function(n){t.toggleCheckbox(e,r.name,n)}}})]):t._e(),t._v(" "),"__component"===t.extractName(r.name)?n("td",{class:["vuetable-component",r.dataClass]},[n(t.extractArgs(r.name),{tag:"component",attrs:{"row-data":e,"row-index":i,"row-field":r.sortField}})],1):t._e(),t._v(" "),"__slot"===t.extractName(r.name)?n("td",{class:["vuetable-slot",r.dataClass]},[t._t(t.extractArgs(r.name),null,{rowData:e,rowIndex:i,rowField:r.sortField})],2):t._e()]:[t.hasCallback(r)?n("td",{class:r.dataClass,domProps:{innerHTML:t._s(t.callCallback(r,e))},on:{click:function(n){t.onCellClicked(e,r,n)},dblclick:function(n){t.onCellDoubleClicked(e,r,n)}}}):n("td",{class:r.dataClass,domProps:{innerHTML:t._s(t.getObjectValue(e,r.name,""))},on:{click:function(n){t.onCellClicked(e,r,n)},dblclick:function(n){t.onCellDoubleClicked(e,r,n)}}})]]:t._e()]})],2),t._v(" "),t.useDetailRow?[t.isVisibleDetailRow(e[t.trackBy])?n("tr",{class:[t.css.detailRowClass],on:{click:function(n){t.onDetailRowClick(e,n)}}},[n("transition",{attrs:{name:t.detailRowTransition}},[n("td",{attrs:{colspan:t.countVisibleFields}},[n(t.detailRowComponent,{tag:"component",attrs:{"row-data":e,"row-index":i}})],1)])],1):t._e()]:t._e()]}),t._v(" "),t.displayEmptyDataRow?[n("tr",[n("td",{staticClass:"vuetable-empty-result",attrs:{colspan:t.countVisibleFields}},[t._v(t._s(t.noDataTemplate))])])]:t._e(),t._v(" "),t.lessThanMinRows?t._l(t.blankRows,function(e){return n("tr",{staticClass:"blank-row"},[t._l(t.tableFields,function(e){return[e.visible?n("td",[t._v(" ")]):t._e()]})],2)}):t._e()],2)])},staticRenderFns:[]}},function(t,e){t.exports={render:function(){var t=this,e=t.$createElement,n=t._self._c||e;return t.tablePagination&&t.tablePagination.last_page>1?n("div",{class:t.css.wrapperClass},[n("a",{class:["btn-nav",t.css.linkClass,t.isOnFirstPage?t.css.disabledClass:""],on:{click:function(e){t.loadPage(1)}}},[""!=t.css.icons.first?n("i",{class:[t.css.icons.first]}):n("span",[t._v("«")])]),t._v(" "),n("a",{class:["btn-nav",t.css.linkClass,t.isOnFirstPage?t.css.disabledClass:""],on:{click:function(e){t.loadPage("prev")}}},[""!=t.css.icons.next?n("i",{class:[t.css.icons.prev]}):n("span",[t._v(" ‹")])]),t._v(" "),t.notEnoughPages?[t._l(t.totalPage,function(e){return[n("a",{class:[t.css.pageClass,t.isCurrentPage(e)?t.css.activeClass:""],domProps:{innerHTML:t._s(e)},on:{click:function(n){t.loadPage(e)}}})]})]:[t._l(t.windowSize,function(e){return[n("a",{class:[t.css.pageClass,t.isCurrentPage(t.windowStart+e-1)?t.css.activeClass:""],domProps:{innerHTML:t._s(t.windowStart+e-1)},on:{click:function(n){t.loadPage(t.windowStart+e-1)}}})]})],t._v(" "),n("a",{class:["btn-nav",t.css.linkClass,t.isOnLastPage?t.css.disabledClass:""],on:{click:function(e){t.loadPage("next")}}},[""!=t.css.icons.next?n("i",{class:[t.css.icons.next]}):n("span",[t._v("› ")])]),t._v(" "),n("a",{class:["btn-nav",t.css.linkClass,t.isOnLastPage?t.css.disabledClass:""],on:{click:function(e){t.loadPage(t.totalPage)}}},[""!=t.css.icons.last?n("i",{class:[t.css.icons.last]}):n("span",[t._v("»")])])],2):t._e()},staticRenderFns:[]}},function(t,e){t.exports={render:function(){var t=this,e=t.$createElement;return(t._self._c||e)("div",{class:["vuetable-pagination-info",t.css.infoClass],domProps:{innerHTML:t._s(t.paginationInfo)}})},staticRenderFns:[]}},function(t,e,n){var i=n(41);"string"==typeof i&&(i=[[t.i,i,""]]),i.locals&&(t.exports=i.locals);n(50)("764e777c",i,!0)},function(t,e,n){function i(t){for(var e=0;e<t.length;e++){var n=t[e],i=u[n.id];if(i){i.refs++;for(var r=0;r<i.parts.length;r++)i.parts[r](n.parts[r]);for(;r<n.parts.length;r++)i.parts.push(a(n.parts[r]));i.parts.length>n.parts.length&&(i.parts.length=n.parts.length)}else{for(var o=[],r=0;r<n.parts.length;r++)o.push(a(n.parts[r]));u[n.id]={id:n.id,refs:1,parts:o}}}}function r(){var t=document.createElement("style");return t.type="text/css",f.appendChild(t),t}function a(t){var e,n,i=document.querySelector('style[data-vue-ssr-id~="'+t.id+'"]');if(i){if(p)return g;i.parentNode.removeChild(i)}if(m){var a=h++;i=d||(d=r()),e=o.bind(null,i,a,!1),n=o.bind(null,i,a,!0)}else i=r(),e=s.bind(null,i),n=function(){i.parentNode.removeChild(i)};return e(t),function(i){if(i){if(i.css===t.css&&i.media===t.media&&i.sourceMap===t.sourceMap)return;e(t=i)}else n()}}function o(t,e,n,i){var r=n?"":i.css;if(t.styleSheet)t.styleSheet.cssText=v(e,r);else{var a=document.createTextNode(r),o=t.childNodes;o[e]&&t.removeChild(o[e]),o.length?t.insertBefore(a,o[e]):t.appendChild(a)}}function s(t,e){var n=e.css,i=e.media,r=e.sourceMap;if(i&&t.setAttribute("media",i),r&&(n+="\n/*# sourceURL="+r.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(r))))+" */"),t.styleSheet)t.styleSheet.cssText=n;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(n))}}var l="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!l)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var c=n(51),u={},f=l&&(document.head||document.getElementsByTagName("head")[0]),d=null,h=0,p=!1,g=function(){},m="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());t.exports=function(t,e,n){p=n;var r=c(t,e);return i(r),function(e){for(var n=[],a=0;a<r.length;a++){var o=r[a],s=u[o.id];s.refs--,n.push(s)}e?(r=c(t,e),i(r)):r=[];for(var a=0;a<n.length;a++){var s=n[a];if(0===s.refs){for(var l=0;l<s.parts.length;l++)s.parts[l]();delete u[s.id]}}}};var v=function(){var t=[];return function(e,n){return t[e]=n,t.filter(Boolean).join("\n")}}()},function(t,e){t.exports=function(t,e){for(var n=[],i={},r=0;r<e.length;r++){var a=e[r],o=a[0],s=a[1],l=a[2],c=a[3],u={id:t+":"+r,css:s,media:l,sourceMap:c};i[o]?i[o].parts.push(u):n.push(i[o]={id:o,parts:[u]})}return n}},function(t,e){var n;n=function(){return this}();try{n=n||Function("return this")()||(0,eval)("this")}catch(t){"object"==typeof window&&(n=window)}t.exports=n}])});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(29).setImmediate, __webpack_require__(29).clearImmediate))

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), __webpack_require__(4)))

/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_selector_type_script_index_0_home_vue__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_a78cd166_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_home_vue__ = __webpack_require__(92);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(66)
}
var normalizeComponent = __webpack_require__(8)
/* script */

/* template */

/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_selector_type_script_index_0_home_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_a78cd166_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_home_vue__["a" /* default */],
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "maintenance/components/home.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] home.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-a78cd166", Component.options)
  } else {
    hotAPI.reload("data-v-a78cd166", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(67);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(7)("423b5f68", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-a78cd166\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./home.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-a78cd166\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./home.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(undefined);
// imports


// module
exports.push([module.i, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", ""]);

// exports


/***/ }),
/* 68 */
/***/ (function(module, exports) {

/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles (parentId, list) {
  var styles = []
  var newStyles = {}
  for (var i = 0; i < list.length; i++) {
    var item = list[i]
    var id = item[0]
    var css = item[1]
    var media = item[2]
    var sourceMap = item[3]
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    }
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] })
    } else {
      newStyles[id].parts.push(part)
    }
  }
  return styles
}


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuetable_2_src_components_Vuetable_vue__ = __webpack_require__(30);
//
//
//
//
//



/* harmony default export */ __webpack_exports__["a"] = ({
    data() {
        return {
            message: 'Bienvenido al mantenimiento del restaurante',
        }
    },
    computed: {
        /*httpOptions(){
            return {headers: {'Authorization': "my-token"}} //table props -> :http-options="httpOptions"
        },*/
    },
    components: {
    },
    methods: {
     
    }
});


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(71);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(7)("b0d8024e", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../css-loader/index.js!../../../vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-b0ab162c\",\"scoped\":true,\"hasInlineConfig\":false}!../../../vue-loader/lib/selector.js?type=styles&index=0!./Vuetable.vue", function() {
     var newContent = require("!!../../../css-loader/index.js!../../../vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-b0ab162c\",\"scoped\":true,\"hasInlineConfig\":false}!../../../vue-loader/lib/selector.js?type=styles&index=0!./Vuetable.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(undefined);
// imports


// module
exports.push([module.i, "\n[v-cloak][data-v-b0ab162c] {\n  display: none;\n}\n.vuetable th.sortable[data-v-b0ab162c]:hover {\n  color: #2185d0;\n  cursor: pointer;\n}\n.vuetable-actions[data-v-b0ab162c] {\n  width: 15%;\n  padding: 12px 0px;\n  text-align: center;\n}\n.vuetable-pagination[data-v-b0ab162c] {\n  background: #f9fafb !important;\n}\n.vuetable-pagination-info[data-v-b0ab162c] {\n  margin-top: auto;\n  margin-bottom: auto;\n}\n.vuetable-empty-result[data-v-b0ab162c] {\n  text-align: center;\n}\n", ""]);

// exports


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_axios__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_axios___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_axios__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ __webpack_exports__["a"] = ({
  props: {
    fields: {
      type: Array,
      required: true
    },
    loadOnStart: {
      type: Boolean,
      default: true
    },
    apiUrl: {
        type: String,
        default: ''
    },
    httpMethod: {
        type: String,
        default: 'get',
        validator: (value) => {
          return ['get', 'post'].indexOf(value) > -1
        }
    },
    reactiveApiUrl: {
        type: Boolean,
        default: true
    },
    apiMode: {
      type: Boolean,
      default: true
    },
    data: {
      type: [Array, Object],
      default () {
        return null
      }
    },
    dataTotal: {
      type: Number,
      default: 0
    },
    dataManager: {
      type: Function,
      default () {
        return null
      }
    },
    dataPath: {
        type: String,
        default: 'data'
    },
    paginationPath: {
        type: [String],
        default: 'links.pagination'
    },
    queryParams: {
      type: Object,
      default () {
        return {
          sort: 'sort',
          page: 'page',
          perPage: 'per_page'
        }
      }
    },
    appendParams: {
      type: Object,
      default () {
        return {}
      }
    },
    httpOptions: {
      type: Object,
      default () {
        return {}
      }
    },
    perPage: {
        type: Number,
        default () {
            return 10
        }
    },
    sortOrder: {
      type: Array,
      default () {
        return []
      }
    },
    multiSort: {
      type: Boolean,
      default () {
        return false
      }
    },
    /*
     * physical key that will trigger multi-sort option
     * possible values: 'alt', 'ctrl', 'meta', 'shift'
     * 'ctrl' might not work as expected on Mac
     */
    multiSortKey: {
      type: String,
      default: 'alt'
    },
    /* deprecated */
    rowClassCallback: {
      type: [String, Function],
      default: ''
    },
    rowClass: {
      type: [String, Function],
      default: ''
    },
    detailRowComponent: {
      type: String,
      default: ''
    },
    detailRowTransition: {
      type: String,
      default: ''
    },
    trackBy: {
      type: String,
      default: 'id'
    },
    css: {
      type: Object,
      default () {
        return {
          tableClass: 'ui blue selectable celled stackable attached table',
          loadingClass: 'loading',
          ascendingIcon: 'blue chevron up icon',
          descendingIcon: 'blue chevron down icon',
          detailRowClass: 'vuetable-detail-row',
          handleIcon: 'grey sidebar icon',
        }
      }
    },
    minRows: {
      type: Number,
      default: 0
    },
    silent: {
      type: Boolean,
      default: false
    },
    noDataTemplate: {
      type: String,
      default() {
        return 'No Data Available'
      }
    },
  },
  data () {
    return {
      eventPrefix: 'vuetable:',
      tableFields: [],
      tableData: null,
      tablePagination: null,
      currentPage: 1,
      selectedTo: [],
      visibleDetailRows: [],
    }
  },
  mounted () {
    this.normalizeFields()
    this.$nextTick(function() {
      this.fireEvent('initialized', this.tableFields)
    })

    if (this.loadOnStart) {
      this.loadData()
    }
  },
  computed: {
    useDetailRow () {
      if (this.tableData && this.tableData[0] && this.detailRowComponent !== '' && typeof this.tableData[0][this.trackBy] === 'undefined') {
        this.warn('You need to define unique row identifier in order for detail-row feature to work. Use `track-by` prop to define one!')
        return false
      }

      return this.detailRowComponent !== ''
    },
    countVisibleFields () {
      return this.tableFields.filter(function(field) {
        return field.visible
      }).length
    },
    countTableData () {
      if (this.tableData === null) {
        return 0
      }
      return this.tableData.length
    },
    displayEmptyDataRow () {
      return this.countTableData === 0 && this.noDataTemplate.length > 0
    },
    lessThanMinRows () {
      if (this.tableData === null || this.tableData.length === 0) {
        return true
      }
      return this.tableData.length < this.minRows
    },
    blankRows () {
      if (this.tableData === null || this.tableData.length === 0) {
        return this.minRows
      }
      if (this.tableData.length >= this.minRows) {
        return 0
      }

      return this.minRows - this.tableData.length
    },
    isApiMode () {
      return this.apiMode 
    },
    isDataMode () {
      return ! this.apiMode
    }
  },
  methods: {
    normalizeFields () {
      if (typeof(this.fields) === 'undefined') {
        this.warn('You need to provide "fields" prop.')
        return
      }

      this.tableFields = []
      let self = this
      let obj
      this.fields.forEach(function(field, i) {
        if (typeof (field) === 'string') {
          obj = {
            name: field,
            title: self.setTitle(field),
            titleClass: '',
            dataClass: '',
            callback: null,
            visible: true,
          }
        } else {
          obj = {
            name: field.name,
            title: (field.title === undefined) ? self.setTitle(field.name) : field.title,
            sortField: field.sortField,
            titleClass: (field.titleClass === undefined) ? '' : field.titleClass,
            dataClass: (field.dataClass === undefined) ? '' : field.dataClass,
            callback: (field.callback === undefined) ? '' : field.callback,
            visible: (field.visible === undefined) ? true : field.visible,
          }
        }
        self.tableFields.push(obj)
      })
    },
    setData (data) {
      this.apiMode = false
      if (Array.isArray(data)) {
        this.tableData = data
        return
      }

      this.fireEvent('loading')

      this.tableData = this.getObjectValue(data, this.dataPath, null)
      this.tablePagination = this.getObjectValue(data, this.paginationPath, null)

      this.$nextTick(function() {
        this.fireEvent('pagination-data', this.tablePagination)
        this.fireEvent('loaded')
      })
    },
    setTitle (str) {
      if (this.isSpecialField(str)) {
        return ''
      }

      return this.titleCase(str)
    },
    renderTitle (field) {
      let title = (typeof field.title === 'undefined') ? field.name.replace('.', ' ') : field.title

      if (title.length > 0 && this.isInCurrentSortGroup(field)) {
        let style = `opacity:${this.sortIconOpacity(field)};position:relative;float:right`
        return title + ' ' + this.renderIconTag(['sort-icon', this.sortIcon(field)], `style="${style}"`)
      }

      return title
    },
    renderSequence (index) {
      return this.tablePagination 
        ? this.tablePagination.from + index 
        : index
    },
    isSpecialField (fieldName) {
      return fieldName.slice(0, 2) === '__'
    },
    titleCase (str) {
      return str.replace(/\w+/g, function(txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
      })
    },
    camelCase (str, delimiter = '_') {
      let self = this
      return str.split(delimiter).map(function(item) {
        return self.titleCase(item)
      }).join('')
    },
    notIn (str, arr) {
      return arr.indexOf(str) === -1
    },
    loadData (success = this.loadSuccess, failed = this.loadFailed) {
      if (this.isDataMode) {
        this.callDataManager()
        return
      }

      this.fireEvent('loading')

      this.httpOptions['params'] = this.getAllQueryParams()

      __WEBPACK_IMPORTED_MODULE_0_axios___default.a[this.httpMethod](this.apiUrl, this.httpOptions).then(
          success,
          failed
      ).catch(() => failed())
    },
    loadSuccess (response) {
      this.fireEvent('load-success', response)

      let body = this.transform(response.data)

      this.tableData = this.getObjectValue(body, this.dataPath, null)
      this.tablePagination = this.getObjectValue(body, this.paginationPath, null)

      if (this.tablePagination === null) {
        this.warn('vuetable: pagination-path "' + this.paginationPath + '" not found. '
          + 'It looks like the data returned from the sever does not have pagination information '
          + "or you may have set it incorrectly.\n"
          + 'You can explicitly suppress this warning by setting pagination-path="".'
        )
      }

      this.$nextTick(function() {
        this.fireEvent('pagination-data', this.tablePagination)
        this.fireEvent('loaded')
      })
    },
    loadFailed (response) {
      console.error('load-error', response)
      this.fireEvent('load-error', response)
      this.fireEvent('loaded')
    },
    transform (data) {
      let func = 'transform'

      if (this.parentFunctionExists(func)) {
          return this.$parent[func].call(this.$parent, data)
      }

      return data
    },
    parentFunctionExists (func) {
      return (func !== '' && typeof this.$parent[func] === 'function')
    },
    callParentFunction (func, args, defaultValue = null) {
      if (this.parentFunctionExists(func)) {
        return this.$parent[func].call(this.$parent, args)
      }

      return defaultValue
    },
    fireEvent (eventName, args) {
      this.$emit(this.eventPrefix + eventName, args)
    },
    warn (msg) {
      if (!this.silent) {
        console.warn(msg)
      }
    },
    getAllQueryParams () {
      let params = {}
      params[this.queryParams.sort] = this.getSortParam()
      params[this.queryParams.page] = this.currentPage
      params[this.queryParams.perPage] = this.perPage

      for (let x in this.appendParams) {
        params[x] = this.appendParams[x]
      }

      return params
    },
    getSortParam () {
      if (!this.sortOrder || this.sortOrder.field == '') {
        return ''
      }

      if (typeof this.$parent['getSortParam'] == 'function') {
        return this.$parent['getSortParam'].call(this.$parent, this.sortOrder)
      }

      return this.getDefaultSortParam()
    },
    getDefaultSortParam () {
      let result = '';

      for (let i = 0; i < this.sortOrder.length; i++) {
        let fieldName = (typeof this.sortOrder[i].sortField === 'undefined')
          ? this.sortOrder[i].field
          : this.sortOrder[i].sortField;

        result += fieldName + '|' + this.sortOrder[i].direction + ((i+1) < this.sortOrder.length ? ',' : '');
      }

      return result;
    },
    extractName (string) {
      return string.split(':')[0].trim()
    },
    extractArgs (string) {
      return string.split(':')[1]
    },
    isSortable (field) {
      return !(typeof field.sortField === 'undefined')
    },
    isInCurrentSortGroup (field) {
      return this.currentSortOrderPosition(field) !== false;
    },
    currentSortOrderPosition (field) {
      if ( ! this.isSortable(field)) {
        return false
      }

      for (let i = 0; i < this.sortOrder.length; i++) {
        if (this.fieldIsInSortOrderPosition(field, i)) {
          return i;
        }
      }

      return false;
    },
    fieldIsInSortOrderPosition (field, i) {
      return this.sortOrder[i].field === field.name && this.sortOrder[i].sortField === field.sortField
    },
    orderBy (field, event) {
      if ( ! this.isSortable(field) ) return

      let key = this.multiSortKey.toLowerCase() + 'Key'

      if (this.multiSort && event[key]) { //adding column to multisort
        this.multiColumnSort(field)
      } else {
        //no multisort, or resetting sort
        this.singleColumnSort(field)
      }

      this.currentPage = 1    // reset page index
      this.loadData()
    },
    multiColumnSort (field) {
      let i = this.currentSortOrderPosition(field);

      if(i === false) { //this field is not in the sort array yet
        this.sortOrder.push({
          field: field.name,
          sortField: field.sortField,
          direction: 'asc'
        });
      } else { //this field is in the sort array, now we change its state
        if(this.sortOrder[i].direction === 'asc') {
          // switch direction
          this.sortOrder[i].direction = 'desc'
        } else {
          //remove sort condition
          this.sortOrder.splice(i, 1);
        }
      }
    },
    singleColumnSort (field) {
      if (this.sortOrder.length === 0) {
        this.clearSortOrder()
      }

      this.sortOrder.splice(1); //removes additional columns

      if (this.fieldIsInSortOrderPosition(field, 0)) {
        // change sort direction
        this.sortOrder[0].direction = this.sortOrder[0].direction === 'asc' ? 'desc' : 'asc'
      } else {
        // reset sort direction
        this.sortOrder[0].direction = 'asc'
      }
      this.sortOrder[0].field = field.name
      this.sortOrder[0].sortField = field.sortField
    },
    clearSortOrder () {
      this.sortOrder.push({
        field: '',
        sortField: '',
        direction: 'asc'
      });
    },
    sortIcon (field) {
      let cls = ''
      let i = this.currentSortOrderPosition(field)

      if (i !== false) {
        cls = (this.sortOrder[i].direction == 'asc') ? this.css.ascendingIcon : this.css.descendingIcon
      }

      return cls;
    },
    sortIconOpacity (field) {
      /*
       * fields with stronger precedence have darker color
       *
       * if there are few fields, we go down by 0.3
       * ex. 2 fields are selected: 1.0, 0.7
       *
       * if there are more we go down evenly on the given spectrum
       * ex. 6 fields are selected: 1.0, 0.86, 0.72, 0.58, 0.44, 0.3
       */
      let max = 1.0,
          min = 0.3,
          step = 0.3

      let count = this.sortOrder.length;
      let current = this.currentSortOrderPosition(field)


      if(max - count * step < min) {
        step = (max - min) / (count-1)
      }

      let opacity = max - current * step

      return opacity
    },
    hasCallback (item) {
      return item.callback ? true : false
    },
    callCallback (field, item) {
      if ( ! this.hasCallback(field)) return

      if(typeof(field.callback) == 'function') {
       return field.callback(this.getObjectValue(item, field.name))
      }

      let args = field.callback.split('|')
      let func = args.shift()

      if (typeof this.$parent[func] === 'function') {
        let value = this.getObjectValue(item, field.name)

        return (args.length > 0)
          ? this.$parent[func].apply(this.$parent, [value].concat(args))
          : this.$parent[func].call(this.$parent, value)
      }

      return null
    },
    getObjectValue (object, path, defaultValue) {
      defaultValue = (typeof defaultValue === 'undefined') ? null : defaultValue

      let obj = object
      if (path.trim() != '') {
        let keys = path.split('.')
        keys.forEach(function(key) {
          if (obj !== null && typeof obj[key] !== 'undefined' && obj[key] !== null) {
            obj = obj[key]
          } else {
            obj = defaultValue
            return
          }
        })
      }
      return obj
    },
    toggleCheckbox (dataItem, fieldName, event) {
      let isChecked = event.target.checked
      let idColumn = this.trackBy

      if (dataItem[idColumn] === undefined) {
        this.warn('__checkbox field: The "'+this.trackBy+'" field does not exist! Make sure the field you specify in "track-by" prop does exist.')
        return
      }

      let key = dataItem[idColumn]
      if (isChecked) {
        this.selectId(key)
      } else {
        this.unselectId(key)
      }
      this.$emit('vuetable:checkbox-toggled', isChecked, dataItem)
    },
    selectId (key) {
      if ( ! this.isSelectedRow(key)) {
        this.selectedTo.push(key)
      }
    },
    unselectId (key) {
      this.selectedTo = this.selectedTo.filter(function(item) {
        return item !== key
      })
    },
    isSelectedRow (key) {
      return this.selectedTo.indexOf(key) >= 0
    },
    rowSelected (dataItem, fieldName){
      let idColumn = this.trackBy
      let key = dataItem[idColumn]

      return this.isSelectedRow(key)
    },
    checkCheckboxesState (fieldName) {
      if (! this.tableData) return

      let self = this
      let idColumn = this.trackBy
      let selector = 'th.vuetable-th-checkbox-' + idColumn + ' input[type=checkbox]'
      let els = document.querySelectorAll(selector)

      //fixed:document.querySelectorAll return the typeof nodeList not array
      if (els.forEach===undefined)
        els.forEach=function(cb){
          [].forEach.call(els, cb);
        }

      // count how many checkbox row in the current page has been checked
      let selected = this.tableData.filter(function(item) {
        return self.selectedTo.indexOf(item[idColumn]) >= 0
      })

      // count == 0, clear the checkbox
      if (selected.length <= 0) {
        els.forEach(function(el) {
          el.indeterminate = false
        })
        return false
      }
      // count > 0 and count < perPage, set checkbox state to 'indeterminate'
      else if (selected.length < this.perPage) {
        els.forEach(function(el) {
          el.indeterminate = true
        })
        return true
      }
      // count == perPage, set checkbox state to 'checked'
      else {
        els.forEach(function(el) {
          el.indeterminate = false
        })
        return true
      }
    },
    toggleAllCheckboxes (fieldName, event) {
      let self = this
      let isChecked = event.target.checked
      let idColumn = this.trackBy

      if (isChecked) {
        this.tableData.forEach(function(dataItem) {
          self.selectId(dataItem[idColumn])
        })
      } else {
        this.tableData.forEach(function(dataItem) {
          self.unselectId(dataItem[idColumn])
        })
      }
      this.$emit('vuetable:checkbox-toggled-all', isChecked)
    },
    gotoPreviousPage () {
      if (this.currentPage > 1) {
        this.currentPage--
        this.loadData()
      }
    },
    gotoNextPage () {
      if (this.currentPage < this.tablePagination.last_page) {
        this.currentPage++
        this.loadData()
      }
    },
    gotoPage (page) {
      if (page != this.currentPage && (page > 0 && page <= this.tablePagination.last_page)) {
        this.currentPage = page
        this.loadData()
      }
    },
    isVisibleDetailRow (rowId) {
      return this.visibleDetailRows.indexOf( rowId ) >= 0
    },
    showDetailRow (rowId) {
      if (!this.isVisibleDetailRow(rowId)) {
        this.visibleDetailRows.push(rowId)
      }
    },
    hideDetailRow (rowId) {
      if (this.isVisibleDetailRow(rowId)) {
        this.visibleDetailRows.splice(
          this.visibleDetailRows.indexOf(rowId),
          1
        )
      }
    },
    toggleDetailRow (rowId) {
      if (this.isVisibleDetailRow(rowId)) {
        this.hideDetailRow(rowId)
      } else {
        this.showDetailRow(rowId)
      }
    },
    showField (index) {
      if (index < 0 || index > this.tableFields.length) return

      this.tableFields[index].visible = true
    },
    hideField (index) {
      if (index < 0 || index > this.tableFields.length) return

      this.tableFields[index].visible = false
    },
    toggleField (index) {
      if (index < 0 || index > this.tableFields.length) return

      this.tableFields[index].visible = ! this.tableFields[index].visible
    },
    renderIconTag (classes, options = '') {
      return typeof(this.css.renderIcon) === 'undefined'
        ? `<i class="${classes.join(' ')}" ${options}></i>`
        : this.css.renderIcon(classes, options)
    },
    makePagination (total = null, perPage = null, currentPage = null) {
      let pagination = {}
      total = total === null ? this.dataTotal : total
      perPage = perPage === null ? this.perPage : perPage
      currentPage = currentPage === null ? this.currentPage : currentPage

      return {
        'total': total,
        'per_page': perPage,
        'current_page': currentPage,
        'last_page': Math.ceil(total / perPage) || 0,
        'next_page_url': '',
        'prev_page_url': '',
        'from': (currentPage -1) * perPage +1,
        'to': Math.min(currentPage * perPage, total)
      }
    },
    normalizeSortOrder () {
      this.sortOrder.forEach(function(item) {
        item.sortField = item.sortField || item.field
      })
    },
    callDataManager () {
      if (this.dataManager === null && this.data === null) return

      if (Array.isArray(this.data)) {
        console.log('data mode: array')
        this.setData(this.data)
      } else {
        this.normalizeSortOrder()
        this.setData(this.dataManager(this.sortOrder, this.makePagination()))
      }
    },
    onRowClass (dataItem, index) {
      if (this.rowClassCallback !== '') {
        this.warn('"row-class-callback" prop is deprecated, please use "row-class" prop instead.')
        return
      }

      if (typeof(this.rowClass) === 'function') {
        return this.rowClass(dataItem, index)
      }

      return this.rowClass
    },
    onRowChanged (dataItem) {
      this.fireEvent('row-changed', dataItem)
      return true
    },
    onRowClicked (dataItem, event) {
      this.$emit(this.eventPrefix + 'row-clicked', dataItem, event)
      return true
    },
    onRowDoubleClicked (dataItem, event) {
      this.$emit(this.eventPrefix + 'row-dblclicked', dataItem, event)
    },
    onDetailRowClick (dataItem, event) {
      this.$emit(this.eventPrefix + 'detail-row-clicked', dataItem, event)
    },
    onCellClicked (dataItem, field, event) {
      this.$emit(this.eventPrefix + 'cell-clicked', dataItem, field, event)
    },
    onCellDoubleClicked (dataItem, field, event) {
      this.$emit(this.eventPrefix + 'cell-dblclicked', dataItem, field, event)
    },
    /*
     * API for externals
     */
    changePage (page) {
      if (page === 'prev') {
        this.gotoPreviousPage()
      } else if (page === 'next') {
        this.gotoNextPage()
      } else {
        this.gotoPage(page)
      }
    },
    reload () {
      this.loadData()
    },
    refresh () {
      this.currentPage = 1
      this.loadData()
    },
    resetData () {
      this.tableData = null
      this.tablePagination = null
      this.fireEvent('data-reset')
    }
  }, // end: methods
  watch: {
    'multiSort' (newVal, oldVal) {
      if (newVal === false && this.sortOrder.length > 1) {
        this.sortOrder.splice(1);
        this.loadData();
      }
    },
    'apiUrl'  (newVal, oldVal) {
      if(this.reactiveApiUrl && newVal !== oldVal)
        this.refresh()
    }
  },
});


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(74);

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(1);
var bind = __webpack_require__(33);
var Axios = __webpack_require__(75);
var defaults = __webpack_require__(31);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(37);
axios.CancelToken = __webpack_require__(89);
axios.isCancel = __webpack_require__(36);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(90);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(31);
var utils = __webpack_require__(1);
var InterceptorManager = __webpack_require__(84);
var dispatchRequest = __webpack_require__(85);
var isAbsoluteURL = __webpack_require__(87);
var combineURLs = __webpack_require__(88);

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(1);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(35);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response
    ));
  }
};


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 @ @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.response = response;
  return error;
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(1);

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      }

      if (!utils.isArray(val)) {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(1);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(1);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  (function standardBrowserEnv() {
    var msie = /(msie|trident)/i.test(navigator.userAgent);
    var urlParsingNode = document.createElement('a');
    var originURL;

    /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
    function resolveURL(url) {
      var href = url;

      if (msie) {
        // IE needs attribute set twice to normalize properties
        urlParsingNode.setAttribute('href', href);
        href = urlParsingNode.href;
      }

      urlParsingNode.setAttribute('href', href);

      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                  urlParsingNode.pathname :
                  '/' + urlParsingNode.pathname
      };
    }

    originURL = resolveURL(window.location.href);

    /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
    return function isURLSameOrigin(requestURL) {
      var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
      return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
    };
  })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  })()
);


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error;
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
    // initialize result and counter
    var block, charCode, idx = 0, map = chars;
    // if the next str index does not exist:
    //   change the mapping table to "="
    //   check if d has no fractional digits
    str.charAt(idx | 0) || (map = '=', idx % 1);
    // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
    output += map.charAt(63 & block >> 8 - idx % 1 * 8)
  ) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(1);

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
  (function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        var cookie = [];
        cookie.push(name + '=' + encodeURIComponent(value));

        if (utils.isNumber(expires)) {
          cookie.push('expires=' + new Date(expires).toGMTString());
        }

        if (utils.isString(path)) {
          cookie.push('path=' + path);
        }

        if (utils.isString(domain)) {
          cookie.push('domain=' + domain);
        }

        if (secure === true) {
          cookie.push('secure');
        }

        document.cookie = cookie.join('; ');
      },

      read: function read(name) {
        var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
        return (match ? decodeURIComponent(match[3]) : null);
      },

      remove: function remove(name) {
        this.write(name, '', Date.now() - 86400000);
      }
    };
  })() :

  // Non standard browser env (web workers, react-native) lack needed support.
  (function nonStandardBrowserEnv() {
    return {
      write: function write() {},
      read: function read() { return null; },
      remove: function remove() {}
    };
  })()
);


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(1);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(1);
var transformData = __webpack_require__(86);
var isCancel = __webpack_require__(36);
var defaults = __webpack_require__(31);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers || {}
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(1);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '');
};


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(37);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('table', {
    class: ['vuetable', _vm.css.tableClass]
  }, [_c('thead', [_c('tr', [_vm._l((_vm.tableFields), function(field) {
    return [(field.visible) ? [(_vm.isSpecialField(field.name)) ? [(_vm.extractName(field.name) == '__checkbox') ? _c('th', {
      class: ['vuetable-th-checkbox-' + _vm.trackBy, field.titleClass]
    }, [_c('input', {
      attrs: {
        "type": "checkbox"
      },
      domProps: {
        "checked": _vm.checkCheckboxesState(field.name)
      },
      on: {
        "change": function($event) {
          _vm.toggleAllCheckboxes(field.name, $event)
        }
      }
    })]) : _vm._e(), _vm._v(" "), (_vm.extractName(field.name) == '__component') ? _c('th', {
      class: ['vuetable-th-component-' + _vm.trackBy, field.titleClass, {
        'sortable': _vm.isSortable(field)
      }],
      domProps: {
        "innerHTML": _vm._s(_vm.renderTitle(field))
      },
      on: {
        "click": function($event) {
          _vm.orderBy(field, $event)
        }
      }
    }) : _vm._e(), _vm._v(" "), (_vm.extractName(field.name) == '__slot') ? _c('th', {
      class: ['vuetable-th-slot-' + _vm.extractArgs(field.name), field.titleClass, {
        'sortable': _vm.isSortable(field)
      }],
      domProps: {
        "innerHTML": _vm._s(_vm.renderTitle(field))
      },
      on: {
        "click": function($event) {
          _vm.orderBy(field, $event)
        }
      }
    }) : _vm._e(), _vm._v(" "), (_vm.extractName(field.name) == '__sequence') ? _c('th', {
      class: ['vuetable-th-sequence', field.titleClass || ''],
      domProps: {
        "innerHTML": _vm._s(_vm.renderTitle(field))
      }
    }) : _vm._e(), _vm._v(" "), (_vm.notIn(_vm.extractName(field.name), ['__sequence', '__checkbox', '__component', '__slot'])) ? _c('th', {
      class: ['vuetable-th-' + field.name, field.titleClass || ''],
      domProps: {
        "innerHTML": _vm._s(_vm.renderTitle(field))
      }
    }) : _vm._e()] : [_c('th', {
      class: ['vuetable-th-' + field.name, field.titleClass, {
        'sortable': _vm.isSortable(field)
      }],
      attrs: {
        "id": '_' + field.name
      },
      domProps: {
        "innerHTML": _vm._s(_vm.renderTitle(field))
      },
      on: {
        "click": function($event) {
          _vm.orderBy(field, $event)
        }
      }
    })]] : _vm._e()]
  })], 2)]), _vm._v(" "), _c('tbody', {
    staticClass: "vuetable-body"
  }, [_vm._l((_vm.tableData), function(item, index) {
    return [_c('tr', {
      class: _vm.onRowClass(item, index),
      attrs: {
        "item-index": index,
        "render": _vm.onRowChanged(item)
      },
      on: {
        "dblclick": function($event) {
          _vm.onRowDoubleClicked(item, $event)
        },
        "click": function($event) {
          _vm.onRowClicked(item, $event)
        }
      }
    }, [_vm._l((_vm.tableFields), function(field) {
      return [(field.visible) ? [(_vm.isSpecialField(field.name)) ? [(_vm.extractName(field.name) == '__sequence') ? _c('td', {
        class: ['vuetable-sequence', field.dataClass],
        domProps: {
          "innerHTML": _vm._s(_vm.renderSequence(index))
        }
      }) : _vm._e(), _vm._v(" "), (_vm.extractName(field.name) == '__handle') ? _c('td', {
        class: ['vuetable-handle', field.dataClass],
        domProps: {
          "innerHTML": _vm._s(_vm.renderIconTag(['handle-icon', _vm.css.handleIcon]))
        }
      }) : _vm._e(), _vm._v(" "), (_vm.extractName(field.name) == '__checkbox') ? _c('td', {
        class: ['vuetable-checkboxes', field.dataClass]
      }, [_c('input', {
        attrs: {
          "type": "checkbox"
        },
        domProps: {
          "checked": _vm.rowSelected(item, field.name)
        },
        on: {
          "change": function($event) {
            _vm.toggleCheckbox(item, field.name, $event)
          }
        }
      })]) : _vm._e(), _vm._v(" "), (_vm.extractName(field.name) === '__component') ? _c('td', {
        class: ['vuetable-component', field.dataClass]
      }, [_c(_vm.extractArgs(field.name), {
        tag: "component",
        attrs: {
          "row-data": item,
          "row-index": index,
          "row-field": field.sortField
        }
      })], 1) : _vm._e(), _vm._v(" "), (_vm.extractName(field.name) === '__slot') ? _c('td', {
        class: ['vuetable-slot', field.dataClass]
      }, [_vm._t(_vm.extractArgs(field.name), null, {
        rowData: item,
        rowIndex: index,
        rowField: field.sortField
      })], 2) : _vm._e()] : [(_vm.hasCallback(field)) ? _c('td', {
        class: field.dataClass,
        domProps: {
          "innerHTML": _vm._s(_vm.callCallback(field, item))
        },
        on: {
          "click": function($event) {
            _vm.onCellClicked(item, field, $event)
          },
          "dblclick": function($event) {
            _vm.onCellDoubleClicked(item, field, $event)
          }
        }
      }) : _c('td', {
        class: field.dataClass,
        domProps: {
          "innerHTML": _vm._s(_vm.getObjectValue(item, field.name, ''))
        },
        on: {
          "click": function($event) {
            _vm.onCellClicked(item, field, $event)
          },
          "dblclick": function($event) {
            _vm.onCellDoubleClicked(item, field, $event)
          }
        }
      })]] : _vm._e()]
    })], 2), _vm._v(" "), (_vm.useDetailRow) ? [(_vm.isVisibleDetailRow(item[_vm.trackBy])) ? _c('tr', {
      class: [_vm.css.detailRowClass],
      on: {
        "click": function($event) {
          _vm.onDetailRowClick(item, $event)
        }
      }
    }, [_c('transition', {
      attrs: {
        "name": _vm.detailRowTransition
      }
    }, [_c('td', {
      attrs: {
        "colspan": _vm.countVisibleFields
      }
    }, [_c(_vm.detailRowComponent, {
      tag: "component",
      attrs: {
        "row-data": item,
        "row-index": index
      }
    })], 1)])], 1) : _vm._e()] : _vm._e()]
  }), _vm._v(" "), (_vm.displayEmptyDataRow) ? [_c('tr', [_c('td', {
    staticClass: "vuetable-empty-result",
    attrs: {
      "colspan": _vm.countVisibleFields
    }
  }, [_vm._v(_vm._s(_vm.noDataTemplate))])])] : _vm._e(), _vm._v(" "), (_vm.lessThanMinRows) ? _vm._l((_vm.blankRows), function(i) {
    return _c('tr', {
      staticClass: "blank-row"
    }, [_vm._l((_vm.tableFields), function(field) {
      return [(field.visible) ? _c('td', [_vm._v(" ")]) : _vm._e()]
    })], 2)
  }) : _vm._e()], 2)])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-b0ab162c", esExports)
  }
}

/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_vm._v("\n    " + _vm._s(_vm.message) + "\n")])
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-a78cd166", esExports)
  }
}

/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_selector_type_script_index_0_categories_vue__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0b84acec_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_categories_vue__ = __webpack_require__(97);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(94)
}
var normalizeComponent = __webpack_require__(8)
/* script */

/* template */

/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_selector_type_script_index_0_categories_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_0b84acec_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_categories_vue__["a" /* default */],
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "maintenance/components/categories.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] categories.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-0b84acec", Component.options)
  } else {
    hotAPI.reload("data-v-0b84acec", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(95);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(7)("fbc48d22", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-0b84acec\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./categories.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-0b84acec\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./categories.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(undefined);
// imports


// module
exports.push([module.i, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", ""]);

// exports


/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuetable_2_src_components_Vuetable_vue__ = __webpack_require__(30);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ __webpack_exports__["a"] = ({
    props: ['categories'],
    data: function() {
        return {
            fields: ['id', 'name', '__slot:actions'],
            localData: this.categories.data,
            name: '',
            selectedRowData: {}
        }
    },
    computed: {
        /*httpOptions(){
            return {headers: {'Authorization': "my-token"}} //table props -> :http-options="httpOptions"
        },*/

    },
    components: {
        Vuetable: __WEBPACK_IMPORTED_MODULE_0_vuetable_2_src_components_Vuetable_vue__["a" /* default */]
    },
    methods: {
        editRow(rowData) {
            console.log(rowData.name);
            this.name = rowData.name;
            this.selectedRowData = rowData;
            this.$refs.modalUpdate.show();
        },
        deleteRow(rowData) {
            let index = this.localData.indexOf(rowData);
            this.localData.splice(index, 1);
        },
        clearName() {
            this.name = '';
        },
        update() {
            this.selectedRowData.name = this.name;
        },
        submit(e) {
            if (!this.name) {
                alert('Por favor ingrese el nombres');
                return e.cancel();
            }

            let id = Math.max(...this.localData.map(v => parseInt(v.id))) || 0;
            this.localData.push({ id: id + 1, name: this.name })
            this.name = '';
            this.$emit('create-category', this.locaData);
            this.$router.app.$emit('create-category')
        }
    }
});


/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_vm._v("\n    Categorias\n    "), _c('vuetable', {
    ref: "vuetable",
    attrs: {
      "api-mode": false,
      "data": _vm.localData,
      "fields": _vm.fields,
      "data-path": "data",
      "pagination-path": ""
    },
    scopedSlots: _vm._u([{
      key: "actions",
      fn: function(props) {
        return [_c('div', {
          staticClass: "table-button-container"
        }, [_c('b-button', {
          attrs: {
            "variant": "success",
            "size": "sm"
          },
          on: {
            "click": function($event) {
              _vm.editRow(props.rowData)
            }
          }
        }, [_c('i', {
          staticClass: "icon-pencil icons"
        })]), _vm._v(" "), _c('b-button', {
          attrs: {
            "variant": "danger",
            "size": "sm"
          },
          on: {
            "click": function($event) {
              _vm.deleteRow(props.rowData)
            }
          }
        }, [_c('i', {
          staticClass: "icon-ban icons"
        })])], 1)]
      }
    }])
  }), _vm._v(" "), _c('b-button', {
    directives: [{
      name: "b-modal",
      rawName: "v-b-modal.modalCreate",
      modifiers: {
        "modalCreate": true
      }
    }],
    attrs: {
      "variant": "success",
      "size": "sm"
    }
  }, [_c('i', {
    staticClass: "icon-plus icons"
  }), _vm._v(" Agregar")]), _vm._v(" "), _c('b-modal', {
    ref: "modalCreate",
    attrs: {
      "id": "modalCreate",
      "title": "Crear Categoria",
      "close-title": "Cerrar"
    },
    on: {
      "ok": _vm.submit,
      "shown": _vm.clearName
    }
  }, [_c('form', {
    on: {
      "submit": function($event) {
        $event.stopPropagation();
        $event.preventDefault();
        _vm.submit($event)
      }
    }
  }, [_c('b-form-input', {
    attrs: {
      "type": "text",
      "placeholder": "Nombre"
    },
    model: {
      value: (_vm.name),
      callback: function($$v) {
        _vm.name = $$v
      },
      expression: "name"
    }
  })], 1)]), _vm._v(" "), _c('b-modal', {
    ref: "modalUpdate",
    attrs: {
      "id": "modalUpdate",
      "title": "Actualizar Categoria",
      "close-title": "Cerrar"
    },
    on: {
      "ok": _vm.update
    }
  }, [_c('form', {
    on: {
      "submit": function($event) {
        $event.stopPropagation();
        $event.preventDefault();
        _vm.submit($event)
      }
    }
  }, [_c('b-form-input', {
    attrs: {
      "type": "text",
      "placeholder": "Nombre"
    },
    model: {
      value: (_vm.name),
      callback: function($$v) {
        _vm.name = $$v
      },
      expression: "name"
    }
  })], 1)])], 1)
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-0b84acec", esExports)
  }
}

/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_selector_type_script_index_0_dishes_vue__ = __webpack_require__(101);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_b60ab794_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_dishes_vue__ = __webpack_require__(102);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(99)
}
var normalizeComponent = __webpack_require__(8)
/* script */

/* template */

/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_selector_type_script_index_0_dishes_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_b60ab794_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_dishes_vue__["a" /* default */],
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "maintenance/components/dishes.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] dishes.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-b60ab794", Component.options)
  } else {
    hotAPI.reload("data-v-b60ab794", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(100);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(7)("472e6f6c", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-b60ab794\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./dishes.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-b60ab794\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./dishes.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(undefined);
// imports


// module
exports.push([module.i, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", ""]);

// exports


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_vuetable_2_src_components_Vuetable_vue__ = __webpack_require__(30);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ __webpack_exports__["a"] = ({
    props: ['categories', 'dishes'],
    data() {

        let categoriesOptions = [];
        categoriesOptions.push({ value: null, text: 'Seleccione una categoria', disabled: true });

        this.categories.data.map(c => {
            let co = {
                value: c.id,
                text: c.name
            }

            categoriesOptions.push(co);
        });

        return {
            fields: [{ name: 'id', title: '' },
            { name: 'name', title: 'Nombre' },
            { name: 'price', title: 'Precio' },
            { name: 'category.id', title: 'Categoria', callback: 'categoryFormatter' }
                , '__slot:actions'],
            localData: this.dishes.data,
            localCategories: categoriesOptions,
            dish: {
                name: '',
                price: '',
                category: {}
            },
            selectedRowData: {},
            selectedCategory: null
        }
    },
    computed: {
        /*httpOptions(){
            return {headers: {'Authorization': "my-token"}} //table props -> :http-options="httpOptions"
        },*/
    },
    components: {
        Vuetable: __WEBPACK_IMPORTED_MODULE_0_vuetable_2_src_components_Vuetable_vue__["a" /* default */]
    },
    methods: {
        categoryFormatter: function(value) {
            let result = this.categories.data.filter(c => {
                return c.id == value;
            })[0];
            return result.name;
        },
        editRow(rowData) {
            let dish = {
                id: rowData.id,
                name: rowData.name,
                price: rowData.price,
                category: {
                    id: rowData.category.id
                }
            };
            this.dish = dish;
            this.selectedCategory = rowData.category.id;
            this.$refs.modalUpdate.show();
        },
        deleteRow(rowData) {
            let index = this.localData.indexOf(rowData);
            this.localData.splice(index, 1);
        },
        clearData() {
            this.dish.price = '';
            this.dish.name = '';
            this.category = {};
            this.selectedCategory = null;
        },
        update() {
            let result = this.localData.filter(data => {
                return data.id == this.dish.id;
            })[0];

            result.name = this.dish.name;
            result.price = this.dish.price;
            result.category.id = this.selectedCategory;
        },
        submit(e) {
            if (!this.dish.name || !this.dish.price || !this.selectedCategory) {
                alert('Por favor ingrese todos los campos');
                return e.cancel();
            }

            let id = Math.max(...this.localData.map(v => parseInt(v.id))) || 0;
            let dish = {
                id: id + 1,
                name: this.dish.name,
                price: this.dish.price,
                category: {
                    id: this.selectedCategory
                }
            }
            this.localData.push(Object.assign(dish));

            this.dish.name = '';
            this.dish.price = '';
            this.dish.category = {};
        }
    }
});


/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_vm._v("\n    Platillos\n    "), _c('vuetable', {
    ref: "vuetable",
    attrs: {
      "api-mode": false,
      "data": _vm.localData,
      "fields": _vm.fields,
      "data-path": "data",
      "pagination-path": ""
    },
    scopedSlots: _vm._u([{
      key: "actions",
      fn: function(props) {
        return [_c('div', {
          staticClass: "table-button-container"
        }, [_c('b-button', {
          attrs: {
            "variant": "success",
            "size": "sm"
          },
          on: {
            "click": function($event) {
              _vm.editRow(props.rowData)
            }
          }
        }, [_c('i', {
          staticClass: "icon-pencil icons"
        })]), _vm._v(" "), _c('b-button', {
          attrs: {
            "variant": "danger",
            "size": "sm"
          },
          on: {
            "click": function($event) {
              _vm.deleteRow(props.rowData)
            }
          }
        }, [_c('i', {
          staticClass: "icon-ban icons"
        })])], 1)]
      }
    }])
  }), _vm._v(" "), _c('b-button', {
    directives: [{
      name: "b-modal",
      rawName: "v-b-modal.modalCreate",
      modifiers: {
        "modalCreate": true
      }
    }],
    attrs: {
      "variant": "success",
      "size": "sm"
    }
  }, [_c('i', {
    staticClass: "icon-plus icons"
  }), _vm._v(" Agregar")]), _vm._v(" "), _c('b-modal', {
    ref: "modalCreate",
    attrs: {
      "id": "modalCreate",
      "title": "Crear Platillo",
      "close-title": "Cerrar"
    },
    on: {
      "ok": _vm.submit,
      "shown": _vm.clearData
    }
  }, [_c('form', {
    on: {
      "submit": function($event) {
        $event.stopPropagation();
        $event.preventDefault();
        _vm.submit($event)
      }
    }
  }, [_c('b-form-input', {
    attrs: {
      "type": "text",
      "placeholder": "Nombre"
    },
    model: {
      value: (_vm.dish.name),
      callback: function($$v) {
        _vm.dish.name = $$v
      },
      expression: "dish.name"
    }
  }), _vm._v(" "), _c('br'), _vm._v(" "), _c('b-form-input', {
    attrs: {
      "type": "number",
      "placeholder": "Precio"
    },
    model: {
      value: (_vm.dish.price),
      callback: function($$v) {
        _vm.dish.price = $$v
      },
      expression: "dish.price"
    }
  }), _vm._v(" "), _c('br'), _vm._v(" "), _c('b-form-select', {
    attrs: {
      "options": _vm.localCategories,
      "plain": "true"
    },
    model: {
      value: (_vm.selectedCategory),
      callback: function($$v) {
        _vm.selectedCategory = $$v
      },
      expression: "selectedCategory"
    }
  })], 1)]), _vm._v(" "), _c('b-modal', {
    ref: "modalUpdate",
    attrs: {
      "id": "modalUpdate",
      "title": "Actualizar Platillo",
      "close-title": "Cerrar"
    },
    on: {
      "ok": _vm.update
    }
  }, [_c('form', {
    on: {
      "submit": function($event) {
        $event.stopPropagation();
        $event.preventDefault();
        _vm.submit($event)
      }
    }
  }, [_c('b-form-input', {
    attrs: {
      "type": "text",
      "placeholder": "Nombre"
    },
    model: {
      value: (_vm.dish.name),
      callback: function($$v) {
        _vm.dish.name = $$v
      },
      expression: "dish.name"
    }
  }), _vm._v(" "), _c('br'), _vm._v(" "), _c('b-form-input', {
    attrs: {
      "type": "number",
      "placeholder": "Precio"
    },
    model: {
      value: (_vm.dish.price),
      callback: function($$v) {
        _vm.dish.price = $$v
      },
      expression: "dish.price"
    }
  }), _vm._v(" "), _c('br'), _vm._v(" "), _c('b-form-select', {
    attrs: {
      "options": _vm.localCategories,
      "plain": "true"
    },
    model: {
      value: (_vm.selectedCategory),
      callback: function($$v) {
        _vm.selectedCategory = $$v
      },
      expression: "selectedCategory"
    }
  })], 1)])], 1)
}
var staticRenderFns = []
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-b60ab794", esExports)
  }
}

/***/ }),
/* 103 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_selector_type_script_index_0_menu_vue__ = __webpack_require__(106);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_b5911066_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_menu_vue__ = __webpack_require__(107);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(104)
}
var normalizeComponent = __webpack_require__(8)
/* script */

/* template */

/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_selector_type_script_index_0_menu_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_b5911066_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_menu_vue__["a" /* default */],
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "maintenance/components/menu.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] menu.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-b5911066", Component.options)
  } else {
    hotAPI.reload("data-v-b5911066", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(105);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(7)("4d4b72e8", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-b5911066\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./menu.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-b5911066\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./menu.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(undefined);
// imports


// module
exports.push([module.i, "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", ""]);

// exports


/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vue_tabs_vue_tabs_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__vue_tabs_vue_tabs_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__vue_tabs_vue_tabs_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vue_tabs_vue_tabs_css__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__vue_tabs_vue_tabs_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__vue_tabs_vue_tabs_css__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__menu_service_menu_service__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__menu_service_clients_service__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__menu_components_inline_edit_component__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__menu_components_inline_edit_component___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__menu_components_inline_edit_component__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//








/* harmony default export */ __webpack_exports__["a"] = ({
    data() {
        return {
            message: 'Administración de menus',
            clients: [],
            clientsService: __WEBPACK_IMPORTED_MODULE_3__menu_service_clients_service__["a" /* default */].service,
            activeClient: {},
            activeTabIndex: -1,
            newClientName: ''
        }
    },
    created: function() {
        // application init
        this.clientsService.clients = this.clients;

        //create an initial client and set it as active
        this.activeClient = this.clientsService.createClient('Client 1');
        this.clientsService.activeClient = this.activeClient;
    },
    mounted: function() {
        var $self = this;

        let addOrderToClientCallback = function(_order) {
            if ($self.$data.activeClient && $self.$data.activeClient.orders) {
                $self.$data.clientsService.addOrderToClient($self.$data.activeClient, _order);
            } else {
                alert('There are no selected clients')
            }
        }

        // execute the menu-service init 
        __WEBPACK_IMPORTED_MODULE_2__menu_service_menu_service__["a" /* default */].gridInit(addOrderToClientCallback);

    },
    computed: {

    },
    components: {
    },
    methods: {
        tabChanged: function(activeTabIndex, newTab, oldTab) {
            this.activeTabIndex = activeTabIndex;
            this.activeClient = this.clients[activeTabIndex];
            this.clientsService.activeClient = this.activeClient;
        },
        actionOrder: function(action, client, order) {
            if (action == 'plus') {
                this.clientsService.addOrderToClient(client, order);
            } else if (action == 'minus') {
                this.clientsService.substractOrderToClient(client, order);
            }
        },
        showClientModal: function() {
            this.$root.$emit('show::modal', 'addClientModal');
        },
        showBillModal: function() {
            this.$root.$emit('show::modal', 'checkAccountModal');
        },
        addClient: function(_name) {
            let name = _name;

            this.$data.clientsService.createClient(_name);

            if (this.$data.clientsService.clients.length === 1) {
                this.$data.activeClient = this.$data.clients[0];
                this.$data.clientsService.activeClient = this.$data.activeClient;
            }
            this.$data.newClientName = '';
        }
    }
});



/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_c('div', {
    staticClass: "container"
  }, [_c('div', {
    staticClass: "row"
  }, [_vm._m(0), _vm._v(" "), _c('div', {
    staticClass: "col-md-6 accounts-open"
  }, [_c('div', {
    staticClass: "actions-row"
  }, [_c('button', {
    staticClass: "btn btn-warning pull-right",
    attrs: {
      "type": "button"
    },
    on: {
      "click": _vm.showClientModal
    }
  }, [_vm._v("Nuevo clientes")])]), _vm._v(" "), _c('div', {
    staticClass: "tabs-container"
  }, [_c('vue-tabs', {
    on: {
      "tab-change": _vm.tabChanged
    }
  }, _vm._l((_vm.clients), function(client) {
    return _c('v-tab', {
      key: client
    }, [_c('div', {
      slot: "title"
    }, [_c('inline-edit', {
      attrs: {
        "text": client.name
      },
      on: {
        "changed": function (val) { return client.name = val; }
      }
    })], 1), _vm._v(" "), _c('div', {
      staticClass: "container-fluid orders-table"
    }, [_c('div', {
      staticClass: "row orders-table-header"
    }, [_c('div', {
      staticClass: "col-7"
    }, [_vm._v("Orden")]), _vm._v(" "), _c('div', {
      staticClass: "col-3 text-center"
    }, [_vm._v("Cantidad")]), _vm._v(" "), _c('div', {
      staticClass: "col-2"
    })]), _vm._v(" "), _vm._l((client.orders), function(order) {
      return _c('div', {
        key: order,
        staticClass: "row orders-table-row"
      }, [_c('div', {
        staticClass: "col-7"
      }, [_vm._v(_vm._s(order.value))]), _vm._v(" "), _c('div', {
        staticClass: "col-3 text-center"
      }, [_vm._v("x" + _vm._s(order.amount) + " ")]), _vm._v(" "), _c('div', {
        staticClass: "col-2"
      }, [_c('i', {
        staticClass: "icon-minus icons",
        on: {
          "click": function($event) {
            _vm.actionOrder('minus', client, order)
          }
        }
      }), _vm._v(" "), _c('i', {
        staticClass: "icon-plus icons",
        on: {
          "click": function($event) {
            _vm.actionOrder('plus', client, order)
          }
        }
      })])])
    })], 2)])
  }))], 1)])]), _vm._v(" "), _c('div', {
    staticClass: "text-center"
  }, [_c('button', {
    staticClass: "btn btn-success",
    attrs: {
      "type": "button",
      "id": "payButton"
    },
    on: {
      "click": _vm.showBillModal
    }
  }, [_vm._v("Pagar Factura")])])]), _vm._v(" "), _c('b-modal', {
    ref: "addClientModal",
    attrs: {
      "id": "addClientModal",
      "title": "Agregar Cliente",
      "hide-footer": "true"
    },
    on: {
      "ok": _vm.addClient
    }
  }, [_c('form', {
    on: {
      "submit": function($event) {
        $event.stopPropagation();
        $event.preventDefault();
        _vm.submit($event)
      }
    }
  }, [_c('div', {
    staticClass: "modal-body"
  }, [_c('form', [_c('div', {
    staticClass: "container"
  }, [_c('div', {
    staticClass: "row"
  }, [_c('div', {
    staticClass: "col-6"
  }, [_c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.newClientName),
      expression: "newClientName"
    }],
    staticClass: "form-control",
    attrs: {
      "type": "text",
      "minlength": "1",
      "required": "",
      "disable": "true",
      "placeholder": "Nombre del cliente"
    },
    domProps: {
      "value": (_vm.newClientName)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.newClientName = $event.target.value
      }
    }
  })]), _vm._v(" "), _c('div', {
    staticClass: "col-6"
  }, [_c('button', {
    staticClass: "btn btn-success",
    attrs: {
      "type": "button"
    },
    on: {
      "click": function($event) {
        _vm.addClient(_vm.newClientName)
      }
    }
  }, [_vm._v("Agregar")])])])]), _vm._v(" "), _c('div', {
    staticClass: "container clients-detail-area"
  }, _vm._l((_vm.clients), function(client) {
    return _c('div', {
      key: client,
      staticClass: "client-row col-12"
    }, [_vm._v("\n                            " + _vm._s(client.name) + "\n                        ")])
  }))])])])]), _vm._v(" "), _c('b-modal', {
    ref: "checkAccountModal",
    attrs: {
      "id": "checkAccountModal",
      "title": "Pago de Factura",
      "close-title": "Cancelar",
      "ok-title": "Pagar"
    },
    on: {
      "ok": _vm.payBill
    }
  }, [_c('form', {
    on: {
      "submit": function($event) {
        $event.stopPropagation();
        $event.preventDefault();
        _vm.submit($event)
      }
    }
  }, [_c('div', {
    staticClass: "modal-body"
  }, [_c('form', [_c('input', {
    attrs: {
      "type": "checkbox"
    }
  }), _vm._v("Cliente 1"), _c('br'), _vm._v(" "), _c('input', {
    attrs: {
      "type": "checkbox"
    }
  }), _vm._v("Cliente 2"), _c('br'), _vm._v(" "), _c('input', {
    attrs: {
      "type": "checkbox"
    }
  }), _vm._v("Cliente 3"), _c('br'), _vm._v(" "), _c('input', {
    attrs: {
      "type": "checkbox"
    }
  }), _vm._v("Cliente 4"), _c('br')])])])])], 1)
}
var staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "col-md-6 menu"
  }, [_c('div', {
    attrs: {
      "id": "container"
    }
  })])
}]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-b5911066", esExports)
  }
}

/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_selector_type_script_index_0_salon_vue__ = __webpack_require__(111);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6b2909bf_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_salon_vue__ = __webpack_require__(134);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(109)
}
var normalizeComponent = __webpack_require__(8)
/* script */

/* template */

/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_selector_type_script_index_0_salon_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_6b2909bf_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_salon_vue__["a" /* default */],
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "maintenance/components/salon.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] salon.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-6b2909bf", Component.options)
  } else {
    hotAPI.reload("data-v-6b2909bf", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(110);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(7)("8d7e1e8c", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-6b2909bf\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./salon.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-6b2909bf\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./salon.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(undefined);
// imports


// module
exports.push([module.i, "\n.canvas-container {\n    display: flex;\n    justify-content: center;\n}\n", ""]);

// exports


/***/ }),
/* 111 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fabric__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fabric___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_fabric__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ __webpack_exports__["a"] = ({
    props: ['tables', 'floor'],
    data() {
        return {
            message: 'Administración de salones',
            tableArray: [],
            selectedObjects: [],
            canvas:{}
        }
    },
    mounted: function() {
        var canvas = new fabric.Canvas('canvasFloor', this.floor.size);
        canvas.backgroundColor = this.floor.backgroundColor;
        this.loadConfiguration(canvas, JSON.parse(JSON.stringify(this.tables)), this.floor);
        canvas.renderAll();
        this.canvas = canvas;
        //select table event
        canvas.on({
            'object:selected': (event) => {
                let objects = [];
                if (event.target) {
                    if (event.target._objects) {
                        objects = event.target._objects;
                    } else {
                        objects = [event.target];
                    }
                    this.objectsSelected(objects);
                    this.$root.$emit('show::modal', 'openAccountModal');
                    canvas.renderAll();
                }
            }
        });

    },
    computed: {

    },
    components: {
    },
    methods: {
        showAccount: function() {
            this.$root.$emit('show::modal', 'modalAccount');
        },
        showTable: function() {
            this.$root.$emit('show::modal', 'modalTable');
        },
        addTableRect: function(_canvas, rect) {
            var rect = new fabric.Rect(rect);
            _canvas.getObjects();
            _canvas.add(rect);
            _canvas.selection = true;
            _canvas.renderAll();
            _canvas.calcOffset();

            return rect;
        },
        loadConfiguration: function(_canvas, tables) {
            var canvas_data = "";

            tables.forEach(table => {
                if (!table.rect) {
                    table.rect = {
                        left: 50,
                        top: 50
                    }
                }
                table.rect = this.addTableRect(_canvas, table.rect);
                this.tableArray.push(table);
            });

            _canvas._objects.forEach((c, index) => {
                c.hasControls = false;
                c.hasBorders = false;
                c.hoverCursor = 'pointer';
                c.lockMovementX = true;
                c.lockMovementY = true;
            })

            _canvas.renderAll();
        }, objectsSelected: function(_objects) {
            let objectsData = this.tableArray.filter((ta, index) => {
                return ta.rect.active;
            })
            
            this.selectedObjects = objectsData;
        }, openAccount: function() {
            // change the color of the selected object
            let openTable = this.selectedObjects[0];
            openTable.rect.set('fill', 'rgb(255,30,30)');
            openTable.occupied = true;
            this.canvas.renderAll();

            this.$router.app.$emit('save:configuration', this.tableArray, this.floor);
            this.goToMenu();
        }, goToMenu: function() {
            this.$router.push('menu');
        }
    }
});


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer, process) {/* build: `node build.js modules=ALL exclude=json,gestures,accessors minifier=uglifyjs` */
 /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */

var fabric = fabric || { version: '2.0.0-beta6' };
if (true) {
  exports.fabric = fabric;
}

if (typeof document !== 'undefined' && typeof window !== 'undefined') {
  fabric.document = document;
  fabric.window = window;
  // ensure globality even if entire library were function wrapped (as in Meteor.js packaging system)
  window.fabric = fabric;
}
else {
  // assume we're running under node.js when document/window are not present
  fabric.document = __webpack_require__(115)
    .jsdom(
      decodeURIComponent('%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E'),
      { features: {
        FetchExternalResources: ['img']
      }
    });

  fabric.window = fabric.document.defaultView;
}

/**
 * True when in environment that supports touch events
 * @type boolean
 */
fabric.isTouchSupported = 'ontouchstart' in fabric.document.documentElement;

/**
 * True when in environment that's probably Node.js
 * @type boolean
 */
fabric.isLikelyNode = typeof Buffer !== 'undefined' &&
                      typeof window === 'undefined';

/* _FROM_SVG_START_ */
/**
 * Attributes parsed from all SVG elements
 * @type array
 */
fabric.SHARED_ATTRIBUTES = [
  "display",
  "transform",
  "fill", "fill-opacity", "fill-rule",
  "opacity",
  "stroke", "stroke-dasharray", "stroke-linecap",
  "stroke-linejoin", "stroke-miterlimit",
  "stroke-opacity", "stroke-width",
  "id"
];
/* _FROM_SVG_END_ */

/**
 * Pixel per Inch as a default value set to 96. Can be changed for more realistic conversion.
 */
fabric.DPI = 96;
fabric.reNum = '(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:e[-+]?\\d+)?)';
fabric.fontPaths = { };
fabric.iMatrix = [1, 0, 0, 1, 0, 0];
fabric.canvasModule = 'canvas';

/**
 * Pixel limit for cache canvases. 1Mpx , 4Mpx should be fine.
 * @since 1.7.14
 * @type Number
 * @default
 */
fabric.perfLimitSizeTotal = 2097152;

/**
 * Pixel limit for cache canvases width or height. IE fixes the maximum at 5000
 * @since 1.7.14
 * @type Number
 * @default
 */
fabric.maxCacheSideLimit = 4096;

/**
 * Lowest pixel limit for cache canvases, set at 256PX
 * @since 1.7.14
 * @type Number
 * @default
 */
fabric.minCacheSideLimit = 256;

/**
 * Cache Object for widths of chars in text rendering.
 */
fabric.charWidthsCache = { };

/**
 * if webgl is enabled and available, textureSize will determine the size
 * of the canvas backend
 * @since 2.0.0
 * @type Number
 * @default
 */
fabric.textureSize = 2048;

/**
 * Enable webgl for filtering picture is available
 * A filtering backend will be initialized, this will both take memory and
 * time since a default 2048x2048 canvas will be created for the gl context
 * @since 2.0.0
 * @type Boolean
 * @default
 */
fabric.enableGLFiltering = true;

/**
 * Device Pixel Ratio
 * @see https://developer.apple.com/library/safari/documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html
 */
fabric.devicePixelRatio = fabric.window.devicePixelRatio ||
                          fabric.window.webkitDevicePixelRatio ||
                          fabric.window.mozDevicePixelRatio ||
                          1;

fabric.initFilterBackend = function() {
  if (fabric.enableGLFiltering && fabric.isWebglSupported && fabric.isWebglSupported(fabric.textureSize)) {
    console.log('max texture size: ' + fabric.maxTextureSize);
    return (new fabric.WebglFilterBackend({ tileSize: fabric.textureSize }));
  }
  else if (fabric.Canvas2dFilterBackend) {
    return (new fabric.Canvas2dFilterBackend());
  }
};


(function() {

  /**
   * @private
   * @param {String} eventName
   * @param {Function} handler
   */
  function _removeEventListener(eventName, handler) {
    if (!this.__eventListeners[eventName]) {
      return;
    }
    var eventListener = this.__eventListeners[eventName];
    if (handler) {
      eventListener[eventListener.indexOf(handler)] = false;
    }
    else {
      fabric.util.array.fill(eventListener, false);
    }
  }

  /**
   * Observes specified event
   * @deprecated `observe` deprecated since 0.8.34 (use `on` instead)
   * @memberOf fabric.Observable
   * @alias on
   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
   * @param {Function} handler Function that receives a notification when an event of the specified type occurs
   * @return {Self} thisArg
   * @chainable
   */
  function observe(eventName, handler) {
    if (!this.__eventListeners) {
      this.__eventListeners = { };
    }
    // one object with key/value pairs was passed
    if (arguments.length === 1) {
      for (var prop in eventName) {
        this.on(prop, eventName[prop]);
      }
    }
    else {
      if (!this.__eventListeners[eventName]) {
        this.__eventListeners[eventName] = [];
      }
      this.__eventListeners[eventName].push(handler);
    }
    return this;
  }

  /**
   * Stops event observing for a particular event handler. Calling this method
   * without arguments removes all handlers for all events
   * @deprecated `stopObserving` deprecated since 0.8.34 (use `off` instead)
   * @memberOf fabric.Observable
   * @alias off
   * @param {String|Object} eventName Event name (eg. 'after:render') or object with key/value pairs (eg. {'after:render': handler, 'selection:cleared': handler})
   * @param {Function} handler Function to be deleted from EventListeners
   * @return {Self} thisArg
   * @chainable
   */
  function stopObserving(eventName, handler) {
    if (!this.__eventListeners) {
      return;
    }

    // remove all key/value pairs (event name -> event handler)
    if (arguments.length === 0) {
      for (eventName in this.__eventListeners) {
        _removeEventListener.call(this, eventName);
      }
    }
    // one object with key/value pairs was passed
    else if (arguments.length === 1 && typeof arguments[0] === 'object') {
      for (var prop in eventName) {
        _removeEventListener.call(this, prop, eventName[prop]);
      }
    }
    else {
      _removeEventListener.call(this, eventName, handler);
    }
    return this;
  }

  /**
   * Fires event with an optional options object
   * @deprecated `fire` deprecated since 1.0.7 (use `trigger` instead)
   * @memberOf fabric.Observable
   * @alias trigger
   * @param {String} eventName Event name to fire
   * @param {Object} [options] Options object
   * @return {Self} thisArg
   * @chainable
   */
  function fire(eventName, options) {
    if (!this.__eventListeners) {
      return;
    }

    var listenersForEvent = this.__eventListeners[eventName];
    if (!listenersForEvent) {
      return;
    }

    for (var i = 0, len = listenersForEvent.length; i < len; i++) {
      listenersForEvent[i] && listenersForEvent[i].call(this, options || { });
    }
    this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {
      return value !== false;
    });
    return this;
  }

  /**
   * @namespace fabric.Observable
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#events}
   * @see {@link http://fabricjs.com/events|Events demo}
   */
  fabric.Observable = {
    observe: observe,
    stopObserving: stopObserving,
    fire: fire,

    on: observe,
    off: stopObserving,
    trigger: fire
  };
})();


/**
 * @namespace fabric.Collection
 */
fabric.Collection = {

  _objects: [],

  /**
   * Adds objects to collection, Canvas or Group, then renders canvas
   * (if `renderOnAddRemove` is not `false`).
   * in case of Group no changes to bounding box are made.
   * Objects should be instances of (or inherit from) fabric.Object
   * @param {...fabric.Object} object Zero or more fabric instances
   * @return {Self} thisArg
   * @chainable
   */
  add: function () {
    this._objects.push.apply(this._objects, arguments);
    if (this._onObjectAdded) {
      for (var i = 0, length = arguments.length; i < length; i++) {
        this._onObjectAdded(arguments[i]);
      }
    }
    this.renderOnAddRemove && this.requestRenderAll();
    return this;
  },

  /**
   * Inserts an object into collection at specified index, then renders canvas (if `renderOnAddRemove` is not `false`)
   * An object should be an instance of (or inherit from) fabric.Object
   * @param {Object} object Object to insert
   * @param {Number} index Index to insert object at
   * @param {Boolean} nonSplicing When `true`, no splicing (shifting) of objects occurs
   * @return {Self} thisArg
   * @chainable
   */
  insertAt: function (object, index, nonSplicing) {
    var objects = this.getObjects();
    if (nonSplicing) {
      objects[index] = object;
    }
    else {
      objects.splice(index, 0, object);
    }
    this._onObjectAdded && this._onObjectAdded(object);
    this.renderOnAddRemove && this.requestRenderAll();
    return this;
  },

  /**
   * Removes objects from a collection, then renders canvas (if `renderOnAddRemove` is not `false`)
   * @param {...fabric.Object} object Zero or more fabric instances
   * @return {Self} thisArg
   * @chainable
   */
  remove: function() {
    var objects = this.getObjects(),
        index, somethingRemoved = false;

    for (var i = 0, length = arguments.length; i < length; i++) {
      index = objects.indexOf(arguments[i]);

      // only call onObjectRemoved if an object was actually removed
      if (index !== -1) {
        somethingRemoved = true;
        objects.splice(index, 1);
        this._onObjectRemoved && this._onObjectRemoved(arguments[i]);
      }
    }

    this.renderOnAddRemove && somethingRemoved && this.requestRenderAll();
    return this;
  },

  /**
   * Executes given function for each object in this group
   * @param {Function} callback
   *                   Callback invoked with current object as first argument,
   *                   index - as second and an array of all objects - as third.
   *                   Callback is invoked in a context of Global Object (e.g. `window`)
   *                   when no `context` argument is given
   *
   * @param {Object} context Context (aka thisObject)
   * @return {Self} thisArg
   * @chainable
   */
  forEachObject: function(callback, context) {
    var objects = this.getObjects();
    for (var i = 0, len = objects.length; i < len; i++) {
      callback.call(context, objects[i], i, objects);
    }
    return this;
  },

  /**
   * Returns an array of children objects of this instance
   * Type parameter introduced in 1.3.10
   * @param {String} [type] When specified, only objects of this type are returned
   * @return {Array}
   */
  getObjects: function(type) {
    if (typeof type === 'undefined') {
      return this._objects;
    }
    return this._objects.filter(function(o) {
      return o.type === type;
    });
  },

  /**
   * Returns object at specified index
   * @param {Number} index
   * @return {Self} thisArg
   */
  item: function (index) {
    return this.getObjects()[index];
  },

  /**
   * Returns true if collection contains no objects
   * @return {Boolean} true if collection is empty
   */
  isEmpty: function () {
    return this.getObjects().length === 0;
  },

  /**
   * Returns a size of a collection (i.e: length of an array containing its objects)
   * @return {Number} Collection size
   */
  size: function() {
    return this.getObjects().length;
  },

  /**
   * Returns true if collection contains an object
   * @param {Object} object Object to check against
   * @return {Boolean} `true` if collection contains an object
   */
  contains: function(object) {
    return this.getObjects().indexOf(object) > -1;
  },

  /**
   * Returns number representation of a collection complexity
   * @return {Number} complexity
   */
  complexity: function () {
    return this.getObjects().reduce(function (memo, current) {
      memo += current.complexity ? current.complexity() : 0;
      return memo;
    }, 0);
  }
};


/**
 * @namespace fabric.CommonMethods
 */
fabric.CommonMethods = {

  /**
   * Sets object's properties from options
   * @param {Object} [options] Options object
   */
  _setOptions: function(options) {
    for (var prop in options) {
      this.set(prop, options[prop]);
    }
  },

  /**
   * @private
   * @param {Object} [filler] Options object
   * @param {String} [property] property to set the Gradient to
   */
  _initGradient: function(filler, property) {
    if (filler && filler.colorStops && !(filler instanceof fabric.Gradient)) {
      this.set(property, new fabric.Gradient(filler));
    }
  },

  /**
   * @private
   * @param {Object} [filler] Options object
   * @param {String} [property] property to set the Pattern to
   * @param {Function} [callback] callback to invoke after pattern load
   */
  _initPattern: function(filler, property, callback) {
    if (filler && filler.source && !(filler instanceof fabric.Pattern)) {
      this.set(property, new fabric.Pattern(filler, callback));
    }
    else {
      callback && callback();
    }
  },

  /**
   * @private
   * @param {Object} [options] Options object
   */
  _initClipping: function(options) {
    if (!options.clipTo || typeof options.clipTo !== 'string') {
      return;
    }

    var functionBody = fabric.util.getFunctionBody(options.clipTo);
    if (typeof functionBody !== 'undefined') {
      this.clipTo = new Function('ctx', functionBody);
    }
  },

  /**
   * @private
   */
  _setObject: function(obj) {
    for (var prop in obj) {
      this._set(prop, obj[prop]);
    }
  },

  /**
   * Sets property to a given value. When changing position/dimension -related properties (left, top, scale, angle, etc.) `set` does not update position of object's borders/controls. If you need to update those, call `setCoords()`.
   * @param {String|Object} key Property name or object (if object, iterate over the object properties)
   * @param {Object|Function} value Property value (if function, the value is passed into it and its return value is used as a new one)
   * @return {fabric.Object} thisArg
   * @chainable
   */
  set: function(key, value) {
    if (typeof key === 'object') {
      this._setObject(key);
    }
    else {
      if (typeof value === 'function' && key !== 'clipTo') {
        this._set(key, value(this.get(key)));
      }
      else {
        this._set(key, value);
      }
    }
    return this;
  },

  _set: function(key, value) {
    this[key] = value;
  },

  /**
   * Toggles specified property from `true` to `false` or from `false` to `true`
   * @param {String} property Property to toggle
   * @return {fabric.Object} thisArg
   * @chainable
   */
  toggle: function(property) {
    var value = this.get(property);
    if (typeof value === 'boolean') {
      this.set(property, !value);
    }
    return this;
  },

  /**
   * Basic getter
   * @param {String} property Property name
   * @return {*} value of a property
   */
  get: function(property) {
    return this[property];
  }
};


(function(global) {

  var sqrt = Math.sqrt,
      atan2 = Math.atan2,
      pow = Math.pow,
      abs = Math.abs,
      PiBy180 = Math.PI / 180;

  /**
   * @namespace fabric.util
   */
  fabric.util = {

    /**
     * Removes value from an array.
     * Presence of value (and its position in an array) is determined via `Array.prototype.indexOf`
     * @static
     * @memberOf fabric.util
     * @param {Array} array
     * @param {*} value
     * @return {Array} original array
     */
    removeFromArray: function(array, value) {
      var idx = array.indexOf(value);
      if (idx !== -1) {
        array.splice(idx, 1);
      }
      return array;
    },

    /**
     * Returns random number between 2 specified ones.
     * @static
     * @memberOf fabric.util
     * @param {Number} min lower limit
     * @param {Number} max upper limit
     * @return {Number} random value (between min and max)
     */
    getRandomInt: function(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    },

    /**
     * Transforms degrees to radians.
     * @static
     * @memberOf fabric.util
     * @param {Number} degrees value in degrees
     * @return {Number} value in radians
     */
    degreesToRadians: function(degrees) {
      return degrees * PiBy180;
    },

    /**
     * Transforms radians to degrees.
     * @static
     * @memberOf fabric.util
     * @param {Number} radians value in radians
     * @return {Number} value in degrees
     */
    radiansToDegrees: function(radians) {
      return radians / PiBy180;
    },

    /**
     * Rotates `point` around `origin` with `radians`
     * @static
     * @memberOf fabric.util
     * @param {fabric.Point} point The point to rotate
     * @param {fabric.Point} origin The origin of the rotation
     * @param {Number} radians The radians of the angle for the rotation
     * @return {fabric.Point} The new rotated point
     */
    rotatePoint: function(point, origin, radians) {
      point.subtractEquals(origin);
      var v = fabric.util.rotateVector(point, radians);
      return new fabric.Point(v.x, v.y).addEquals(origin);
    },

    /**
     * Rotates `vector` with `radians`
     * @static
     * @memberOf fabric.util
     * @param {Object} vector The vector to rotate (x and y)
     * @param {Number} radians The radians of the angle for the rotation
     * @return {Object} The new rotated point
     */
    rotateVector: function(vector, radians) {
      var sin = Math.sin(radians),
          cos = Math.cos(radians),
          rx = vector.x * cos - vector.y * sin,
          ry = vector.x * sin + vector.y * cos;
      return {
        x: rx,
        y: ry
      };
    },

    /**
     * Apply transform t to point p
     * @static
     * @memberOf fabric.util
     * @param  {fabric.Point} p The point to transform
     * @param  {Array} t The transform
     * @param  {Boolean} [ignoreOffset] Indicates that the offset should not be applied
     * @return {fabric.Point} The transformed point
     */
    transformPoint: function(p, t, ignoreOffset) {
      if (ignoreOffset) {
        return new fabric.Point(
          t[0] * p.x + t[2] * p.y,
          t[1] * p.x + t[3] * p.y
        );
      }
      return new fabric.Point(
        t[0] * p.x + t[2] * p.y + t[4],
        t[1] * p.x + t[3] * p.y + t[5]
      );
    },

    /**
     * Returns coordinates of points's bounding rectangle (left, top, width, height)
     * @param {Array} points 4 points array
     * @return {Object} Object with left, top, width, height properties
     */
    makeBoundingBoxFromPoints: function(points) {
      var xPoints = [points[0].x, points[1].x, points[2].x, points[3].x],
          minX = fabric.util.array.min(xPoints),
          maxX = fabric.util.array.max(xPoints),
          width = Math.abs(minX - maxX),
          yPoints = [points[0].y, points[1].y, points[2].y, points[3].y],
          minY = fabric.util.array.min(yPoints),
          maxY = fabric.util.array.max(yPoints),
          height = Math.abs(minY - maxY);

      return {
        left: minX,
        top: minY,
        width: width,
        height: height
      };
    },

    /**
     * Invert transformation t
     * @static
     * @memberOf fabric.util
     * @param {Array} t The transform
     * @return {Array} The inverted transform
     */
    invertTransform: function(t) {
      var a = 1 / (t[0] * t[3] - t[1] * t[2]),
          r = [a * t[3], -a * t[1], -a * t[2], a * t[0]],
          o = fabric.util.transformPoint({ x: t[4], y: t[5] }, r, true);
      r[4] = -o.x;
      r[5] = -o.y;
      return r;
    },

    /**
     * A wrapper around Number#toFixed, which contrary to native method returns number, not string.
     * @static
     * @memberOf fabric.util
     * @param {Number|String} number number to operate on
     * @param {Number} fractionDigits number of fraction digits to "leave"
     * @return {Number}
     */
    toFixed: function(number, fractionDigits) {
      return parseFloat(Number(number).toFixed(fractionDigits));
    },

    /**
     * Converts from attribute value to pixel value if applicable.
     * Returns converted pixels or original value not converted.
     * @param {Number|String} value number to operate on
     * @param {Number} fontSize
     * @return {Number|String}
     */
    parseUnit: function(value, fontSize) {
      var unit = /\D{0,2}$/.exec(value),
          number = parseFloat(value);
      if (!fontSize) {
        fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
      }
      switch (unit[0]) {
        case 'mm':
          return number * fabric.DPI / 25.4;

        case 'cm':
          return number * fabric.DPI / 2.54;

        case 'in':
          return number * fabric.DPI;

        case 'pt':
          return number * fabric.DPI / 72; // or * 4 / 3

        case 'pc':
          return number * fabric.DPI / 72 * 12; // or * 16

        case 'em':
          return number * fontSize;

        default:
          return number;
      }
    },

    /**
     * Function which always returns `false`.
     * @static
     * @memberOf fabric.util
     * @return {Boolean}
     */
    falseFunction: function() {
      return false;
    },

    /**
     * Returns klass "Class" object of given namespace
     * @memberOf fabric.util
     * @param {String} type Type of object (eg. 'circle')
     * @param {String} namespace Namespace to get klass "Class" object from
     * @return {Object} klass "Class"
     */
    getKlass: function(type, namespace) {
      // capitalize first letter only
      type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));
      return fabric.util.resolveNamespace(namespace)[type];
    },

    /**
     * Returns object of given namespace
     * @memberOf fabric.util
     * @param {String} namespace Namespace string e.g. 'fabric.Image.filter' or 'fabric'
     * @return {Object} Object for given namespace (default fabric)
     */
    resolveNamespace: function(namespace) {
      if (!namespace) {
        return fabric;
      }

      var parts = namespace.split('.'),
          len = parts.length, i,
          obj = global || fabric.window;

      for (i = 0; i < len; ++i) {
        obj = obj[parts[i]];
      }

      return obj;
    },

    /**
     * Loads image element from given url and passes it to a callback
     * @memberOf fabric.util
     * @param {String} url URL representing an image
     * @param {Function} callback Callback; invoked with loaded image
     * @param {*} [context] Context to invoke callback in
     * @param {Object} [crossOrigin] crossOrigin value to set image element to
     */
    loadImage: function(url, callback, context, crossOrigin) {
      if (!url) {
        callback && callback.call(context, url);
        return;
      }

      var img = fabric.util.createImage();

      /** @ignore */
      img.onload = function () {
        callback && callback.call(context, img);
        img = img.onload = img.onerror = null;
      };

      /** @ignore */
      img.onerror = function() {
        fabric.log('Error loading ' + img.src);
        callback && callback.call(context, null, true);
        img = img.onload = img.onerror = null;
      };

      // data-urls appear to be buggy with crossOrigin
      // https://github.com/kangax/fabric.js/commit/d0abb90f1cd5c5ef9d2a94d3fb21a22330da3e0a#commitcomment-4513767
      // see https://code.google.com/p/chromium/issues/detail?id=315152
      //     https://bugzilla.mozilla.org/show_bug.cgi?id=935069
      if (url.indexOf('data') !== 0 && crossOrigin) {
        img.crossOrigin = crossOrigin;
      }

      img.src = url;
    },

    /**
     * Creates corresponding fabric instances from their object representations
     * @static
     * @memberOf fabric.util
     * @param {Array} objects Objects to enliven
     * @param {Function} callback Callback to invoke when all objects are created
     * @param {String} namespace Namespace to get klass "Class" object from
     * @param {Function} reviver Method for further parsing of object elements,
     * called after each fabric object created.
     */
    enlivenObjects: function(objects, callback, namespace, reviver) {
      objects = objects || [];

      function onLoaded() {
        if (++numLoadedObjects === numTotalObjects) {
          callback && callback(enlivenedObjects);
        }
      }

      var enlivenedObjects = [],
          numLoadedObjects = 0,
          numTotalObjects = objects.length;

      if (!numTotalObjects) {
        callback && callback(enlivenedObjects);
        return;
      }

      objects.forEach(function (o, index) {
        // if sparse array
        if (!o || !o.type) {
          onLoaded();
          return;
        }
        var klass = fabric.util.getKlass(o.type, namespace);
        klass.fromObject(o, function (obj, error) {
          error || (enlivenedObjects[index] = obj);
          reviver && reviver(o, obj, error);
          onLoaded();
        });
      });
    },

    /**
     * Create and wait for loading of patterns
     * @static
     * @memberOf fabric.util
     * @param {Array} patterns Objects to enliven
     * @param {Function} callback Callback to invoke when all objects are created
     * called after each fabric object created.
     */
    enlivenPatterns: function(patterns, callback) {
      patterns = patterns || [];

      function onLoaded() {
        if (++numLoadedPatterns === numPatterns) {
          callback && callback(enlivenedPatterns);
        }
      }

      var enlivenedPatterns = [],
          numLoadedPatterns = 0,
          numPatterns = patterns.length;

      if (!numPatterns) {
        callback && callback(enlivenedPatterns);
        return;
      }

      patterns.forEach(function (p, index) {
        if (p && p.source) {
          new fabric.Pattern(p, function(pattern) {
            enlivenedPatterns[index] = pattern;
            onLoaded();
          });
        }
        else {
          enlivenedPatterns[index] = p;
          onLoaded();
        }
      });
    },

    /**
     * Groups SVG elements (usually those retrieved from SVG document)
     * @static
     * @memberOf fabric.util
     * @param {Array} elements SVG elements to group
     * @param {Object} [options] Options object
     * @param {String} path Value to set sourcePath to
     * @return {fabric.Object|fabric.Group}
     */
    groupSVGElements: function(elements, options, path) {
      var object;
      if (elements.length === 1) {
        return elements[0];
      }
      if (options) {
        if (options.width && options.height) {
          options.centerPoint = {
            x: options.width / 2,
            y: options.height / 2
          };
        }
        else {
          delete options.width;
          delete options.height;
        }
      }
      object = new fabric.Group(elements, options);
      if (typeof path !== 'undefined') {
        object.sourcePath = path;
      }
      return object;
    },

    /**
     * Populates an object with properties of another object
     * @static
     * @memberOf fabric.util
     * @param {Object} source Source object
     * @param {Object} destination Destination object
     * @return {Array} properties Properties names to include
     */
    populateWithProperties: function(source, destination, properties) {
      if (properties && Object.prototype.toString.call(properties) === '[object Array]') {
        for (var i = 0, len = properties.length; i < len; i++) {
          if (properties[i] in source) {
            destination[properties[i]] = source[properties[i]];
          }
        }
      }
    },

    /**
     * Draws a dashed line between two points
     *
     * This method is used to draw dashed line around selection area.
     * See <a href="http://stackoverflow.com/questions/4576724/dotted-stroke-in-canvas">dotted stroke in canvas</a>
     *
     * @param {CanvasRenderingContext2D} ctx context
     * @param {Number} x  start x coordinate
     * @param {Number} y start y coordinate
     * @param {Number} x2 end x coordinate
     * @param {Number} y2 end y coordinate
     * @param {Array} da dash array pattern
     */
    drawDashedLine: function(ctx, x, y, x2, y2, da) {
      var dx = x2 - x,
          dy = y2 - y,
          len = sqrt(dx * dx + dy * dy),
          rot = atan2(dy, dx),
          dc = da.length,
          di = 0,
          draw = true;

      ctx.save();
      ctx.translate(x, y);
      ctx.moveTo(0, 0);
      ctx.rotate(rot);

      x = 0;
      while (len > x) {
        x += da[di++ % dc];
        if (x > len) {
          x = len;
        }
        ctx[draw ? 'lineTo' : 'moveTo'](x, 0);
        draw = !draw;
      }

      ctx.restore();
    },

    /**
     * Creates canvas element
     * @static
     * @memberOf fabric.util
     * @return {CanvasElement} initialized canvas element
     */
    createCanvasElement: function() {
      return fabric.document.createElement('canvas');
    },

    /**
     * Creates image element (works on client and node)
     * @static
     * @memberOf fabric.util
     * @return {HTMLImageElement} HTML image element
     */
    createImage: function() {
      return fabric.document.createElement('img');
    },

    /**
     * @static
     * @memberOf fabric.util
     * @deprecated since 2.0.0
     * @param {fabric.Object} receiver Object implementing `clipTo` method
     * @param {CanvasRenderingContext2D} ctx Context to clip
     */
    clipContext: function(receiver, ctx) {
      ctx.save();
      ctx.beginPath();
      receiver.clipTo(ctx);
      ctx.clip();
    },

    /**
     * Multiply matrix A by matrix B to nest transformations
     * @static
     * @memberOf fabric.util
     * @param  {Array} a First transformMatrix
     * @param  {Array} b Second transformMatrix
     * @param  {Boolean} is2x2 flag to multiply matrices as 2x2 matrices
     * @return {Array} The product of the two transform matrices
     */
    multiplyTransformMatrices: function(a, b, is2x2) {
      // Matrix multiply a * b
      return [
        a[0] * b[0] + a[2] * b[1],
        a[1] * b[0] + a[3] * b[1],
        a[0] * b[2] + a[2] * b[3],
        a[1] * b[2] + a[3] * b[3],
        is2x2 ? 0 : a[0] * b[4] + a[2] * b[5] + a[4],
        is2x2 ? 0 : a[1] * b[4] + a[3] * b[5] + a[5]
      ];
    },

    /**
     * Decomposes standard 2x2 matrix into transform componentes
     * @static
     * @memberOf fabric.util
     * @param  {Array} a transformMatrix
     * @return {Object} Components of transform
     */
    qrDecompose: function(a) {
      var angle = atan2(a[1], a[0]),
          denom = pow(a[0], 2) + pow(a[1], 2),
          scaleX = sqrt(denom),
          scaleY = (a[0] * a[3] - a[2] * a [1]) / scaleX,
          skewX = atan2(a[0] * a[2] + a[1] * a [3], denom);
      return {
        angle: angle  / PiBy180,
        scaleX: scaleX,
        scaleY: scaleY,
        skewX: skewX / PiBy180,
        skewY: 0,
        translateX: a[4],
        translateY: a[5]
      };
    },

    customTransformMatrix: function(scaleX, scaleY, skewX) {
      var skewMatrixX = [1, 0, abs(Math.tan(skewX * PiBy180)), 1],
          scaleMatrix = [abs(scaleX), 0, 0, abs(scaleY)];
      return fabric.util.multiplyTransformMatrices(scaleMatrix, skewMatrixX, true);
    },

    resetObjectTransform: function (target) {
      target.scaleX = 1;
      target.scaleY = 1;
      target.skewX = 0;
      target.skewY = 0;
      target.flipX = false;
      target.flipY = false;
      target.rotate(0);
    },

    /**
     * Returns string representation of function body
     * @param {Function} fn Function to get body of
     * @return {String} Function body
     */
    getFunctionBody: function(fn) {
      return (String(fn).match(/function[^{]*\{([\s\S]*)\}/) || {})[1];
    },

    /**
     * Returns true if context has transparent pixel
     * at specified location (taking tolerance into account)
     * @param {CanvasRenderingContext2D} ctx context
     * @param {Number} x x coordinate
     * @param {Number} y y coordinate
     * @param {Number} tolerance Tolerance
     */
    isTransparent: function(ctx, x, y, tolerance) {

      // If tolerance is > 0 adjust start coords to take into account.
      // If moves off Canvas fix to 0
      if (tolerance > 0) {
        if (x > tolerance) {
          x -= tolerance;
        }
        else {
          x = 0;
        }
        if (y > tolerance) {
          y -= tolerance;
        }
        else {
          y = 0;
        }
      }

      var _isTransparent = true, i, temp,
          imageData = ctx.getImageData(x, y, (tolerance * 2) || 1, (tolerance * 2) || 1),
          l = imageData.data.length;

      // Split image data - for tolerance > 1, pixelDataSize = 4;
      for (i = 3; i < l; i += 4) {
        temp = imageData.data[i];
        _isTransparent = temp <= 0;
        if (_isTransparent === false) {
          break; // Stop if colour found
        }
      }

      imageData = null;

      return _isTransparent;
    },

    /**
     * Parse preserveAspectRatio attribute from element
     * @param {string} attribute to be parsed
     * @return {Object} an object containing align and meetOrSlice attribute
     */
    parsePreserveAspectRatioAttribute: function(attribute) {
      var meetOrSlice = 'meet', alignX = 'Mid', alignY = 'Mid',
          aspectRatioAttrs = attribute.split(' '), align;

      if (aspectRatioAttrs && aspectRatioAttrs.length) {
        meetOrSlice = aspectRatioAttrs.pop();
        if (meetOrSlice !== 'meet' && meetOrSlice !== 'slice') {
          align = meetOrSlice;
          meetOrSlice = 'meet';
        }
        else if (aspectRatioAttrs.length) {
          align = aspectRatioAttrs.pop();
        }
      }
      //divide align in alignX and alignY
      alignX = align !== 'none' ? align.slice(1, 4) : 'none';
      alignY = align !== 'none' ? align.slice(5, 8) : 'none';
      return {
        meetOrSlice: meetOrSlice,
        alignX: alignX,
        alignY: alignY
      };
    },

    /**
     * Clear char widths cache for a font family.
     * @memberOf fabric.util
     * @param {String} [fontFamily] font family to clear
     */
    clearFabricFontCache: function(fontFamily) {
      if (!fontFamily) {
        fabric.charWidthsCache = { };
      }
      else if (fabric.charWidthsCache[fontFamily]) {
        delete fabric.charWidthsCache[fontFamily];
      }
    },

    /**
     * Clear char widths cache for a font family.
     * @memberOf fabric.util
     * @param {Number} ar aspect ratio
     * @param {Number} maximumArea Maximum area you want to achieve
     * @return {Object.x} Limited dimensions by X
     * @return {Object.y} Limited dimensions by Y
     */
    limitDimsByArea: function(ar, maximumArea) {
      var roughWidth = Math.sqrt(maximumArea * ar),
          perfLimitSizeY = Math.floor(maximumArea / roughWidth);
      return { x: Math.floor(roughWidth), y: perfLimitSizeY };
    },

    capValue: function(min, value, max) {
      return Math.max(min, Math.min(value, max));
    },

    findScaleToFit: function(source, destination) {
      return Math.min(destination.width / source.width, destination.height / source.height);
    },

    findScaleToCover: function(source, destination) {
      return Math.max(destination.width / source.width, destination.height / source.height);
    }
  };
})( true ? exports : this);


(function() {

  var arcToSegmentsCache = { },
      segmentToBezierCache = { },
      boundsOfCurveCache = { },
      _join = Array.prototype.join;

  /* Adapted from http://dxr.mozilla.org/mozilla-central/source/content/svg/content/src/nsSVGPathDataParser.cpp
   * by Andrea Bogazzi code is under MPL. if you don't have a copy of the license you can take it here
   * http://mozilla.org/MPL/2.0/
   */
  function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
    var argsString = _join.call(arguments);
    if (arcToSegmentsCache[argsString]) {
      return arcToSegmentsCache[argsString];
    }

    var PI = Math.PI, th = rotateX * PI / 180,
        sinTh = Math.sin(th),
        cosTh = Math.cos(th),
        fromX = 0, fromY = 0;

    rx = Math.abs(rx);
    ry = Math.abs(ry);

    var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5,
        py = -cosTh * toY * 0.5 + sinTh * toX * 0.5,
        rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px,
        pl = rx2 * ry2 - rx2 * py2 - ry2 * px2,
        root = 0;

    if (pl < 0) {
      var s = Math.sqrt(1 - pl / (rx2 * ry2));
      rx *= s;
      ry *= s;
    }
    else {
      root = (large === sweep ? -1.0 : 1.0) *
              Math.sqrt( pl / (rx2 * py2 + ry2 * px2));
    }

    var cx = root * rx * py / ry,
        cy = -root * ry * px / rx,
        cx1 = cosTh * cx - sinTh * cy + toX * 0.5,
        cy1 = sinTh * cx + cosTh * cy + toY * 0.5,
        mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry),
        dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);

    if (sweep === 0 && dtheta > 0) {
      dtheta -= 2 * PI;
    }
    else if (sweep === 1 && dtheta < 0) {
      dtheta += 2 * PI;
    }

    // Convert into cubic bezier segments <= 90deg
    var segments = Math.ceil(Math.abs(dtheta / PI * 2)),
        result = [], mDelta = dtheta / segments,
        mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2),
        th3 = mTheta + mDelta;

    for (var i = 0; i < segments; i++) {
      result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
      fromX = result[i][4];
      fromY = result[i][5];
      mTheta = th3;
      th3 += mDelta;
    }
    arcToSegmentsCache[argsString] = result;
    return result;
  }

  function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
    var argsString2 = _join.call(arguments);
    if (segmentToBezierCache[argsString2]) {
      return segmentToBezierCache[argsString2];
    }

    var costh2 = Math.cos(th2),
        sinth2 = Math.sin(th2),
        costh3 = Math.cos(th3),
        sinth3 = Math.sin(th3),
        toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1,
        toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1,
        cp1X = fromX + mT * ( -cosTh * rx * sinth2 - sinTh * ry * costh2),
        cp1Y = fromY + mT * ( -sinTh * rx * sinth2 + cosTh * ry * costh2),
        cp2X = toX + mT * ( cosTh * rx * sinth3 + sinTh * ry * costh3),
        cp2Y = toY + mT * ( sinTh * rx * sinth3 - cosTh * ry * costh3);

    segmentToBezierCache[argsString2] = [
      cp1X, cp1Y,
      cp2X, cp2Y,
      toX, toY
    ];
    return segmentToBezierCache[argsString2];
  }

  /*
   * Private
   */
  function calcVectorAngle(ux, uy, vx, vy) {
    var ta = Math.atan2(uy, ux),
        tb = Math.atan2(vy, vx);
    if (tb >= ta) {
      return tb - ta;
    }
    else {
      return 2 * Math.PI - (ta - tb);
    }
  }

  /**
   * Draws arc
   * @param {CanvasRenderingContext2D} ctx
   * @param {Number} fx
   * @param {Number} fy
   * @param {Array} coords
   */
  fabric.util.drawArc = function(ctx, fx, fy, coords) {
    var rx = coords[0],
        ry = coords[1],
        rot = coords[2],
        large = coords[3],
        sweep = coords[4],
        tx = coords[5],
        ty = coords[6],
        segs = [[], [], [], []],
        segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

    for (var i = 0, len = segsNorm.length; i < len; i++) {
      segs[i][0] = segsNorm[i][0] + fx;
      segs[i][1] = segsNorm[i][1] + fy;
      segs[i][2] = segsNorm[i][2] + fx;
      segs[i][3] = segsNorm[i][3] + fy;
      segs[i][4] = segsNorm[i][4] + fx;
      segs[i][5] = segsNorm[i][5] + fy;
      ctx.bezierCurveTo.apply(ctx, segs[i]);
    }
  };

  /**
   * Calculate bounding box of a elliptic-arc
   * @param {Number} fx start point of arc
   * @param {Number} fy
   * @param {Number} rx horizontal radius
   * @param {Number} ry vertical radius
   * @param {Number} rot angle of horizontal axe
   * @param {Number} large 1 or 0, whatever the arc is the big or the small on the 2 points
   * @param {Number} sweep 1 or 0, 1 clockwise or counterclockwise direction
   * @param {Number} tx end point of arc
   * @param {Number} ty
   */
  fabric.util.getBoundsOfArc = function(fx, fy, rx, ry, rot, large, sweep, tx, ty) {

    var fromX = 0, fromY = 0, bound, bounds = [],
        segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);

    for (var i = 0, len = segs.length; i < len; i++) {
      bound = getBoundsOfCurve(fromX, fromY, segs[i][0], segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5]);
      bounds.push({ x: bound[0].x + fx, y: bound[0].y + fy });
      bounds.push({ x: bound[1].x + fx, y: bound[1].y + fy });
      fromX = segs[i][4];
      fromY = segs[i][5];
    }
    return bounds;
  };

  /**
   * Calculate bounding box of a beziercurve
   * @param {Number} x0 starting point
   * @param {Number} y0
   * @param {Number} x1 first control point
   * @param {Number} y1
   * @param {Number} x2 secondo control point
   * @param {Number} y2
   * @param {Number} x3 end of beizer
   * @param {Number} y3
   */
  // taken from http://jsbin.com/ivomiq/56/edit  no credits available for that.
  function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
    var argsString = _join.call(arguments);
    if (boundsOfCurveCache[argsString]) {
      return boundsOfCurveCache[argsString];
    }

    var sqrt = Math.sqrt,
        min = Math.min, max = Math.max,
        abs = Math.abs, tvalues = [],
        bounds = [[], []],
        a, b, c, t, t1, t2, b2ac, sqrtb2ac;

    b = 6 * x0 - 12 * x1 + 6 * x2;
    a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
    c = 3 * x1 - 3 * x0;

    for (var i = 0; i < 2; ++i) {
      if (i > 0) {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }

      if (abs(a) < 1e-12) {
        if (abs(b) < 1e-12) {
          continue;
        }
        t = -c / b;
        if (0 < t && t < 1) {
          tvalues.push(t);
        }
        continue;
      }
      b2ac = b * b - 4 * c * a;
      if (b2ac < 0) {
        continue;
      }
      sqrtb2ac = sqrt(b2ac);
      t1 = (-b + sqrtb2ac) / (2 * a);
      if (0 < t1 && t1 < 1) {
        tvalues.push(t1);
      }
      t2 = (-b - sqrtb2ac) / (2 * a);
      if (0 < t2 && t2 < 1) {
        tvalues.push(t2);
      }
    }

    var x, y, j = tvalues.length, jlen = j, mt;
    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      x = (mt * mt * mt * x0) + (3 * mt * mt * t * x1) + (3 * mt * t * t * x2) + (t * t * t * x3);
      bounds[0][j] = x;

      y = (mt * mt * mt * y0) + (3 * mt * mt * t * y1) + (3 * mt * t * t * y2) + (t * t * t * y3);
      bounds[1][j] = y;
    }

    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    var result = [
      {
        x: min.apply(null, bounds[0]),
        y: min.apply(null, bounds[1])
      },
      {
        x: max.apply(null, bounds[0]),
        y: max.apply(null, bounds[1])
      }
    ];
    boundsOfCurveCache[argsString] = result;
    return result;
  }

  fabric.util.getBoundsOfCurve = getBoundsOfCurve;

})();


(function() {

  var slice = Array.prototype.slice;

  /**
   * Invokes method on all items in a given array
   * @memberOf fabric.util.array
   * @param {Array} array Array to iterate over
   * @param {String} method Name of a method to invoke
   * @return {Array}
   */
  function invoke(array, method) {
    var args = slice.call(arguments, 2), result = [];
    for (var i = 0, len = array.length; i < len; i++) {
      result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);
    }
    return result;
  }

  /**
   * Finds maximum value in array (not necessarily "first" one)
   * @memberOf fabric.util.array
   * @param {Array} array Array to iterate over
   * @param {String} byProperty
   * @return {*}
   */
  function max(array, byProperty) {
    return find(array, byProperty, function(value1, value2) {
      return value1 >= value2;
    });
  }

  /**
   * Finds minimum value in array (not necessarily "first" one)
   * @memberOf fabric.util.array
   * @param {Array} array Array to iterate over
   * @param {String} byProperty
   * @return {*}
   */
  function min(array, byProperty) {
    return find(array, byProperty, function(value1, value2) {
      return value1 < value2;
    });
  }

  /**
   * @private
   */
  function fill(array, value) {
    var k = array.length;
    while (k--) {
      array[k] = value;
    }
    return array;
  }

  /**
   * @private
   */
  function find(array, byProperty, condition) {
    if (!array || array.length === 0) {
      return;
    }

    var i = array.length - 1,
        result = byProperty ? array[i][byProperty] : array[i];
    if (byProperty) {
      while (i--) {
        if (condition(array[i][byProperty], result)) {
          result = array[i][byProperty];
        }
      }
    }
    else {
      while (i--) {
        if (condition(array[i], result)) {
          result = array[i];
        }
      }
    }
    return result;
  }

  /**
   * @namespace fabric.util.array
   */
  fabric.util.array = {
    fill: fill,
    invoke: invoke,
    min: min,
    max: max
  };

})();


(function() {
  /**
   * Copies all enumerable properties of one js object to another
   * Does not clone or extend fabric.Object subclasses.
   * @memberOf fabric.util.object
   * @param {Object} destination Where to copy to
   * @param {Object} source Where to copy from
   * @return {Object}
   */

  function extend(destination, source, deep) {
    // JScript DontEnum bug is not taken care of
    // the deep clone is for internal use, is not meant to avoid
    // javascript traps or cloning html element or self referenced objects.
    if (deep) {
      if (!fabric.isLikelyNode && source instanceof Element) {
        // avoid cloning deep images, canvases,
        destination = source;
      }
      else if (source instanceof Array) {
        destination = [];
        for (var i = 0, len = source.length; i < len; i++) {
          destination[i] = extend({ }, source[i], deep);
        }
      }
      else if (source && typeof source === 'object') {
        for (var property in source) {
          if (source.hasOwnProperty(property)) {
            destination[property] = extend({ }, source[property], deep);
          }
        }
      }
      else {
        // this sounds odd for an extend but is ok for recursive use
        destination = source;
      }
    }
    else {
      for (var property in source) {
        destination[property] = source[property];
      }
    }
    return destination;
  }

  /**
   * Creates an empty object and copies all enumerable properties of another object to it
   * @memberOf fabric.util.object
   * TODO: this function return an empty object if you try to clone null
   * @param {Object} object Object to clone
   * @return {Object}
   */
  function clone(object, deep) {
    return extend({ }, object, deep);
  }

  /** @namespace fabric.util.object */
  fabric.util.object = {
    extend: extend,
    clone: clone
  };
  fabric.util.object.extend(fabric.util, fabric.Observable);
})();


(function() {

  /**
   * Camelizes a string
   * @memberOf fabric.util.string
   * @param {String} string String to camelize
   * @return {String} Camelized version of a string
   */
  function camelize(string) {
    return string.replace(/-+(.)?/g, function(match, character) {
      return character ? character.toUpperCase() : '';
    });
  }

  /**
   * Capitalizes a string
   * @memberOf fabric.util.string
   * @param {String} string String to capitalize
   * @param {Boolean} [firstLetterOnly] If true only first letter is capitalized
   * and other letters stay untouched, if false first letter is capitalized
   * and other letters are converted to lowercase.
   * @return {String} Capitalized version of a string
   */
  function capitalize(string, firstLetterOnly) {
    return string.charAt(0).toUpperCase() +
      (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());
  }

  /**
   * Escapes XML in a string
   * @memberOf fabric.util.string
   * @param {String} string String to escape
   * @return {String} Escaped version of a string
   */
  function escapeXml(string) {
    return string.replace(/&/g, '&amp;')
       .replace(/"/g, '&quot;')
       .replace(/'/g, '&apos;')
       .replace(/</g, '&lt;')
       .replace(/>/g, '&gt;');
  }

  /**
   * Divide a string in the user perceived single units
   * @memberOf fabric.util.string
   * @param {String} textstring String to escape
   * @return {Array} array containing the graphemes
   */
  function graphemeSplit(textstring) {
    var i = 0, chr, graphemes = [];
    for (i = 0, chr; i < textstring.length; i++) {
      if ((chr = getWholeChar(textstring, i)) === false) {
        continue;
      }
      graphemes.push(chr);
    }
    return graphemes;
  }

  // taken from mdn in the charAt doc page.
  function getWholeChar(str, i) {
    var code = str.charCodeAt(i);

    if (isNaN(code)) {
      return ''; // Position not found
    }
    if (code < 0xD800 || code > 0xDFFF) {
      return str.charAt(i);
    }

    // High surrogate (could change last hex to 0xDB7F to treat high private
    // surrogates as single characters)
    if (0xD800 <= code && code <= 0xDBFF) {
      if (str.length <= (i + 1)) {
        throw 'High surrogate without following low surrogate';
      }
      var next = str.charCodeAt(i + 1);
      if (0xDC00 > next || next > 0xDFFF) {
        throw 'High surrogate without following low surrogate';
      }
      return str.charAt(i) + str.charAt(i + 1);
    }
    // Low surrogate (0xDC00 <= code && code <= 0xDFFF)
    if (i === 0) {
      throw 'Low surrogate without preceding high surrogate';
    }
    var prev = str.charCodeAt(i - 1);

    // (could change last hex to 0xDB7F to treat high private
    // surrogates as single characters)
    if (0xD800 > prev || prev > 0xDBFF) {
      throw 'Low surrogate without preceding high surrogate';
    }
    // We can pass over low surrogates now as the second component
    // in a pair which we have already processed
    return false;
  }


  /**
   * String utilities
   * @namespace fabric.util.string
   */
  fabric.util.string = {
    camelize: camelize,
    capitalize: capitalize,
    escapeXml: escapeXml,
    graphemeSplit: graphemeSplit
  };
})();


(function() {

  var slice = Array.prototype.slice, emptyFunction = function() { },

      IS_DONTENUM_BUGGY = (function() {
        for (var p in { toString: 1 }) {
          if (p === 'toString') {
            return false;
          }
        }
        return true;
      })(),

      /** @ignore */
      addMethods = function(klass, source, parent) {
        for (var property in source) {

          if (property in klass.prototype &&
              typeof klass.prototype[property] === 'function' &&
              (source[property] + '').indexOf('callSuper') > -1) {

            klass.prototype[property] = (function(property) {
              return function() {

                var superclass = this.constructor.superclass;
                this.constructor.superclass = parent;
                var returnValue = source[property].apply(this, arguments);
                this.constructor.superclass = superclass;

                if (property !== 'initialize') {
                  return returnValue;
                }
              };
            })(property);
          }
          else {
            klass.prototype[property] = source[property];
          }

          if (IS_DONTENUM_BUGGY) {
            if (source.toString !== Object.prototype.toString) {
              klass.prototype.toString = source.toString;
            }
            if (source.valueOf !== Object.prototype.valueOf) {
              klass.prototype.valueOf = source.valueOf;
            }
          }
        }
      };

  function Subclass() { }

  function callSuper(methodName) {
    var parentMethod = null,
        _this = this;

    // climb prototype chain to find method not equal to callee's method
    while (_this.constructor.superclass) {
      var superClassMethod = _this.constructor.superclass.prototype[methodName];
      if (_this[methodName] !== superClassMethod) {
        parentMethod = superClassMethod;
        break;
      }
      // eslint-disable-next-line
      _this = _this.constructor.superclass.prototype;
    }

    if (!parentMethod) {
      return console.log('tried to callSuper ' + methodName + ', method not found in prototype chain', this);
    }

    return (arguments.length > 1)
      ? parentMethod.apply(this, slice.call(arguments, 1))
      : parentMethod.call(this);
  }

  /**
   * Helper for creation of "classes".
   * @memberOf fabric.util
   * @param {Function} [parent] optional "Class" to inherit from
   * @param {Object} [properties] Properties shared by all instances of this class
   *                  (be careful modifying objects defined here as this would affect all instances)
   */
  function createClass() {
    var parent = null,
        properties = slice.call(arguments, 0);

    if (typeof properties[0] === 'function') {
      parent = properties.shift();
    }
    function klass() {
      this.initialize.apply(this, arguments);
    }

    klass.superclass = parent;
    klass.subclasses = [];

    if (parent) {
      Subclass.prototype = parent.prototype;
      klass.prototype = new Subclass();
      parent.subclasses.push(klass);
    }
    for (var i = 0, length = properties.length; i < length; i++) {
      addMethods(klass, properties[i], parent);
    }
    if (!klass.prototype.initialize) {
      klass.prototype.initialize = emptyFunction;
    }
    klass.prototype.constructor = klass;
    klass.prototype.callSuper = callSuper;
    return klass;
  }

  fabric.util.createClass = createClass;
})();


(function () {

  var unknown = 'unknown';

  /* EVENT HANDLING */

  function areHostMethods(object) {
    var methodNames = Array.prototype.slice.call(arguments, 1),
        t, i, len = methodNames.length;
    for (i = 0; i < len; i++) {
      t = typeof object[methodNames[i]];
      if (!(/^(?:function|object|unknown)$/).test(t)) {
        return false;
      }
    }
    return true;
  }

  /** @ignore */
  var getElement,
      setElement,
      getUniqueId = (function () {
        var uid = 0;
        return function (element) {
          return element.__uniqueID || (element.__uniqueID = 'uniqueID__' + uid++);
        };
      })();

  (function () {
    var elements = { };
    /** @ignore */
    getElement = function (uid) {
      return elements[uid];
    };
    /** @ignore */
    setElement = function (uid, element) {
      elements[uid] = element;
    };
  })();

  function createListener(uid, handler) {
    return {
      handler: handler,
      wrappedHandler: createWrappedHandler(uid, handler)
    };
  }

  function createWrappedHandler(uid, handler) {
    return function (e) {
      handler.call(getElement(uid), e || fabric.window.event);
    };
  }

  function createDispatcher(uid, eventName) {
    return function (e) {
      if (handlers[uid] && handlers[uid][eventName]) {
        var handlersForEvent = handlers[uid][eventName];
        for (var i = 0, len = handlersForEvent.length; i < len; i++) {
          handlersForEvent[i].call(this, e || fabric.window.event);
        }
      }
    };
  }

  var shouldUseAddListenerRemoveListener = (
        areHostMethods(fabric.document.documentElement, 'addEventListener', 'removeEventListener') &&
        areHostMethods(fabric.window, 'addEventListener', 'removeEventListener')),

      shouldUseAttachEventDetachEvent = (
        areHostMethods(fabric.document.documentElement, 'attachEvent', 'detachEvent') &&
        areHostMethods(fabric.window, 'attachEvent', 'detachEvent')),

      // IE branch
      listeners = { },

      // DOM L0 branch
      handlers = { },

      addListener, removeListener;

  if (shouldUseAddListenerRemoveListener) {
    /** @ignore */
    addListener = function (element, eventName, handler, options) {
      // since ie10 or ie9 can use addEventListener but they do not support options, i need to check
      element && element.addEventListener(eventName, handler, shouldUseAttachEventDetachEvent ? false : options);
    };
    /** @ignore */
    removeListener = function (element, eventName, handler, options) {
      element && element.removeEventListener(eventName, handler, shouldUseAttachEventDetachEvent ? false : options);
    };
  }

  else if (shouldUseAttachEventDetachEvent) {
    /** @ignore */
    addListener = function (element, eventName, handler) {
      if (!element) {
        return;
      }
      var uid = getUniqueId(element);
      setElement(uid, element);
      if (!listeners[uid]) {
        listeners[uid] = { };
      }
      if (!listeners[uid][eventName]) {
        listeners[uid][eventName] = [];

      }
      var listener = createListener(uid, handler);
      listeners[uid][eventName].push(listener);
      element.attachEvent('on' + eventName, listener.wrappedHandler);
    };
    /** @ignore */
    removeListener = function (element, eventName, handler) {
      if (!element) {
        return;
      }
      var uid = getUniqueId(element), listener;
      if (listeners[uid] && listeners[uid][eventName]) {
        for (var i = 0, len = listeners[uid][eventName].length; i < len; i++) {
          listener = listeners[uid][eventName][i];
          if (listener && listener.handler === handler) {
            element.detachEvent('on' + eventName, listener.wrappedHandler);
            listeners[uid][eventName][i] = null;
          }
        }
      }
    };
  }
  else {
    /** @ignore */
    addListener = function (element, eventName, handler) {
      if (!element) {
        return;
      }
      var uid = getUniqueId(element);
      if (!handlers[uid]) {
        handlers[uid] = { };
      }
      if (!handlers[uid][eventName]) {
        handlers[uid][eventName] = [];
        var existingHandler = element['on' + eventName];
        if (existingHandler) {
          handlers[uid][eventName].push(existingHandler);
        }
        element['on' + eventName] = createDispatcher(uid, eventName);
      }
      handlers[uid][eventName].push(handler);
    };
    /** @ignore */
    removeListener = function (element, eventName, handler) {
      if (!element) {
        return;
      }
      var uid = getUniqueId(element);
      if (handlers[uid] && handlers[uid][eventName]) {
        var handlersForEvent = handlers[uid][eventName];
        for (var i = 0, len = handlersForEvent.length; i < len; i++) {
          if (handlersForEvent[i] === handler) {
            handlersForEvent.splice(i, 1);
          }
        }
      }
    };
  }

  /**
   * Adds an event listener to an element
   * @function
   * @memberOf fabric.util
   * @param {HTMLElement} element
   * @param {String} eventName
   * @param {Function} handler
   */
  fabric.util.addListener = addListener;

  /**
   * Removes an event listener from an element
   * @function
   * @memberOf fabric.util
   * @param {HTMLElement} element
   * @param {String} eventName
   * @param {Function} handler
   */
  fabric.util.removeListener = removeListener;

  /**
   * Cross-browser wrapper for getting event's coordinates
   * @memberOf fabric.util
   * @param {Event} event Event object
   */
  function getPointer(event) {
    event || (event = fabric.window.event);

    var element = event.target ||
                  (typeof event.srcElement !== unknown ? event.srcElement : null),

        scroll = fabric.util.getScrollLeftTop(element);

    return {
      x: pointerX(event) + scroll.left,
      y: pointerY(event) + scroll.top
    };
  }

  var pointerX = function(event) {
        return event.clientX;
      },

      pointerY = function(event) {
        return event.clientY;
      };

  function _getPointer(event, pageProp, clientProp) {
    var touchProp = event.type === 'touchend' ? 'changedTouches' : 'touches';

    return (event[touchProp] && event[touchProp][0]
      ? (event[touchProp][0][pageProp] - (event[touchProp][0][pageProp] - event[touchProp][0][clientProp]))
        || event[clientProp]
      : event[clientProp]);
  }

  if (fabric.isTouchSupported) {
    pointerX = function(event) {
      return _getPointer(event, 'pageX', 'clientX');
    };
    pointerY = function(event) {
      return _getPointer(event, 'pageY', 'clientY');
    };
  }

  fabric.util.getPointer = getPointer;

})();


(function () {

  /**
   * Cross-browser wrapper for setting element's style
   * @memberOf fabric.util
   * @param {HTMLElement} element
   * @param {Object} styles
   * @return {HTMLElement} Element that was passed as a first argument
   */
  function setStyle(element, styles) {
    var elementStyle = element.style;
    if (!elementStyle) {
      return element;
    }
    if (typeof styles === 'string') {
      element.style.cssText += ';' + styles;
      return styles.indexOf('opacity') > -1
        ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1])
        : element;
    }
    for (var property in styles) {
      if (property === 'opacity') {
        setOpacity(element, styles[property]);
      }
      else {
        var normalizedProperty = (property === 'float' || property === 'cssFloat')
          ? (typeof elementStyle.styleFloat === 'undefined' ? 'cssFloat' : 'styleFloat')
          : property;
        elementStyle[normalizedProperty] = styles[property];
      }
    }
    return element;
  }

  var parseEl = fabric.document.createElement('div'),
      supportsOpacity = typeof parseEl.style.opacity === 'string',
      supportsFilters = typeof parseEl.style.filter === 'string',
      reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/,

      /** @ignore */
      setOpacity = function (element) { return element; };

  if (supportsOpacity) {
    /** @ignore */
    setOpacity = function(element, value) {
      element.style.opacity = value;
      return element;
    };
  }
  else if (supportsFilters) {
    /** @ignore */
    setOpacity = function(element, value) {
      var es = element.style;
      if (element.currentStyle && !element.currentStyle.hasLayout) {
        es.zoom = 1;
      }
      if (reOpacity.test(es.filter)) {
        value = value >= 0.9999 ? '' : ('alpha(opacity=' + (value * 100) + ')');
        es.filter = es.filter.replace(reOpacity, value);
      }
      else {
        es.filter += ' alpha(opacity=' + (value * 100) + ')';
      }
      return element;
    };
  }

  fabric.util.setStyle = setStyle;

})();


(function() {

  var _slice = Array.prototype.slice;

  /**
   * Takes id and returns an element with that id (if one exists in a document)
   * @memberOf fabric.util
   * @param {String|HTMLElement} id
   * @return {HTMLElement|null}
   */
  function getById(id) {
    return typeof id === 'string' ? fabric.document.getElementById(id) : id;
  }

  var sliceCanConvertNodelists,
      /**
       * Converts an array-like object (e.g. arguments or NodeList) to an array
       * @memberOf fabric.util
       * @param {Object} arrayLike
       * @return {Array}
       */
      toArray = function(arrayLike) {
        return _slice.call(arrayLike, 0);
      };

  try {
    sliceCanConvertNodelists = toArray(fabric.document.childNodes) instanceof Array;
  }
  catch (err) { }

  if (!sliceCanConvertNodelists) {
    toArray = function(arrayLike) {
      var arr = new Array(arrayLike.length), i = arrayLike.length;
      while (i--) {
        arr[i] = arrayLike[i];
      }
      return arr;
    };
  }

  /**
   * Creates specified element with specified attributes
   * @memberOf fabric.util
   * @param {String} tagName Type of an element to create
   * @param {Object} [attributes] Attributes to set on an element
   * @return {HTMLElement} Newly created element
   */
  function makeElement(tagName, attributes) {
    var el = fabric.document.createElement(tagName);
    for (var prop in attributes) {
      if (prop === 'class') {
        el.className = attributes[prop];
      }
      else if (prop === 'for') {
        el.htmlFor = attributes[prop];
      }
      else {
        el.setAttribute(prop, attributes[prop]);
      }
    }
    return el;
  }

  /**
   * Adds class to an element
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to add class to
   * @param {String} className Class to add to an element
   */
  function addClass(element, className) {
    if (element && (' ' + element.className + ' ').indexOf(' ' + className + ' ') === -1) {
      element.className += (element.className ? ' ' : '') + className;
    }
  }

  /**
   * Wraps element with another element
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to wrap
   * @param {HTMLElement|String} wrapper Element to wrap with
   * @param {Object} [attributes] Attributes to set on a wrapper
   * @return {HTMLElement} wrapper
   */
  function wrapElement(element, wrapper, attributes) {
    if (typeof wrapper === 'string') {
      wrapper = makeElement(wrapper, attributes);
    }
    if (element.parentNode) {
      element.parentNode.replaceChild(wrapper, element);
    }
    wrapper.appendChild(element);
    return wrapper;
  }

  /**
   * Returns element scroll offsets
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to operate on
   * @return {Object} Object with left/top values
   */
  function getScrollLeftTop(element) {

    var left = 0,
        top = 0,
        docElement = fabric.document.documentElement,
        body = fabric.document.body || {
          scrollLeft: 0, scrollTop: 0
        };

    // While loop checks (and then sets element to) .parentNode OR .host
    //  to account for ShadowDOM. We still want to traverse up out of ShadowDOM,
    //  but the .parentNode of a root ShadowDOM node will always be null, instead
    //  it should be accessed through .host. See http://stackoverflow.com/a/24765528/4383938
    while (element && (element.parentNode || element.host)) {

      // Set element to element parent, or 'host' in case of ShadowDOM
      element = element.parentNode || element.host;

      if (element === fabric.document) {
        left = body.scrollLeft || docElement.scrollLeft || 0;
        top = body.scrollTop ||  docElement.scrollTop || 0;
      }
      else {
        left += element.scrollLeft || 0;
        top += element.scrollTop || 0;
      }

      if (element.nodeType === 1 &&
          fabric.util.getElementStyle(element, 'position') === 'fixed') {
        break;
      }
    }

    return { left: left, top: top };
  }

  /**
   * Returns offset for a given element
   * @function
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to get offset for
   * @return {Object} Object with "left" and "top" properties
   */
  function getElementOffset(element) {
    var docElem,
        doc = element && element.ownerDocument,
        box = { left: 0, top: 0 },
        offset = { left: 0, top: 0 },
        scrollLeftTop,
        offsetAttributes = {
          borderLeftWidth: 'left',
          borderTopWidth:  'top',
          paddingLeft:     'left',
          paddingTop:      'top'
        };

    if (!doc) {
      return offset;
    }

    for (var attr in offsetAttributes) {
      offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;
    }

    docElem = doc.documentElement;
    if ( typeof element.getBoundingClientRect !== 'undefined' ) {
      box = element.getBoundingClientRect();
    }

    scrollLeftTop = getScrollLeftTop(element);

    return {
      left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,
      top: box.top + scrollLeftTop.top - (docElem.clientTop || 0)  + offset.top
    };
  }

  /**
   * Returns style attribute value of a given element
   * @memberOf fabric.util
   * @param {HTMLElement} element Element to get style attribute for
   * @param {String} attr Style attribute to get for element
   * @return {String} Style attribute value of the given element.
   */
  var getElementStyle;
  if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {
    getElementStyle = function(element, attr) {
      var style = fabric.document.defaultView.getComputedStyle(element, null);
      return style ? style[attr] : undefined;
    };
  }
  else {
    getElementStyle = function(element, attr) {
      var value = element.style[attr];
      if (!value && element.currentStyle) {
        value = element.currentStyle[attr];
      }
      return value;
    };
  }

  (function () {
    var style = fabric.document.documentElement.style,
        selectProp = 'userSelect' in style
          ? 'userSelect'
          : 'MozUserSelect' in style
            ? 'MozUserSelect'
            : 'WebkitUserSelect' in style
              ? 'WebkitUserSelect'
              : 'KhtmlUserSelect' in style
                ? 'KhtmlUserSelect'
                : '';

    /**
     * Makes element unselectable
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to make unselectable
     * @return {HTMLElement} Element that was passed in
     */
    function makeElementUnselectable(element) {
      if (typeof element.onselectstart !== 'undefined') {
        element.onselectstart = fabric.util.falseFunction;
      }
      if (selectProp) {
        element.style[selectProp] = 'none';
      }
      else if (typeof element.unselectable === 'string') {
        element.unselectable = 'on';
      }
      return element;
    }

    /**
     * Makes element selectable
     * @memberOf fabric.util
     * @param {HTMLElement} element Element to make selectable
     * @return {HTMLElement} Element that was passed in
     */
    function makeElementSelectable(element) {
      if (typeof element.onselectstart !== 'undefined') {
        element.onselectstart = null;
      }
      if (selectProp) {
        element.style[selectProp] = '';
      }
      else if (typeof element.unselectable === 'string') {
        element.unselectable = '';
      }
      return element;
    }

    fabric.util.makeElementUnselectable = makeElementUnselectable;
    fabric.util.makeElementSelectable = makeElementSelectable;
  })();

  (function() {

    /**
     * Inserts a script element with a given url into a document; invokes callback, when that script is finished loading
     * @memberOf fabric.util
     * @param {String} url URL of a script to load
     * @param {Function} callback Callback to execute when script is finished loading
     */
    function getScript(url, callback) {
      var headEl = fabric.document.getElementsByTagName('head')[0],
          scriptEl = fabric.document.createElement('script'),
          loading = true;

      /** @ignore */
      scriptEl.onload = /** @ignore */ scriptEl.onreadystatechange = function(e) {
        if (loading) {
          if (typeof this.readyState === 'string' &&
              this.readyState !== 'loaded' &&
              this.readyState !== 'complete') {
            return;
          }
          loading = false;
          callback(e || fabric.window.event);
          scriptEl = scriptEl.onload = scriptEl.onreadystatechange = null;
        }
      };
      scriptEl.src = url;
      headEl.appendChild(scriptEl);
      // causes issue in Opera
      // headEl.removeChild(scriptEl);
    }

    fabric.util.getScript = getScript;
  })();

  fabric.util.getById = getById;
  fabric.util.toArray = toArray;
  fabric.util.makeElement = makeElement;
  fabric.util.addClass = addClass;
  fabric.util.wrapElement = wrapElement;
  fabric.util.getScrollLeftTop = getScrollLeftTop;
  fabric.util.getElementOffset = getElementOffset;
  fabric.util.getElementStyle = getElementStyle;

})();


(function() {

  function addParamToUrl(url, param) {
    return url + (/\?/.test(url) ? '&' : '?') + param;
  }

  var makeXHR = (function() {
    var factories = [
      function() { return new ActiveXObject('Microsoft.XMLHTTP'); },
      function() { return new ActiveXObject('Msxml2.XMLHTTP'); },
      function() { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); },
      function() { return new XMLHttpRequest(); }
    ];
    for (var i = factories.length; i--; ) {
      try {
        var req = factories[i]();
        if (req) {
          return factories[i];
        }
      }
      catch (err) { }
    }
  })();

  function emptyFn() { }

  /**
   * Cross-browser abstraction for sending XMLHttpRequest
   * @memberOf fabric.util
   * @param {String} url URL to send XMLHttpRequest to
   * @param {Object} [options] Options object
   * @param {String} [options.method="GET"]
   * @param {String} [options.parameters] parameters to append to url in GET or in body
   * @param {String} [options.body] body to send with POST or PUT request
   * @param {Function} options.onComplete Callback to invoke when request is completed
   * @return {XMLHttpRequest} request
   */
  function request(url, options) {

    options || (options = { });

    var method = options.method ? options.method.toUpperCase() : 'GET',
        onComplete = options.onComplete || function() { },
        xhr = makeXHR(),
        body = options.body || options.parameters;

    /** @ignore */
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        onComplete(xhr);
        xhr.onreadystatechange = emptyFn;
      }
    };

    if (method === 'GET') {
      body = null;
      if (typeof options.parameters === 'string') {
        url = addParamToUrl(url, options.parameters);
      }
    }

    xhr.open(method, url, true);

    if (method === 'POST' || method === 'PUT') {
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    }

    xhr.send(body);
    return xhr;
  }

  fabric.util.request = request;
})();


/**
 * Wrapper around `console.log` (when available)
 * @param {*} [values] Values to log
 */
fabric.log = function() { };

/**
 * Wrapper around `console.warn` (when available)
 * @param {*} [values] Values to log as a warning
 */
fabric.warn = function() { };

/* eslint-disable */
if (typeof console !== 'undefined') {

  ['log', 'warn'].forEach(function(methodName) {

    if (typeof console[methodName] !== 'undefined' &&
        typeof console[methodName].apply === 'function') {

      fabric[methodName] = function() {
        return console[methodName].apply(console, arguments);
      };
    }
  });
}
/* eslint-enable */


(function() {

  function noop() {
    return false;
  }

  /**
   * Changes value from one to another within certain period of time, invoking callbacks as value is being changed.
   * @memberOf fabric.util
   * @param {Object} [options] Animation options
   * @param {Function} [options.onChange] Callback; invoked on every value change
   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
   * @param {Number} [options.startValue=0] Starting value
   * @param {Number} [options.endValue=100] Ending value
   * @param {Number} [options.byValue=100] Value to modify the property by
   * @param {Function} [options.easing] Easing function
   * @param {Number} [options.duration=500] Duration of change (in ms)
   */
  function animate(options) {

    requestAnimFrame(function(timestamp) {
      options || (options = { });

      var start = timestamp || +new Date(),
          duration = options.duration || 500,
          finish = start + duration, time,
          onChange = options.onChange || noop,
          abort = options.abort || noop,
          onComplete = options.onComplete || noop,
          easing = options.easing || function(t, b, c, d) {return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;},
          startValue = 'startValue' in options ? options.startValue : 0,
          endValue = 'endValue' in options ? options.endValue : 100,
          byValue = options.byValue || endValue - startValue;

      options.onStart && options.onStart();

      (function tick(ticktime) {
        if (abort()) {
          onComplete(endValue, 1, 1);
          return;
        }
        time = ticktime || +new Date();
        var currentTime = time > finish ? duration : (time - start),
            timePerc = currentTime / duration,
            current = easing(currentTime, startValue, byValue, duration),
            valuePerc = Math.abs((current - startValue) / byValue);
        onChange(current, valuePerc, timePerc);
        if (time > finish) {
          options.onComplete && options.onComplete();
          return;
        }
        requestAnimFrame(tick);
      })(start);
    });

  }

  var _requestAnimFrame = fabric.window.requestAnimationFrame       ||
                          fabric.window.webkitRequestAnimationFrame ||
                          fabric.window.mozRequestAnimationFrame    ||
                          fabric.window.oRequestAnimationFrame      ||
                          fabric.window.msRequestAnimationFrame     ||
                          function(callback) {
                            return fabric.window.setTimeout(callback, 1000 / 60);
                          };

  var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;

  /**
   * requestAnimationFrame polyfill based on http://paulirish.com/2011/requestanimationframe-for-smart-animating/
   * In order to get a precise start time, `requestAnimFrame` should be called as an entry into the method
   * @memberOf fabric.util
   * @param {Function} callback Callback to invoke
   * @param {DOMElement} element optional Element to associate with animation
   */
  function requestAnimFrame() {
    return _requestAnimFrame.apply(fabric.window, arguments);
  }

  function cancelAnimFrame() {
    return _cancelAnimFrame.apply(fabric.window, arguments);
  }

  fabric.util.animate = animate;
  fabric.util.requestAnimFrame = requestAnimFrame;
  fabric.util.cancelAnimFrame = cancelAnimFrame;
})();


(function() {
  // Calculate an in-between color. Returns a "rgba()" string.
  // Credit: Edwin Martin <edwin@bitstorm.org>
  //         http://www.bitstorm.org/jquery/color-animation/jquery.animate-colors.js
  function calculateColor(begin, end, pos) {
    var color = 'rgba('
        + parseInt((begin[0] + pos * (end[0] - begin[0])), 10) + ','
        + parseInt((begin[1] + pos * (end[1] - begin[1])), 10) + ','
        + parseInt((begin[2] + pos * (end[2] - begin[2])), 10);

    color += ',' + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);
    color += ')';
    return color;
  }

  /**
   * Changes the color from one to another within certain period of time, invoking callbacks as value is being changed.
   * @memberOf fabric.util
   * @param {String} fromColor The starting color in hex or rgb(a) format.
   * @param {String} toColor The starting color in hex or rgb(a) format.
   * @param {Number} [duration] Duration of change (in ms).
   * @param {Object} [options] Animation options
   * @param {Function} [options.onChange] Callback; invoked on every value change
   * @param {Function} [options.onComplete] Callback; invoked when value change is completed
   * @param {Function} [options.colorEasing] Easing function. Note that this function only take two arguments (currentTime, duration). Thus the regular animation easing functions cannot be used.
   */
  function animateColor(fromColor, toColor, duration, options) {
    var startColor = new fabric.Color(fromColor).getSource(),
        endColor = new fabric.Color(toColor).getSource();

    options = options || {};

    fabric.util.animate(fabric.util.object.extend(options, {
      duration: duration || 500,
      startValue: startColor,
      endValue: endColor,
      byValue: endColor,
      easing: function (currentTime, startValue, byValue, duration) {
        var posValue = options.colorEasing
              ? options.colorEasing(currentTime, duration)
              : 1 - Math.cos(currentTime / duration * (Math.PI / 2));
        return calculateColor(startValue, byValue, posValue);
      }
    }));
  }

  fabric.util.animateColor = animateColor;

})();


(function() {

  function normalize(a, c, p, s) {
    if (a < Math.abs(c)) {
      a = c;
      s = p / 4;
    }
    else {
      //handle the 0/0 case:
      if (c === 0 && a === 0) {
        s = p / (2 * Math.PI) * Math.asin(1);
      }
      else {
        s = p / (2 * Math.PI) * Math.asin(c / a);
      }
    }
    return { a: a, c: c, p: p, s: s };
  }

  function elastic(opts, t, d) {
    return opts.a *
      Math.pow(2, 10 * (t -= 1)) *
      Math.sin( (t * d - opts.s) * (2 * Math.PI) / opts.p );
  }

  /**
   * Cubic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutCubic(t, b, c, d) {
    return c * ((t = t / d - 1) * t * t + 1) + b;
  }

  /**
   * Cubic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutCubic(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return c / 2 * t * t * t + b;
    }
    return c / 2 * ((t -= 2) * t * t + 2) + b;
  }

  /**
   * Quartic easing in
   * @memberOf fabric.util.ease
   */
  function easeInQuart(t, b, c, d) {
    return c * (t /= d) * t * t * t + b;
  }

  /**
   * Quartic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutQuart(t, b, c, d) {
    return -c * ((t = t / d - 1) * t * t * t - 1) + b;
  }

  /**
   * Quartic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutQuart(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return c / 2 * t * t * t * t + b;
    }
    return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
  }

  /**
   * Quintic easing in
   * @memberOf fabric.util.ease
   */
  function easeInQuint(t, b, c, d) {
    return c * (t /= d) * t * t * t * t + b;
  }

  /**
   * Quintic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutQuint(t, b, c, d) {
    return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
  }

  /**
   * Quintic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutQuint(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return c / 2 * t * t * t * t * t + b;
    }
    return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
  }

  /**
   * Sinusoidal easing in
   * @memberOf fabric.util.ease
   */
  function easeInSine(t, b, c, d) {
    return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
  }

  /**
   * Sinusoidal easing out
   * @memberOf fabric.util.ease
   */
  function easeOutSine(t, b, c, d) {
    return c * Math.sin(t / d * (Math.PI / 2)) + b;
  }

  /**
   * Sinusoidal easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutSine(t, b, c, d) {
    return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
  }

  /**
   * Exponential easing in
   * @memberOf fabric.util.ease
   */
  function easeInExpo(t, b, c, d) {
    return (t === 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
  }

  /**
   * Exponential easing out
   * @memberOf fabric.util.ease
   */
  function easeOutExpo(t, b, c, d) {
    return (t === d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
  }

  /**
   * Exponential easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutExpo(t, b, c, d) {
    if (t === 0) {
      return b;
    }
    if (t === d) {
      return b + c;
    }
    t /= d / 2;
    if (t < 1) {
      return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
    }
    return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
  }

  /**
   * Circular easing in
   * @memberOf fabric.util.ease
   */
  function easeInCirc(t, b, c, d) {
    return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
  }

  /**
   * Circular easing out
   * @memberOf fabric.util.ease
   */
  function easeOutCirc(t, b, c, d) {
    return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
  }

  /**
   * Circular easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutCirc(t, b, c, d) {
    t /= d / 2;
    if (t < 1) {
      return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
    }
    return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
  }

  /**
   * Elastic easing in
   * @memberOf fabric.util.ease
   */
  function easeInElastic(t, b, c, d) {
    var s = 1.70158, p = 0, a = c;
    if (t === 0) {
      return b;
    }
    t /= d;
    if (t === 1) {
      return b + c;
    }
    if (!p) {
      p = d * 0.3;
    }
    var opts = normalize(a, c, p, s);
    return -elastic(opts, t, d) + b;
  }

  /**
   * Elastic easing out
   * @memberOf fabric.util.ease
   */
  function easeOutElastic(t, b, c, d) {
    var s = 1.70158, p = 0, a = c;
    if (t === 0) {
      return b;
    }
    t /= d;
    if (t === 1) {
      return b + c;
    }
    if (!p) {
      p = d * 0.3;
    }
    var opts = normalize(a, c, p, s);
    return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) + opts.c + b;
  }

  /**
   * Elastic easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutElastic(t, b, c, d) {
    var s = 1.70158, p = 0, a = c;
    if (t === 0) {
      return b;
    }
    t /= d / 2;
    if (t === 2) {
      return b + c;
    }
    if (!p) {
      p = d * (0.3 * 1.5);
    }
    var opts = normalize(a, c, p, s);
    if (t < 1) {
      return -0.5 * elastic(opts, t, d) + b;
    }
    return opts.a * Math.pow(2, -10 * (t -= 1)) *
      Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p ) * 0.5 + opts.c + b;
  }

  /**
   * Backwards easing in
   * @memberOf fabric.util.ease
   */
  function easeInBack(t, b, c, d, s) {
    if (s === undefined) {
      s = 1.70158;
    }
    return c * (t /= d) * t * ((s + 1) * t - s) + b;
  }

  /**
   * Backwards easing out
   * @memberOf fabric.util.ease
   */
  function easeOutBack(t, b, c, d, s) {
    if (s === undefined) {
      s = 1.70158;
    }
    return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
  }

  /**
   * Backwards easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutBack(t, b, c, d, s) {
    if (s === undefined) {
      s = 1.70158;
    }
    t /= d / 2;
    if (t < 1) {
      return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
    }
    return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
  }

  /**
   * Bouncing easing in
   * @memberOf fabric.util.ease
   */
  function easeInBounce(t, b, c, d) {
    return c - easeOutBounce (d - t, 0, c, d) + b;
  }

  /**
   * Bouncing easing out
   * @memberOf fabric.util.ease
   */
  function easeOutBounce(t, b, c, d) {
    if ((t /= d) < (1 / 2.75)) {
      return c * (7.5625 * t * t) + b;
    }
    else if (t < (2 / 2.75)) {
      return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
    }
    else if (t < (2.5 / 2.75)) {
      return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
    }
    else {
      return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
    }
  }

  /**
   * Bouncing easing in and out
   * @memberOf fabric.util.ease
   */
  function easeInOutBounce(t, b, c, d) {
    if (t < d / 2) {
      return easeInBounce (t * 2, 0, c, d) * 0.5 + b;
    }
    return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
  }

  /**
   * Easing functions
   * See <a href="http://gizma.com/easing/">Easing Equations by Robert Penner</a>
   * @namespace fabric.util.ease
   */
  fabric.util.ease = {

    /**
     * Quadratic easing in
     * @memberOf fabric.util.ease
     */
    easeInQuad: function(t, b, c, d) {
      return c * (t /= d) * t + b;
    },

    /**
     * Quadratic easing out
     * @memberOf fabric.util.ease
     */
    easeOutQuad: function(t, b, c, d) {
      return -c * (t /= d) * (t - 2) + b;
    },

    /**
     * Quadratic easing in and out
     * @memberOf fabric.util.ease
     */
    easeInOutQuad: function(t, b, c, d) {
      t /= (d / 2);
      if (t < 1) {
        return c / 2 * t * t + b;
      }
      return -c / 2 * ((--t) * (t - 2) - 1) + b;
    },

    /**
     * Cubic easing in
     * @memberOf fabric.util.ease
     */
    easeInCubic: function(t, b, c, d) {
      return c * (t /= d) * t * t + b;
    },

    easeOutCubic: easeOutCubic,
    easeInOutCubic: easeInOutCubic,
    easeInQuart: easeInQuart,
    easeOutQuart: easeOutQuart,
    easeInOutQuart: easeInOutQuart,
    easeInQuint: easeInQuint,
    easeOutQuint: easeOutQuint,
    easeInOutQuint: easeInOutQuint,
    easeInSine: easeInSine,
    easeOutSine: easeOutSine,
    easeInOutSine: easeInOutSine,
    easeInExpo: easeInExpo,
    easeOutExpo: easeOutExpo,
    easeInOutExpo: easeInOutExpo,
    easeInCirc: easeInCirc,
    easeOutCirc: easeOutCirc,
    easeInOutCirc: easeInOutCirc,
    easeInElastic: easeInElastic,
    easeOutElastic: easeOutElastic,
    easeInOutElastic: easeInOutElastic,
    easeInBack: easeInBack,
    easeOutBack: easeOutBack,
    easeInOutBack: easeInOutBack,
    easeInBounce: easeInBounce,
    easeOutBounce: easeOutBounce,
    easeInOutBounce: easeInOutBounce
  };

})();


(function(global) {

  'use strict';

  /**
   * @name fabric
   * @namespace
   */

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      clone = fabric.util.object.clone,
      toFixed = fabric.util.toFixed,
      parseUnit = fabric.util.parseUnit,
      multiplyTransformMatrices = fabric.util.multiplyTransformMatrices,

      reAllowedSVGTagNames = /^(path|circle|polygon|polyline|ellipse|rect|line|image|text)$/i,
      reViewBoxTagNames = /^(symbol|image|marker|pattern|view|svg)$/i,
      reNotAllowedAncestors = /^(?:pattern|defs|symbol|metadata|clipPath|mask)$/i,
      reAllowedParents = /^(symbol|g|a|svg)$/i,

      attributesMap = {
        cx:                   'left',
        x:                    'left',
        r:                    'radius',
        cy:                   'top',
        y:                    'top',
        display:              'visible',
        visibility:           'visible',
        transform:            'transformMatrix',
        'fill-opacity':       'fillOpacity',
        'fill-rule':          'fillRule',
        'font-family':        'fontFamily',
        'font-size':          'fontSize',
        'font-style':         'fontStyle',
        'font-weight':        'fontWeight',
        'stroke-dasharray':   'strokeDashArray',
        'stroke-linecap':     'strokeLineCap',
        'stroke-linejoin':    'strokeLineJoin',
        'stroke-miterlimit':  'strokeMiterLimit',
        'stroke-opacity':     'strokeOpacity',
        'stroke-width':       'strokeWidth',
        'text-decoration':    'textDecoration',
        'text-anchor':        'textAnchor',
        opacity:              'opacity'
      },

      colorAttributes = {
        stroke: 'strokeOpacity',
        fill:   'fillOpacity'
      };

  fabric.cssRules = { };
  fabric.gradientDefs = { };

  function normalizeAttr(attr) {
    // transform attribute names
    if (attr in attributesMap) {
      return attributesMap[attr];
    }
    return attr;
  }

  function normalizeValue(attr, value, parentAttributes, fontSize) {
    var isArray = Object.prototype.toString.call(value) === '[object Array]',
        parsed;

    if ((attr === 'fill' || attr === 'stroke') && value === 'none') {
      value = '';
    }
    else if (attr === 'strokeDashArray') {
      if (value === 'none') {
        value = null;
      }
      else {
        value = value.replace(/,/g, ' ').split(/\s+/).map(function(n) {
          return parseFloat(n);
        });
      }
    }
    else if (attr === 'transformMatrix') {
      if (parentAttributes && parentAttributes.transformMatrix) {
        value = multiplyTransformMatrices(
          parentAttributes.transformMatrix, fabric.parseTransformAttribute(value));
      }
      else {
        value = fabric.parseTransformAttribute(value);
      }
    }
    else if (attr === 'visible') {
      value = value !== 'none' && value !== 'hidden';
      // display=none on parent element always takes precedence over child element
      if (parentAttributes && parentAttributes.visible === false) {
        value = false;
      }
    }
    else if (attr === 'opacity') {
      value = parseFloat(value);
      if (parentAttributes && typeof parentAttributes.opacity !== 'undefined') {
        value *= parentAttributes.opacity;
      }
    }
    else if (attr === 'textAnchor' /* text-anchor */) {
      value = value === 'start' ? 'left' : value === 'end' ? 'right' : 'center';
    }
    else {
      parsed = isArray ? value.map(parseUnit) : parseUnit(value, fontSize);
    }

    return (!isArray && isNaN(parsed) ? value : parsed);
  }

  /**
   * @private
   * @param {Object} attributes Array of attributes to parse
   */
  function _setStrokeFillOpacity(attributes) {
    for (var attr in colorAttributes) {

      if (typeof attributes[colorAttributes[attr]] === 'undefined' || attributes[attr] === '') {
        continue;
      }

      if (typeof attributes[attr] === 'undefined') {
        if (!fabric.Object.prototype[attr]) {
          continue;
        }
        attributes[attr] = fabric.Object.prototype[attr];
      }

      if (attributes[attr].indexOf('url(') === 0) {
        continue;
      }

      var color = new fabric.Color(attributes[attr]);
      attributes[attr] = color.setAlpha(toFixed(color.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();
    }
    return attributes;
  }

  /**
   * @private
   */
  function _getMultipleNodes(doc, nodeNames) {
    var nodeName, nodeArray = [], nodeList, i, len;
    for (i = 0, len = nodeNames.length; i < len; i++) {
      nodeName = nodeNames[i];
      nodeList = doc.getElementsByTagName(nodeName);
      nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));
    }
    return nodeArray;
  }

  /**
   * Parses "transform" attribute, returning an array of values
   * @static
   * @function
   * @memberOf fabric
   * @param {String} attributeValue String containing attribute value
   * @return {Array} Array of 6 elements representing transformation matrix
   */
  fabric.parseTransformAttribute = (function() {
    function rotateMatrix(matrix, args) {
      var cos = Math.cos(args[0]), sin = Math.sin(args[0]),
          x = 0, y = 0;
      if (args.length === 3) {
        x = args[1];
        y = args[2];
      }

      matrix[0] = cos;
      matrix[1] = sin;
      matrix[2] = -sin;
      matrix[3] = cos;
      matrix[4] = x - (cos * x - sin * y);
      matrix[5] = y - (sin * x + cos * y);
    }

    function scaleMatrix(matrix, args) {
      var multiplierX = args[0],
          multiplierY = (args.length === 2) ? args[1] : args[0];

      matrix[0] = multiplierX;
      matrix[3] = multiplierY;
    }

    function skewMatrix(matrix, args, pos) {
      matrix[pos] = Math.tan(fabric.util.degreesToRadians(args[0]));
    }

    function translateMatrix(matrix, args) {
      matrix[4] = args[0];
      if (args.length === 2) {
        matrix[5] = args[1];
      }
    }

    // identity matrix
    var iMatrix = [
          1, // a
          0, // b
          0, // c
          1, // d
          0, // e
          0  // f
        ],

        // == begin transform regexp
        number = fabric.reNum,

        commaWsp = '(?:\\s+,?\\s*|,\\s*)',

        skewX = '(?:(skewX)\\s*\\(\\s*(' + number + ')\\s*\\))',

        skewY = '(?:(skewY)\\s*\\(\\s*(' + number + ')\\s*\\))',

        rotate = '(?:(rotate)\\s*\\(\\s*(' + number + ')(?:' +
                    commaWsp + '(' + number + ')' +
                    commaWsp + '(' + number + '))?\\s*\\))',

        scale = '(?:(scale)\\s*\\(\\s*(' + number + ')(?:' +
                    commaWsp + '(' + number + '))?\\s*\\))',

        translate = '(?:(translate)\\s*\\(\\s*(' + number + ')(?:' +
                    commaWsp + '(' + number + '))?\\s*\\))',

        matrix = '(?:(matrix)\\s*\\(\\s*' +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' + commaWsp +
                  '(' + number + ')' +
                  '\\s*\\))',

        transform = '(?:' +
                    matrix + '|' +
                    translate + '|' +
                    scale + '|' +
                    rotate + '|' +
                    skewX + '|' +
                    skewY +
                    ')',

        transforms = '(?:' + transform + '(?:' + commaWsp + '*' + transform + ')*' + ')',

        transformList = '^\\s*(?:' + transforms + '?)\\s*$',

        // http://www.w3.org/TR/SVG/coords.html#TransformAttribute
        reTransformList = new RegExp(transformList),
        // == end transform regexp

        reTransform = new RegExp(transform, 'g');

    return function(attributeValue) {

      // start with identity matrix
      var matrix = iMatrix.concat(),
          matrices = [];

      // return if no argument was given or
      // an argument does not match transform attribute regexp
      if (!attributeValue || (attributeValue && !reTransformList.test(attributeValue))) {
        return matrix;
      }

      attributeValue.replace(reTransform, function(match) {

        var m = new RegExp(transform).exec(match).filter(function (match) {
              // match !== '' && match != null
              return (!!match);
            }),
            operation = m[1],
            args = m.slice(2).map(parseFloat);

        switch (operation) {
          case 'translate':
            translateMatrix(matrix, args);
            break;
          case 'rotate':
            args[0] = fabric.util.degreesToRadians(args[0]);
            rotateMatrix(matrix, args);
            break;
          case 'scale':
            scaleMatrix(matrix, args);
            break;
          case 'skewX':
            skewMatrix(matrix, args, 2);
            break;
          case 'skewY':
            skewMatrix(matrix, args, 1);
            break;
          case 'matrix':
            matrix = args;
            break;
        }

        // snapshot current matrix into matrices array
        matrices.push(matrix.concat());
        // reset
        matrix = iMatrix.concat();
      });

      var combinedMatrix = matrices[0];
      while (matrices.length > 1) {
        matrices.shift();
        combinedMatrix = fabric.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);
      }
      return combinedMatrix;
    };
  })();

  /**
   * @private
   */
  function parseStyleString(style, oStyle) {
    var attr, value;
    style.replace(/;\s*$/, '').split(';').forEach(function (chunk) {
      var pair = chunk.split(':');

      attr = pair[0].trim().toLowerCase();
      value =  pair[1].trim();

      oStyle[attr] = value;
    });
  }

  /**
   * @private
   */
  function parseStyleObject(style, oStyle) {
    var attr, value;
    for (var prop in style) {
      if (typeof style[prop] === 'undefined') {
        continue;
      }

      attr = prop.toLowerCase();
      value = style[prop];

      oStyle[attr] = value;
    }
  }

  /**
   * @private
   */
  function getGlobalStylesForElement(element, svgUid) {
    var styles = { };
    for (var rule in fabric.cssRules[svgUid]) {
      if (elementMatchesRule(element, rule.split(' '))) {
        for (var property in fabric.cssRules[svgUid][rule]) {
          styles[property] = fabric.cssRules[svgUid][rule][property];
        }
      }
    }
    return styles;
  }

  /**
   * @private
   */
  function elementMatchesRule(element, selectors) {
    var firstMatching, parentMatching = true;
    //start from rightmost selector.
    firstMatching = selectorMatches(element, selectors.pop());
    if (firstMatching && selectors.length) {
      parentMatching = doesSomeParentMatch(element, selectors);
    }
    return firstMatching && parentMatching && (selectors.length === 0);
  }

  function doesSomeParentMatch(element, selectors) {
    var selector, parentMatching = true;
    while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {
      if (parentMatching) {
        selector = selectors.pop();
      }
      element = element.parentNode;
      parentMatching = selectorMatches(element, selector);
    }
    return selectors.length === 0;
  }

  /**
   * @private
   */
  function selectorMatches(element, selector) {
    var nodeName = element.nodeName,
        classNames = element.getAttribute('class'),
        id = element.getAttribute('id'), matcher, i;
    // i check if a selector matches slicing away part from it.
    // if i get empty string i should match
    matcher = new RegExp('^' + nodeName, 'i');
    selector = selector.replace(matcher, '');
    if (id && selector.length) {
      matcher = new RegExp('#' + id + '(?![a-zA-Z\\-]+)', 'i');
      selector = selector.replace(matcher, '');
    }
    if (classNames && selector.length) {
      classNames = classNames.split(' ');
      for (i = classNames.length; i--;) {
        matcher = new RegExp('\\.' + classNames[i] + '(?![a-zA-Z\\-]+)', 'i');
        selector = selector.replace(matcher, '');
      }
    }
    return selector.length === 0;
  }

  /**
   * @private
   * to support IE8 missing getElementById on SVGdocument
   */
  function elementById(doc, id) {
    var el;
    doc.getElementById && (el = doc.getElementById(id));
    if (el) {
      return el;
    }
    var node, i, len, nodelist = doc.getElementsByTagName('*');
    for (i = 0, len = nodelist.length; i < len; i++) {
      node = nodelist[i];
      if (id === node.getAttribute('id')) {
        return node;
      }
    }
  }

  /**
   * @private
   */
  function parseUseDirectives(doc) {
    var nodelist = _getMultipleNodes(doc, ['use', 'svg:use']), i = 0;

    while (nodelist.length && i < nodelist.length) {
      var el = nodelist[i],
          xlink = el.getAttribute('xlink:href').substr(1),
          x = el.getAttribute('x') || 0,
          y = el.getAttribute('y') || 0,
          el2 = elementById(doc, xlink).cloneNode(true),
          currentTrans = (el2.getAttribute('transform') || '') + ' translate(' + x + ', ' + y + ')',
          parentNode, oldLength = nodelist.length, attr, j, attrs, len;

      applyViewboxTransform(el2);
      if (/^svg$/i.test(el2.nodeName)) {
        var el3 = el2.ownerDocument.createElement('g');
        for (j = 0, attrs = el2.attributes, len = attrs.length; j < len; j++) {
          attr = attrs.item(j);
          el3.setAttribute(attr.nodeName, attr.nodeValue);
        }
        // el2.firstChild != null
        while (el2.firstChild) {
          el3.appendChild(el2.firstChild);
        }
        el2 = el3;
      }

      for (j = 0, attrs = el.attributes, len = attrs.length; j < len; j++) {
        attr = attrs.item(j);
        if (attr.nodeName === 'x' || attr.nodeName === 'y' || attr.nodeName === 'xlink:href') {
          continue;
        }

        if (attr.nodeName === 'transform') {
          currentTrans = attr.nodeValue + ' ' + currentTrans;
        }
        else {
          el2.setAttribute(attr.nodeName, attr.nodeValue);
        }
      }

      el2.setAttribute('transform', currentTrans);
      el2.setAttribute('instantiated_by_use', '1');
      el2.removeAttribute('id');
      parentNode = el.parentNode;
      parentNode.replaceChild(el2, el);
      // some browsers do not shorten nodelist after replaceChild (IE8)
      if (nodelist.length === oldLength) {
        i++;
      }
    }
  }

  // http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute
  // matches, e.g.: +14.56e-12, etc.
  var reViewBoxAttrValue = new RegExp(
    '^' +
    '\\s*(' + fabric.reNum + '+)\\s*,?' +
    '\\s*(' + fabric.reNum + '+)\\s*,?' +
    '\\s*(' + fabric.reNum + '+)\\s*,?' +
    '\\s*(' + fabric.reNum + '+)\\s*' +
    '$'
  );

  /**
   * Add a <g> element that envelop all child elements and makes the viewbox transformMatrix descend on all elements
   */
  function applyViewboxTransform(element) {

    var viewBoxAttr = element.getAttribute('viewBox'),
        scaleX = 1,
        scaleY = 1,
        minX = 0,
        minY = 0,
        viewBoxWidth, viewBoxHeight, matrix, el,
        widthAttr = element.getAttribute('width'),
        heightAttr = element.getAttribute('height'),
        x = element.getAttribute('x') || 0,
        y = element.getAttribute('y') || 0,
        preserveAspectRatio = element.getAttribute('preserveAspectRatio') || '',
        missingViewBox = (!viewBoxAttr || !reViewBoxTagNames.test(element.nodeName)
                           || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue))),
        missingDimAttr = (!widthAttr || !heightAttr || widthAttr === '100%' || heightAttr === '100%'),
        toBeParsed = missingViewBox && missingDimAttr,
        parsedDim = { }, translateMatrix = '';

    parsedDim.width = 0;
    parsedDim.height = 0;
    parsedDim.toBeParsed = toBeParsed;

    if (toBeParsed) {
      return parsedDim;
    }

    if (missingViewBox) {
      parsedDim.width = parseUnit(widthAttr);
      parsedDim.height = parseUnit(heightAttr);
      return parsedDim;
    }

    minX = -parseFloat(viewBoxAttr[1]);
    minY = -parseFloat(viewBoxAttr[2]);
    viewBoxWidth = parseFloat(viewBoxAttr[3]);
    viewBoxHeight = parseFloat(viewBoxAttr[4]);

    if (!missingDimAttr) {
      parsedDim.width = parseUnit(widthAttr);
      parsedDim.height = parseUnit(heightAttr);
      scaleX = parsedDim.width / viewBoxWidth;
      scaleY = parsedDim.height / viewBoxHeight;
    }
    else {
      parsedDim.width = viewBoxWidth;
      parsedDim.height = viewBoxHeight;
    }

    // default is to preserve aspect ratio
    preserveAspectRatio = fabric.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);
    if (preserveAspectRatio.alignX !== 'none') {
      //translate all container for the effect of Mid, Min, Max
      scaleY = scaleX = (scaleX > scaleY ? scaleY : scaleX);
    }

    if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {
      return parsedDim;
    }

    if (x || y) {
      translateMatrix = ' translate(' + parseUnit(x) + ' ' + parseUnit(y) + ') ';
    }

    matrix = translateMatrix + ' matrix(' + scaleX +
                  ' 0' +
                  ' 0 ' +
                  scaleY + ' ' +
                  (minX * scaleX) + ' ' +
                  (minY * scaleY) + ') ';

    if (element.nodeName === 'svg') {
      el = element.ownerDocument.createElement('g');
      // element.firstChild != null
      while (element.firstChild) {
        el.appendChild(element.firstChild);
      }
      element.appendChild(el);
    }
    else {
      el = element;
      matrix = el.getAttribute('transform') + matrix;
    }

    el.setAttribute('transform', matrix);
    return parsedDim;
  }

  function hasAncestorWithNodeName(element, nodeName) {
    while (element && (element = element.parentNode)) {
      if (element.nodeName && nodeName.test(element.nodeName.replace('svg:', ''))
        && !element.getAttribute('instantiated_by_use')) {
        return true;
      }
    }
    return false;
  }

  /**
   * Parses an SVG document, converts it to an array of corresponding fabric.* instances and passes them to a callback
   * @static
   * @function
   * @memberOf fabric
   * @param {SVGDocument} doc SVG document to parse
   * @param {Function} callback Callback to call when parsing is finished;
   * It's being passed an array of elements (parsed from a document).
   * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
   * @param {Object} [parsingOptions] options for parsing document
   * @param {String} [parsingOptions.crossOrigin] crossOrigin settings
   */
  fabric.parseSVGDocument = function(doc, callback, reviver, parsingOptions) {
    if (!doc) {
      return;
    }

    parseUseDirectives(doc);

    var svgUid =  fabric.Object.__uid++, i, len,
        options = applyViewboxTransform(doc),
        descendants = fabric.util.toArray(doc.getElementsByTagName('*'));
    options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;
    options.svgUid = svgUid;

    if (descendants.length === 0 && fabric.isLikelyNode) {
      // we're likely in node, where "o3-xml" library fails to gEBTN("*")
      // https://github.com/ajaxorg/node-o3-xml/issues/21
      descendants = doc.selectNodes('//*[name(.)!="svg"]');
      var arr = [];
      for (i = 0, len = descendants.length; i < len; i++) {
        arr[i] = descendants[i];
      }
      descendants = arr;
    }

    var elements = descendants.filter(function(el) {
      applyViewboxTransform(el);
      return reAllowedSVGTagNames.test(el.nodeName.replace('svg:', '')) &&
            !hasAncestorWithNodeName(el, reNotAllowedAncestors); // http://www.w3.org/TR/SVG/struct.html#DefsElement
    });

    if (!elements || (elements && !elements.length)) {
      callback && callback([], {});
      return;
    }

    fabric.gradientDefs[svgUid] = fabric.getGradientDefs(doc);
    fabric.cssRules[svgUid] = fabric.getCSSRules(doc);
    // Precedence of rules:   style > class > attribute
    fabric.parseElements(elements, function(instances, elements) {
      if (callback) {
        callback(instances, options, elements, descendants);
      }
    }, clone(options), reviver, parsingOptions);
  };

  var reFontDeclaration = new RegExp(
    '(normal|italic)?\\s*(normal|small-caps)?\\s*' +
    '(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(' +
      fabric.reNum +
    '(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|' + fabric.reNum + '))?\\s+(.*)');

  extend(fabric, {
    /**
     * Parses a short font declaration, building adding its properties to a style object
     * @static
     * @function
     * @memberOf fabric
     * @param {String} value font declaration
     * @param {Object} oStyle definition
     */
    parseFontDeclaration: function(value, oStyle) {
      var match = value.match(reFontDeclaration);

      if (!match) {
        return;
      }
      var fontStyle = match[1],
          // font variant is not used
          // fontVariant = match[2],
          fontWeight = match[3],
          fontSize = match[4],
          lineHeight = match[5],
          fontFamily = match[6];

      if (fontStyle) {
        oStyle.fontStyle = fontStyle;
      }
      if (fontWeight) {
        oStyle.fontWeight = isNaN(parseFloat(fontWeight)) ? fontWeight : parseFloat(fontWeight);
      }
      if (fontSize) {
        oStyle.fontSize = parseUnit(fontSize);
      }
      if (fontFamily) {
        oStyle.fontFamily = fontFamily;
      }
      if (lineHeight) {
        oStyle.lineHeight = lineHeight === 'normal' ? 1 : lineHeight;
      }
    },

    /**
     * Parses an SVG document, returning all of the gradient declarations found in it
     * @static
     * @function
     * @memberOf fabric
     * @param {SVGDocument} doc SVG document to parse
     * @return {Object} Gradient definitions; key corresponds to element id, value -- to gradient definition element
     */
    getGradientDefs: function(doc) {
      var tagArray = [
            'linearGradient',
            'radialGradient',
            'svg:linearGradient',
            'svg:radialGradient'],
          elList = _getMultipleNodes(doc, tagArray),
          el, j = 0, id, xlink,
          gradientDefs = { }, idsToXlinkMap = { };

      j = elList.length;

      while (j--) {
        el = elList[j];
        xlink = el.getAttribute('xlink:href');
        id = el.getAttribute('id');
        if (xlink) {
          idsToXlinkMap[id] = xlink.substr(1);
        }
        gradientDefs[id] = el;
      }

      for (id in idsToXlinkMap) {
        var el2 = gradientDefs[idsToXlinkMap[id]].cloneNode(true);
        el = gradientDefs[id];
        while (el2.firstChild) {
          el.appendChild(el2.firstChild);
        }
      }
      return gradientDefs;
    },

    /**
     * Returns an object of attributes' name/value, given element and an array of attribute names;
     * Parses parent "g" nodes recursively upwards.
     * @static
     * @memberOf fabric
     * @param {DOMElement} element Element to parse
     * @param {Array} attributes Array of attributes to parse
     * @return {Object} object containing parsed attributes' names/values
     */
    parseAttributes: function(element, attributes, svgUid) {

      if (!element) {
        return;
      }

      var value,
          parentAttributes = { },
          fontSize;

      if (typeof svgUid === 'undefined') {
        svgUid = element.getAttribute('svgUid');
      }
      // if there's a parent container (`g` or `a` or `symbol` node), parse its attributes recursively upwards
      if (element.parentNode && reAllowedParents.test(element.parentNode.nodeName)) {
        parentAttributes = fabric.parseAttributes(element.parentNode, attributes, svgUid);
      }
      fontSize = (parentAttributes && parentAttributes.fontSize ) ||
                 element.getAttribute('font-size') || fabric.Text.DEFAULT_SVG_FONT_SIZE;

      var ownAttributes = attributes.reduce(function(memo, attr) {
        value = element.getAttribute(attr);
        if (value) { // eslint-disable-line
          memo[attr] = value;
        }
        return memo;
      }, { });
      // add values parsed from style, which take precedence over attributes
      // (see: http://www.w3.org/TR/SVG/styling.html#UsingPresentationAttributes)
      ownAttributes = extend(ownAttributes,
        extend(getGlobalStylesForElement(element, svgUid), fabric.parseStyleAttribute(element)));

      var normalizedAttr, normalizedValue, normalizedStyle = {};
      for (var attr in ownAttributes) {
        normalizedAttr = normalizeAttr(attr);
        normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize);
        normalizedStyle[normalizedAttr] = normalizedValue;
      }
      if (normalizedStyle && normalizedStyle.font) {
        fabric.parseFontDeclaration(normalizedStyle.font, normalizedStyle);
      }
      var mergedAttrs = extend(parentAttributes, normalizedStyle);
      return reAllowedParents.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);
    },

    /**
     * Transforms an array of svg elements to corresponding fabric.* instances
     * @static
     * @memberOf fabric
     * @param {Array} elements Array of elements to parse
     * @param {Function} callback Being passed an array of fabric instances (transformed from SVG elements)
     * @param {Object} [options] Options object
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     */
    parseElements: function(elements, callback, options, reviver, parsingOptions) {
      new fabric.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();
    },

    /**
     * Parses "style" attribute, retuning an object with values
     * @static
     * @memberOf fabric
     * @param {SVGElement} element Element to parse
     * @return {Object} Objects with values parsed from style attribute of an element
     */
    parseStyleAttribute: function(element) {
      var oStyle = { },
          style = element.getAttribute('style');

      if (!style) {
        return oStyle;
      }

      if (typeof style === 'string') {
        parseStyleString(style, oStyle);
      }
      else {
        parseStyleObject(style, oStyle);
      }

      return oStyle;
    },

    /**
     * Parses "points" attribute, returning an array of values
     * @static
     * @memberOf fabric
     * @param {String} points points attribute string
     * @return {Array} array of points
     */
    parsePointsAttribute: function(points) {

      // points attribute is required and must not be empty
      if (!points) {
        return null;
      }

      // replace commas with whitespace and remove bookending whitespace
      points = points.replace(/,/g, ' ').trim();

      points = points.split(/\s+/);
      var parsedPoints = [], i, len;

      for (i = 0, len = points.length; i < len; i += 2) {
        parsedPoints.push({
          x: parseFloat(points[i]),
          y: parseFloat(points[i + 1])
        });
      }

      // odd number of points is an error
      // if (parsedPoints.length % 2 !== 0) {
      //   return null;
      // }

      return parsedPoints;
    },

    /**
     * Returns CSS rules for a given SVG document
     * @static
     * @function
     * @memberOf fabric
     * @param {SVGDocument} doc SVG document to parse
     * @return {Object} CSS rules of this document
     */
    getCSSRules: function(doc) {
      var styles = doc.getElementsByTagName('style'), i, len,
          allRules = { }, rules;

      // very crude parsing of style contents
      for (i = 0, len = styles.length; i < len; i++) {
        // IE9 doesn't support textContent, but provides text instead.
        var styleContents = styles[i].textContent || styles[i].text;

        // remove comments
        styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, '');
        if (styleContents.trim() === '') {
          continue;
        }
        rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
        rules = rules.map(function(rule) { return rule.trim(); });
        // eslint-disable-next-line no-loop-func
        rules.forEach(function(rule) {

          var match = rule.match(/([\s\S]*?)\s*\{([^}]*)\}/),
              ruleObj = { }, declaration = match[2].trim(),
              propertyValuePairs = declaration.replace(/;$/, '').split(/\s*;\s*/);

          for (i = 0, len = propertyValuePairs.length; i < len; i++) {
            var pair = propertyValuePairs[i].split(/\s*:\s*/),
                property = pair[0],
                value = pair[1];
            ruleObj[property] = value;
          }
          rule = match[1];
          rule.split(',').forEach(function(_rule) {
            _rule = _rule.replace(/^svg/i, '').trim();
            if (_rule === '') {
              return;
            }
            if (allRules[_rule]) {
              fabric.util.object.extend(allRules[_rule], ruleObj);
            }
            else {
              allRules[_rule] = fabric.util.object.clone(ruleObj);
            }
          });
        });
      }
      return allRules;
    },

    /**
     * Takes url corresponding to an SVG document, and parses it into a set of fabric objects.
     * Note that SVG is fetched via XMLHttpRequest, so it needs to conform to SOP (Same Origin Policy)
     * @memberOf fabric
     * @param {String} url
     * @param {Function} callback
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     * @param {Object} [options] Object containing options for parsing
     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
     */
    loadSVGFromURL: function(url, callback, reviver, options) {

      url = url.replace(/^\n\s*/, '').trim();
      new fabric.util.request(url, {
        method: 'get',
        onComplete: onComplete
      });

      function onComplete(r) {

        var xml = r.responseXML;
        if (xml && !xml.documentElement && fabric.window.ActiveXObject && r.responseText) {
          xml = new ActiveXObject('Microsoft.XMLDOM');
          xml.async = 'false';
          //IE chokes on DOCTYPE
          xml.loadXML(r.responseText.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
        }
        if (!xml || !xml.documentElement) {
          callback && callback(null);
        }

        fabric.parseSVGDocument(xml.documentElement, function (results, _options, elements, allElements) {
          callback && callback(results, _options, elements, allElements);
        }, reviver, options);
      }
    },

    /**
     * Takes string corresponding to an SVG document, and parses it into a set of fabric objects
     * @memberOf fabric
     * @param {String} string
     * @param {Function} callback
     * @param {Function} [reviver] Method for further parsing of SVG elements, called after each fabric object created.
     * @param {Object} [options] Object containing options for parsing
     * @param {String} [options.crossOrigin] crossOrigin crossOrigin setting to use for external resources
     */
    loadSVGFromString: function(string, callback, reviver, options) {
      string = string.trim();
      var doc;
      if (typeof DOMParser !== 'undefined') {
        var parser = new DOMParser();
        if (parser && parser.parseFromString) {
          doc = parser.parseFromString(string, 'text/xml');
        }
      }
      else if (fabric.window.ActiveXObject) {
        doc = new ActiveXObject('Microsoft.XMLDOM');
        doc.async = 'false';
        // IE chokes on DOCTYPE
        doc.loadXML(string.replace(/<!DOCTYPE[\s\S]*?(\[[\s\S]*\])*?>/i, ''));
      }

      fabric.parseSVGDocument(doc.documentElement, function (results, _options, elements, allElements) {
        callback(results, _options, elements, allElements);
      }, reviver, options);
    }
  });

})( true ? exports : this);


fabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions) {
  this.elements = elements;
  this.callback = callback;
  this.options = options;
  this.reviver = reviver;
  this.svgUid = (options && options.svgUid) || 0;
  this.parsingOptions = parsingOptions;
};

fabric.ElementsParser.prototype.parse = function() {
  this.instances = new Array(this.elements.length);
  this.numElements = this.elements.length;

  this.createObjects();
};

fabric.ElementsParser.prototype.createObjects = function() {
  for (var i = 0, len = this.elements.length; i < len; i++) {
    this.elements[i].setAttribute('svgUid', this.svgUid);
    (function(_obj, i) {
      setTimeout(function() {
        _obj.createObject(_obj.elements[i], i);
      }, 0);
    })(this, i);
  }
};

fabric.ElementsParser.prototype.createObject = function(el, index) {
  var klass = fabric[fabric.util.string.capitalize(el.tagName.replace('svg:', ''))];
  if (klass && klass.fromElement) {
    try {
      this._createObject(klass, el, index);
    }
    catch (err) {
      fabric.log(err);
    }
  }
  else {
    this.checkIfDone();
  }
};

fabric.ElementsParser.prototype._createObject = function(klass, el, index) {
  klass.fromElement(el, this.createCallback(index, el), this.options);
};

fabric.ElementsParser.prototype.createCallback = function(index, el) {
  var _this = this;
  return function(obj) {
    _this.resolveGradient(obj, 'fill');
    _this.resolveGradient(obj, 'stroke');
    obj._removeTransformMatrix();
    if (obj instanceof fabric.Image) {
      obj.parsePreserveAspectRatioAttribute(el);
    }
    _this.reviver && _this.reviver(el, obj);
    _this.instances[index] = obj;
    _this.checkIfDone();
  };
};

fabric.ElementsParser.prototype.resolveGradient = function(obj, property) {

  var instanceFillValue = obj.get(property);
  if (!(/^url\(/).test(instanceFillValue)) {
    return;
  }
  var gradientId = instanceFillValue.slice(5, instanceFillValue.length - 1);
  if (fabric.gradientDefs[this.svgUid][gradientId]) {
    obj.set(property,
      fabric.Gradient.fromElement(fabric.gradientDefs[this.svgUid][gradientId], obj));
  }
};

fabric.ElementsParser.prototype.checkIfDone = function() {
  if (--this.numElements === 0) {
    this.instances = this.instances.filter(function(el) {
      // eslint-disable-next-line no-eq-null, eqeqeq
      return el != null;
    });
    this.callback(this.instances, this.elements);
  }
};


(function(global) {

  'use strict';

  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Point) {
    fabric.warn('fabric.Point is already defined');
    return;
  }

  fabric.Point = Point;

  /**
   * Point class
   * @class fabric.Point
   * @memberOf fabric
   * @constructor
   * @param {Number} x
   * @param {Number} y
   * @return {fabric.Point} thisArg
   */
  function Point(x, y) {
    this.x = x;
    this.y = y;
  }

  Point.prototype = /** @lends fabric.Point.prototype */ {

    type: 'point',

    constructor: Point,

    /**
     * Adds another point to this one and returns another one
     * @param {fabric.Point} that
     * @return {fabric.Point} new Point instance with added values
     */
    add: function (that) {
      return new Point(this.x + that.x, this.y + that.y);
    },

    /**
     * Adds another point to this one
     * @param {fabric.Point} that
     * @return {fabric.Point} thisArg
     * @chainable
     */
    addEquals: function (that) {
      this.x += that.x;
      this.y += that.y;
      return this;
    },

    /**
     * Adds value to this point and returns a new one
     * @param {Number} scalar
     * @return {fabric.Point} new Point with added value
     */
    scalarAdd: function (scalar) {
      return new Point(this.x + scalar, this.y + scalar);
    },

    /**
     * Adds value to this point
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    scalarAddEquals: function (scalar) {
      this.x += scalar;
      this.y += scalar;
      return this;
    },

    /**
     * Subtracts another point from this point and returns a new one
     * @param {fabric.Point} that
     * @return {fabric.Point} new Point object with subtracted values
     */
    subtract: function (that) {
      return new Point(this.x - that.x, this.y - that.y);
    },

    /**
     * Subtracts another point from this point
     * @param {fabric.Point} that
     * @return {fabric.Point} thisArg
     * @chainable
     */
    subtractEquals: function (that) {
      this.x -= that.x;
      this.y -= that.y;
      return this;
    },

    /**
     * Subtracts value from this point and returns a new one
     * @param {Number} scalar
     * @return {fabric.Point}
     */
    scalarSubtract: function (scalar) {
      return new Point(this.x - scalar, this.y - scalar);
    },

    /**
     * Subtracts value from this point
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    scalarSubtractEquals: function (scalar) {
      this.x -= scalar;
      this.y -= scalar;
      return this;
    },

    /**
     * Multiplies this point by a value and returns a new one
     * TODO: rename in scalarMultiply in 2.0
     * @param {Number} scalar
     * @return {fabric.Point}
     */
    multiply: function (scalar) {
      return new Point(this.x * scalar, this.y * scalar);
    },

    /**
     * Multiplies this point by a value
     * TODO: rename in scalarMultiplyEquals in 2.0
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    multiplyEquals: function (scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    },

    /**
     * Divides this point by a value and returns a new one
     * TODO: rename in scalarDivide in 2.0
     * @param {Number} scalar
     * @return {fabric.Point}
     */
    divide: function (scalar) {
      return new Point(this.x / scalar, this.y / scalar);
    },

    /**
     * Divides this point by a value
     * TODO: rename in scalarDivideEquals in 2.0
     * @param {Number} scalar
     * @return {fabric.Point} thisArg
     * @chainable
     */
    divideEquals: function (scalar) {
      this.x /= scalar;
      this.y /= scalar;
      return this;
    },

    /**
     * Returns true if this point is equal to another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    eq: function (that) {
      return (this.x === that.x && this.y === that.y);
    },

    /**
     * Returns true if this point is less than another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    lt: function (that) {
      return (this.x < that.x && this.y < that.y);
    },

    /**
     * Returns true if this point is less than or equal to another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    lte: function (that) {
      return (this.x <= that.x && this.y <= that.y);
    },

    /**

     * Returns true if this point is greater another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    gt: function (that) {
      return (this.x > that.x && this.y > that.y);
    },

    /**
     * Returns true if this point is greater than or equal to another one
     * @param {fabric.Point} that
     * @return {Boolean}
     */
    gte: function (that) {
      return (this.x >= that.x && this.y >= that.y);
    },

    /**
     * Returns new point which is the result of linear interpolation with this one and another one
     * @param {fabric.Point} that
     * @param {Number} t , position of interpolation, between 0 and 1 default 0.5
     * @return {fabric.Point}
     */
    lerp: function (that, t) {
      if (typeof t === 'undefined') {
        t = 0.5;
      }
      t = Math.max(Math.min(1, t), 0);
      return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
    },

    /**
     * Returns distance from this point and another one
     * @param {fabric.Point} that
     * @return {Number}
     */
    distanceFrom: function (that) {
      var dx = this.x - that.x,
          dy = this.y - that.y;
      return Math.sqrt(dx * dx + dy * dy);
    },

    /**
     * Returns the point between this point and another one
     * @param {fabric.Point} that
     * @return {fabric.Point}
     */
    midPointFrom: function (that) {
      return this.lerp(that);
    },

    /**
     * Returns a new point which is the min of this and another one
     * @param {fabric.Point} that
     * @return {fabric.Point}
     */
    min: function (that) {
      return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));
    },

    /**
     * Returns a new point which is the max of this and another one
     * @param {fabric.Point} that
     * @return {fabric.Point}
     */
    max: function (that) {
      return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));
    },

    /**
     * Returns string representation of this point
     * @return {String}
     */
    toString: function () {
      return this.x + ',' + this.y;
    },

    /**
     * Sets x/y of this point
     * @param {Number} x
     * @param {Number} y
     * @chainable
     */
    setXY: function (x, y) {
      this.x = x;
      this.y = y;
      return this;
    },

    /**
     * Sets x of this point
     * @param {Number} x
     * @chainable
     */
    setX: function (x) {
      this.x = x;
      return this;
    },

    /**
     * Sets y of this point
     * @param {Number} y
     * @chainable
     */
    setY: function (y) {
      this.y = y;
      return this;
    },

    /**
     * Sets x/y of this point from another point
     * @param {fabric.Point} that
     * @chainable
     */
    setFromPoint: function (that) {
      this.x = that.x;
      this.y = that.y;
      return this;
    },

    /**
     * Swaps x/y of this point and another point
     * @param {fabric.Point} that
     */
    swap: function (that) {
      var x = this.x,
          y = this.y;
      this.x = that.x;
      this.y = that.y;
      that.x = x;
      that.y = y;
    },

    /**
     * return a cloned instance of the point
     * @return {fabric.Point}
     */
    clone: function () {
      return new Point(this.x, this.y);
    }
  };

})( true ? exports : this);


(function(global) {

  'use strict';

  /* Adaptation of work of Kevin Lindsey (kevin@kevlindev.com) */
  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Intersection) {
    fabric.warn('fabric.Intersection is already defined');
    return;
  }

  /**
   * Intersection class
   * @class fabric.Intersection
   * @memberOf fabric
   * @constructor
   */
  function Intersection(status) {
    this.status = status;
    this.points = [];
  }

  fabric.Intersection = Intersection;

  fabric.Intersection.prototype = /** @lends fabric.Intersection.prototype */ {

    constructor: Intersection,

    /**
     * Appends a point to intersection
     * @param {fabric.Point} point
     * @return {fabric.Intersection} thisArg
     * @chainable
     */
    appendPoint: function (point) {
      this.points.push(point);
      return this;
    },

    /**
     * Appends points to intersection
     * @param {Array} points
     * @return {fabric.Intersection} thisArg
     * @chainable
     */
    appendPoints: function (points) {
      this.points = this.points.concat(points);
      return this;
    }
  };

  /**
   * Checks if one line intersects another
   * TODO: rename in intersectSegmentSegment
   * @static
   * @param {fabric.Point} a1
   * @param {fabric.Point} a2
   * @param {fabric.Point} b1
   * @param {fabric.Point} b2
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectLineLine = function (a1, a2, b1, b2) {
    var result,
        uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
        ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
        uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
    if (uB !== 0) {
      var ua = uaT / uB,
          ub = ubT / uB;
      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
        result = new Intersection('Intersection');
        result.appendPoint(new fabric.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
      }
      else {
        result = new Intersection();
      }
    }
    else {
      if (uaT === 0 || ubT === 0) {
        result = new Intersection('Coincident');
      }
      else {
        result = new Intersection('Parallel');
      }
    }
    return result;
  };

  /**
   * Checks if line intersects polygon
   * TODO: rename in intersectSegmentPolygon
   * fix detection of coincident
   * @static
   * @param {fabric.Point} a1
   * @param {fabric.Point} a2
   * @param {Array} points
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectLinePolygon = function(a1, a2, points) {
    var result = new Intersection(),
        length = points.length,
        b1, b2, inter, i;

    for (i = 0; i < length; i++) {
      b1 = points[i];
      b2 = points[(i + 1) % length];
      inter = Intersection.intersectLineLine(a1, a2, b1, b2);

      result.appendPoints(inter.points);
    }
    if (result.points.length > 0) {
      result.status = 'Intersection';
    }
    return result;
  };

  /**
   * Checks if polygon intersects another polygon
   * @static
   * @param {Array} points1
   * @param {Array} points2
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectPolygonPolygon = function (points1, points2) {
    var result = new Intersection(),
        length = points1.length, i;

    for (i = 0; i < length; i++) {
      var a1 = points1[i],
          a2 = points1[(i + 1) % length],
          inter = Intersection.intersectLinePolygon(a1, a2, points2);

      result.appendPoints(inter.points);
    }
    if (result.points.length > 0) {
      result.status = 'Intersection';
    }
    return result;
  };

  /**
   * Checks if polygon intersects rectangle
   * @static
   * @param {Array} points
   * @param {fabric.Point} r1
   * @param {fabric.Point} r2
   * @return {fabric.Intersection}
   */
  fabric.Intersection.intersectPolygonRectangle = function (points, r1, r2) {
    var min = r1.min(r2),
        max = r1.max(r2),
        topRight = new fabric.Point(max.x, min.y),
        bottomLeft = new fabric.Point(min.x, max.y),
        inter1 = Intersection.intersectLinePolygon(min, topRight, points),
        inter2 = Intersection.intersectLinePolygon(topRight, max, points),
        inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points),
        inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points),
        result = new Intersection();

    result.appendPoints(inter1.points);
    result.appendPoints(inter2.points);
    result.appendPoints(inter3.points);
    result.appendPoints(inter4.points);

    if (result.points.length > 0) {
      result.status = 'Intersection';
    }
    return result;
  };

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Color) {
    fabric.warn('fabric.Color is already defined.');
    return;
  }

  /**
   * Color class
   * The purpose of {@link fabric.Color} is to abstract and encapsulate common color operations;
   * {@link fabric.Color} is a constructor and creates instances of {@link fabric.Color} objects.
   *
   * @class fabric.Color
   * @param {String} color optional in hex or rgb(a) or hsl format or from known color list
   * @return {fabric.Color} thisArg
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2/#colors}
   */
  function Color(color) {
    if (!color) {
      this.setSource([0, 0, 0, 1]);
    }
    else {
      this._tryParsingColor(color);
    }
  }

  fabric.Color = Color;

  fabric.Color.prototype = /** @lends fabric.Color.prototype */ {

    /**
     * @private
     * @param {String|Array} color Color value to parse
     */
    _tryParsingColor: function(color) {
      var source;

      if (color in Color.colorNameMap) {
        color = Color.colorNameMap[color];
      }

      if (color === 'transparent') {
        source = [255, 255, 255, 0];
      }

      if (!source) {
        source = Color.sourceFromHex(color);
      }
      if (!source) {
        source = Color.sourceFromRgb(color);
      }
      if (!source) {
        source = Color.sourceFromHsl(color);
      }
      if (!source) {
        //if color is not recognize let's make black as canvas does
        source = [0, 0, 0, 1];
      }
      if (source) {
        this.setSource(source);
      }
    },

    /**
     * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
     * @private
     * @param {Number} r Red color value
     * @param {Number} g Green color value
     * @param {Number} b Blue color value
     * @return {Array} Hsl color
     */
    _rgbToHsl: function(r, g, b) {
      r /= 255; g /= 255; b /= 255;

      var h, s, l,
          max = fabric.util.array.max([r, g, b]),
          min = fabric.util.array.min([r, g, b]);

      l = (max + min) / 2;

      if (max === min) {
        h = s = 0; // achromatic
      }
      else {
        var d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }

      return [
        Math.round(h * 360),
        Math.round(s * 100),
        Math.round(l * 100)
      ];
    },

    /**
     * Returns source of this color (where source is an array representation; ex: [200, 200, 100, 1])
     * @return {Array}
     */
    getSource: function() {
      return this._source;
    },

    /**
     * Sets source of this color (where source is an array representation; ex: [200, 200, 100, 1])
     * @param {Array} source
     */
    setSource: function(source) {
      this._source = source;
    },

    /**
     * Returns color representation in RGB format
     * @return {String} ex: rgb(0-255,0-255,0-255)
     */
    toRgb: function() {
      var source = this.getSource();
      return 'rgb(' + source[0] + ',' + source[1] + ',' + source[2] + ')';
    },

    /**
     * Returns color representation in RGBA format
     * @return {String} ex: rgba(0-255,0-255,0-255,0-1)
     */
    toRgba: function() {
      var source = this.getSource();
      return 'rgba(' + source[0] + ',' + source[1] + ',' + source[2] + ',' + source[3] + ')';
    },

    /**
     * Returns color representation in HSL format
     * @return {String} ex: hsl(0-360,0%-100%,0%-100%)
     */
    toHsl: function() {
      var source = this.getSource(),
          hsl = this._rgbToHsl(source[0], source[1], source[2]);

      return 'hsl(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%)';
    },

    /**
     * Returns color representation in HSLA format
     * @return {String} ex: hsla(0-360,0%-100%,0%-100%,0-1)
     */
    toHsla: function() {
      var source = this.getSource(),
          hsl = this._rgbToHsl(source[0], source[1], source[2]);

      return 'hsla(' + hsl[0] + ',' + hsl[1] + '%,' + hsl[2] + '%,' + source[3] + ')';
    },

    /**
     * Returns color representation in HEX format
     * @return {String} ex: FF5555
     */
    toHex: function() {
      var source = this.getSource(), r, g, b;

      r = source[0].toString(16);
      r = (r.length === 1) ? ('0' + r) : r;

      g = source[1].toString(16);
      g = (g.length === 1) ? ('0' + g) : g;

      b = source[2].toString(16);
      b = (b.length === 1) ? ('0' + b) : b;

      return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();
    },

    /**
     * Returns color representation in HEXA format
     * @return {String} ex: FF5555CC
     */
    toHexa: function() {
      var source = this.getSource(), a;

      a = source[3] * 255;
      a = a.toString(16);
      a = (a.length === 1) ? ('0' + a) : a;

      return this.toHex() + a.toUpperCase();
    },

    /**
     * Gets value of alpha channel for this color
     * @return {Number} 0-1
     */
    getAlpha: function() {
      return this.getSource()[3];
    },

    /**
     * Sets value of alpha channel for this color
     * @param {Number} alpha Alpha value 0-1
     * @return {fabric.Color} thisArg
     */
    setAlpha: function(alpha) {
      var source = this.getSource();
      source[3] = alpha;
      this.setSource(source);
      return this;
    },

    /**
     * Transforms color to its grayscale representation
     * @return {fabric.Color} thisArg
     */
    toGrayscale: function() {
      var source = this.getSource(),
          average = parseInt((source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0), 10),
          currentAlpha = source[3];
      this.setSource([average, average, average, currentAlpha]);
      return this;
    },

    /**
     * Transforms color to its black and white representation
     * @param {Number} threshold
     * @return {fabric.Color} thisArg
     */
    toBlackWhite: function(threshold) {
      var source = this.getSource(),
          average = (source[0] * 0.3 + source[1] * 0.59 + source[2] * 0.11).toFixed(0),
          currentAlpha = source[3];

      threshold = threshold || 127;

      average = (Number(average) < Number(threshold)) ? 0 : 255;
      this.setSource([average, average, average, currentAlpha]);
      return this;
    },

    /**
     * Overlays color with another color
     * @param {String|fabric.Color} otherColor
     * @return {fabric.Color} thisArg
     */
    overlayWith: function(otherColor) {
      if (!(otherColor instanceof Color)) {
        otherColor = new Color(otherColor);
      }

      var result = [],
          alpha = this.getAlpha(),
          otherAlpha = 0.5,
          source = this.getSource(),
          otherSource = otherColor.getSource(), i;

      for (i = 0; i < 3; i++) {
        result.push(Math.round((source[i] * (1 - otherAlpha)) + (otherSource[i] * otherAlpha)));
      }

      result[3] = alpha;
      this.setSource(result);
      return this;
    }
  };

  /**
   * Regex matching color in RGB or RGBA formats (ex: rgb(0, 0, 0), rgba(255, 100, 10, 0.5), rgba( 255 , 100 , 10 , 0.5 ), rgb(1,1,1), rgba(100%, 60%, 10%, 0.5))
   * @static
   * @field
   * @memberOf fabric.Color
   */
   // eslint-disable-next-line max-len
  fabric.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/;

  /**
   * Regex matching color in HSL or HSLA formats (ex: hsl(200, 80%, 10%), hsla(300, 50%, 80%, 0.5), hsla( 300 , 50% , 80% , 0.5 ))
   * @static
   * @field
   * @memberOf fabric.Color
   */
  fabric.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/;

  /**
   * Regex matching color in HEX format (ex: #FF5544CC, #FF5555, 010155, aff)
   * @static
   * @field
   * @memberOf fabric.Color
   */
  fabric.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;

  /**
   * Map of the 148 color names with HEX code
   * @static
   * @field
   * @memberOf fabric.Color
   * @see: https://www.w3.org/TR/css3-color/#svg-color
   */
  fabric.Color.colorNameMap = {
    aliceblue:            '#F0F8FF',
    antiquewhite:         '#FAEBD7',
    aqua:                 '#00FFFF',
    aquamarine:           '#7FFFD4',
    azure:                '#F0FFFF',
    beige:                '#F5F5DC',
    bisque:               '#FFE4C4',
    black:                '#000000',
    blanchedalmond:       '#FFEBCD',
    blue:                 '#0000FF',
    blueviolet:           '#8A2BE2',
    brown:                '#A52A2A',
    burlywood:            '#DEB887',
    cadetblue:            '#5F9EA0',
    chartreuse:           '#7FFF00',
    chocolate:            '#D2691E',
    coral:                '#FF7F50',
    cornflowerblue:       '#6495ED',
    cornsilk:             '#FFF8DC',
    crimson:              '#DC143C',
    cyan:                 '#00FFFF',
    darkblue:             '#00008B',
    darkcyan:             '#008B8B',
    darkgoldenrod:        '#B8860B',
    darkgray:             '#A9A9A9',
    darkgrey:             '#A9A9A9',
    darkgreen:            '#006400',
    darkkhaki:            '#BDB76B',
    darkmagenta:          '#8B008B',
    darkolivegreen:       '#556B2F',
    darkorange:           '#FF8C00',
    darkorchid:           '#9932CC',
    darkred:              '#8B0000',
    darksalmon:           '#E9967A',
    darkseagreen:         '#8FBC8F',
    darkslateblue:        '#483D8B',
    darkslategray:        '#2F4F4F',
    darkslategrey:        '#2F4F4F',
    darkturquoise:        '#00CED1',
    darkviolet:           '#9400D3',
    deeppink:             '#FF1493',
    deepskyblue:          '#00BFFF',
    dimgray:              '#696969',
    dimgrey:              '#696969',
    dodgerblue:           '#1E90FF',
    firebrick:            '#B22222',
    floralwhite:          '#FFFAF0',
    forestgreen:          '#228B22',
    fuchsia:              '#FF00FF',
    gainsboro:            '#DCDCDC',
    ghostwhite:           '#F8F8FF',
    gold:                 '#FFD700',
    goldenrod:            '#DAA520',
    gray:                 '#808080',
    grey:                 '#808080',
    green:                '#008000',
    greenyellow:          '#ADFF2F',
    honeydew:             '#F0FFF0',
    hotpink:              '#FF69B4',
    indianred:            '#CD5C5C',
    indigo:               '#4B0082',
    ivory:                '#FFFFF0',
    khaki:                '#F0E68C',
    lavender:             '#E6E6FA',
    lavenderblush:        '#FFF0F5',
    lawngreen:            '#7CFC00',
    lemonchiffon:         '#FFFACD',
    lightblue:            '#ADD8E6',
    lightcoral:           '#F08080',
    lightcyan:            '#E0FFFF',
    lightgoldenrodyellow: '#FAFAD2',
    lightgray:            '#D3D3D3',
    lightgrey:            '#D3D3D3',
    lightgreen:           '#90EE90',
    lightpink:            '#FFB6C1',
    lightsalmon:          '#FFA07A',
    lightseagreen:        '#20B2AA',
    lightskyblue:         '#87CEFA',
    lightslategray:       '#778899',
    lightslategrey:       '#778899',
    lightsteelblue:       '#B0C4DE',
    lightyellow:          '#FFFFE0',
    lime:                 '#00FF00',
    limegreen:            '#32CD32',
    linen:                '#FAF0E6',
    magenta:              '#FF00FF',
    maroon:               '#800000',
    mediumaquamarine:     '#66CDAA',
    mediumblue:           '#0000CD',
    mediumorchid:         '#BA55D3',
    mediumpurple:         '#9370DB',
    mediumseagreen:       '#3CB371',
    mediumslateblue:      '#7B68EE',
    mediumspringgreen:    '#00FA9A',
    mediumturquoise:      '#48D1CC',
    mediumvioletred:      '#C71585',
    midnightblue:         '#191970',
    mintcream:            '#F5FFFA',
    mistyrose:            '#FFE4E1',
    moccasin:             '#FFE4B5',
    navajowhite:          '#FFDEAD',
    navy:                 '#000080',
    oldlace:              '#FDF5E6',
    olive:                '#808000',
    olivedrab:            '#6B8E23',
    orange:               '#FFA500',
    orangered:            '#FF4500',
    orchid:               '#DA70D6',
    palegoldenrod:        '#EEE8AA',
    palegreen:            '#98FB98',
    paleturquoise:        '#AFEEEE',
    palevioletred:        '#DB7093',
    papayawhip:           '#FFEFD5',
    peachpuff:            '#FFDAB9',
    peru:                 '#CD853F',
    pink:                 '#FFC0CB',
    plum:                 '#DDA0DD',
    powderblue:           '#B0E0E6',
    purple:               '#800080',
    rebeccapurple:        '#663399',
    red:                  '#FF0000',
    rosybrown:            '#BC8F8F',
    royalblue:            '#4169E1',
    saddlebrown:          '#8B4513',
    salmon:               '#FA8072',
    sandybrown:           '#F4A460',
    seagreen:             '#2E8B57',
    seashell:             '#FFF5EE',
    sienna:               '#A0522D',
    silver:               '#C0C0C0',
    skyblue:              '#87CEEB',
    slateblue:            '#6A5ACD',
    slategray:            '#708090',
    slategrey:            '#708090',
    snow:                 '#FFFAFA',
    springgreen:          '#00FF7F',
    steelblue:            '#4682B4',
    tan:                  '#D2B48C',
    teal:                 '#008080',
    thistle:              '#D8BFD8',
    tomato:               '#FF6347',
    turquoise:            '#40E0D0',
    violet:               '#EE82EE',
    wheat:                '#F5DEB3',
    white:                '#FFFFFF',
    whitesmoke:           '#F5F5F5',
    yellow:               '#FFFF00',
    yellowgreen:          '#9ACD32'
  };

  /**
   * @private
   * @param {Number} p
   * @param {Number} q
   * @param {Number} t
   * @return {Number}
   */
  function hue2rgb(p, q, t) {
    if (t < 0) {
      t += 1;
    }
    if (t > 1) {
      t -= 1;
    }
    if (t < 1 / 6) {
      return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
      return q;
    }
    if (t < 2 / 3) {
      return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
  }

  /**
   * Returns new color object, when given a color in RGB format
   * @memberOf fabric.Color
   * @param {String} color Color value ex: rgb(0-255,0-255,0-255)
   * @return {fabric.Color}
   */
  fabric.Color.fromRgb = function(color) {
    return Color.fromSource(Color.sourceFromRgb(color));
  };

  /**
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in RGB or RGBA format
   * @memberOf fabric.Color
   * @param {String} color Color value ex: rgb(0-255,0-255,0-255), rgb(0%-100%,0%-100%,0%-100%)
   * @return {Array} source
   */
  fabric.Color.sourceFromRgb = function(color) {
    var match = color.match(Color.reRGBa);
    if (match) {
      var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1),
          g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1),
          b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);

      return [
        parseInt(r, 10),
        parseInt(g, 10),
        parseInt(b, 10),
        match[4] ? parseFloat(match[4]) : 1
      ];
    }
  };

  /**
   * Returns new color object, when given a color in RGBA format
   * @static
   * @function
   * @memberOf fabric.Color
   * @param {String} color
   * @return {fabric.Color}
   */
  fabric.Color.fromRgba = Color.fromRgb;

  /**
   * Returns new color object, when given a color in HSL format
   * @param {String} color Color value ex: hsl(0-260,0%-100%,0%-100%)
   * @memberOf fabric.Color
   * @return {fabric.Color}
   */
  fabric.Color.fromHsl = function(color) {
    return Color.fromSource(Color.sourceFromHsl(color));
  };

  /**
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HSL or HSLA format.
   * Adapted from <a href="https://rawgithub.com/mjijackson/mjijackson.github.com/master/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript.html">https://github.com/mjijackson</a>
   * @memberOf fabric.Color
   * @param {String} color Color value ex: hsl(0-360,0%-100%,0%-100%) or hsla(0-360,0%-100%,0%-100%, 0-1)
   * @return {Array} source
   * @see http://http://www.w3.org/TR/css3-color/#hsl-color
   */
  fabric.Color.sourceFromHsl = function(color) {
    var match = color.match(Color.reHSLa);
    if (!match) {
      return;
    }

    var h = (((parseFloat(match[1]) % 360) + 360) % 360) / 360,
        s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1),
        l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1),
        r, g, b;

    if (s === 0) {
      r = g = b = l;
    }
    else {
      var q = l <= 0.5 ? l * (s + 1) : l + s - l * s,
          p = l * 2 - q;

      r = hue2rgb(p, q, h + 1 / 3);
      g = hue2rgb(p, q, h);
      b = hue2rgb(p, q, h - 1 / 3);
    }

    return [
      Math.round(r * 255),
      Math.round(g * 255),
      Math.round(b * 255),
      match[4] ? parseFloat(match[4]) : 1
    ];
  };

  /**
   * Returns new color object, when given a color in HSLA format
   * @static
   * @function
   * @memberOf fabric.Color
   * @param {String} color
   * @return {fabric.Color}
   */
  fabric.Color.fromHsla = Color.fromHsl;

  /**
   * Returns new color object, when given a color in HEX format
   * @static
   * @memberOf fabric.Color
   * @param {String} color Color value ex: FF5555
   * @return {fabric.Color}
   */
  fabric.Color.fromHex = function(color) {
    return Color.fromSource(Color.sourceFromHex(color));
  };

  /**
   * Returns array representation (ex: [100, 100, 200, 1]) of a color that's in HEX format
   * @static
   * @memberOf fabric.Color
   * @param {String} color ex: FF5555 or FF5544CC (RGBa)
   * @return {Array} source
   */
  fabric.Color.sourceFromHex = function(color) {
    if (color.match(Color.reHex)) {
      var value = color.slice(color.indexOf('#') + 1),
          isShortNotation = (value.length === 3 || value.length === 4),
          isRGBa = (value.length === 8 || value.length === 4),
          r = isShortNotation ? (value.charAt(0) + value.charAt(0)) : value.substring(0, 2),
          g = isShortNotation ? (value.charAt(1) + value.charAt(1)) : value.substring(2, 4),
          b = isShortNotation ? (value.charAt(2) + value.charAt(2)) : value.substring(4, 6),
          a = isRGBa ? (isShortNotation ? (value.charAt(3) + value.charAt(3)) : value.substring(6, 8)) : 'FF';

      return [
        parseInt(r, 16),
        parseInt(g, 16),
        parseInt(b, 16),
        parseFloat((parseInt(a, 16) / 255).toFixed(2))
      ];
    }
  };

  /**
   * Returns new color object, when given color in array representation (ex: [200, 100, 100, 0.5])
   * @static
   * @memberOf fabric.Color
   * @param {Array} source
   * @return {fabric.Color}
   */
  fabric.Color.fromSource = function(source) {
    var oColor = new Color();
    oColor.setSource(source);
    return oColor;
  };

})( true ? exports : this);


(function() {

  /* _FROM_SVG_START_ */
  function getColorStop(el) {
    var style = el.getAttribute('style'),
        offset = el.getAttribute('offset') || 0,
        color, colorAlpha, opacity, i;

    // convert percents to absolute values
    offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);
    offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;
    if (style) {
      var keyValuePairs = style.split(/\s*;\s*/);

      if (keyValuePairs[keyValuePairs.length - 1] === '') {
        keyValuePairs.pop();
      }

      for (i = keyValuePairs.length; i--; ) {

        var split = keyValuePairs[i].split(/\s*:\s*/),
            key = split[0].trim(),
            value = split[1].trim();

        if (key === 'stop-color') {
          color = value;
        }
        else if (key === 'stop-opacity') {
          opacity = value;
        }
      }
    }

    if (!color) {
      color = el.getAttribute('stop-color') || 'rgb(0,0,0)';
    }
    if (!opacity) {
      opacity = el.getAttribute('stop-opacity');
    }

    color = new fabric.Color(color);
    colorAlpha = color.getAlpha();
    opacity = isNaN(parseFloat(opacity)) ? 1 : parseFloat(opacity);
    opacity *= colorAlpha;

    return {
      offset: offset,
      color: color.toRgb(),
      opacity: opacity
    };
  }

  function getLinearCoords(el) {
    return {
      x1: el.getAttribute('x1') || 0,
      y1: el.getAttribute('y1') || 0,
      x2: el.getAttribute('x2') || '100%',
      y2: el.getAttribute('y2') || 0
    };
  }

  function getRadialCoords(el) {
    return {
      x1: el.getAttribute('fx') || el.getAttribute('cx') || '50%',
      y1: el.getAttribute('fy') || el.getAttribute('cy') || '50%',
      r1: 0,
      x2: el.getAttribute('cx') || '50%',
      y2: el.getAttribute('cy') || '50%',
      r2: el.getAttribute('r') || '50%'
    };
  }
  /* _FROM_SVG_END_ */

  var clone = fabric.util.object.clone;

  /**
   * Gradient class
   * @class fabric.Gradient
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#gradients}
   * @see {@link fabric.Gradient#initialize} for constructor definition
   */
  fabric.Gradient = fabric.util.createClass(/** @lends fabric.Gradient.prototype */ {

    /**
     * Horizontal offset for aligning gradients coming from SVG when outside pathgroups
     * @type Number
     * @default 0
     */
    offsetX: 0,

    /**
     * Vertical offset for aligning gradients coming from SVG when outside pathgroups
     * @type Number
     * @default 0
     */
    offsetY: 0,

    /**
     * Constructor
     * @param {Object} [options] Options object with type, coords, gradientUnits and colorStops
     * @return {fabric.Gradient} thisArg
     */
    initialize: function(options) {
      options || (options = { });

      var coords = { };

      this.id = fabric.Object.__uid++;
      this.type = options.type || 'linear';

      coords = {
        x1: options.coords.x1 || 0,
        y1: options.coords.y1 || 0,
        x2: options.coords.x2 || 0,
        y2: options.coords.y2 || 0
      };

      if (this.type === 'radial') {
        coords.r1 = options.coords.r1 || 0;
        coords.r2 = options.coords.r2 || 0;
      }
      this.coords = coords;
      this.colorStops = options.colorStops.slice();
      if (options.gradientTransform) {
        this.gradientTransform = options.gradientTransform;
      }
      this.offsetX = options.offsetX || this.offsetX;
      this.offsetY = options.offsetY || this.offsetY;
    },

    /**
     * Adds another colorStop
     * @param {Object} colorStop Object with offset and color
     * @return {fabric.Gradient} thisArg
     */
    addColorStop: function(colorStops) {
      for (var position in colorStops) {
        var color = new fabric.Color(colorStops[position]);
        this.colorStops.push({
          offset: parseFloat(position),
          color: color.toRgb(),
          opacity: color.getAlpha()
        });
      }
      return this;
    },

    /**
     * Returns object representation of a gradient
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object}
     */
    toObject: function(propertiesToInclude) {
      var object = {
        type: this.type,
        coords: this.coords,
        colorStops: this.colorStops,
        offsetX: this.offsetX,
        offsetY: this.offsetY,
        gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform
      };
      fabric.util.populateWithProperties(this, object, propertiesToInclude);

      return object;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of an gradient
     * @param {Object} object Object to create a gradient for
     * @return {String} SVG representation of an gradient (linear/radial)
     */
    toSVG: function(object) {
      var coords = clone(this.coords, true), i, len,
          markup, commonAttributes, colorStops = clone(this.colorStops, true),
          needsSwap = coords.r1 > coords.r2;
      // colorStops must be sorted ascending
      colorStops.sort(function(a, b) {
        return a.offset - b.offset;
      });

      for (var prop in coords) {
        if (prop === 'x1' || prop === 'x2') {
          coords[prop] += this.offsetX - object.width / 2;
        }
        else if (prop === 'y1' || prop === 'y2') {
          coords[prop] += this.offsetY - object.height / 2;
        }
      }

      commonAttributes = 'id="SVGID_' + this.id +
                     '" gradientUnits="userSpaceOnUse"';
      if (this.gradientTransform) {
        commonAttributes += ' gradientTransform="matrix(' + this.gradientTransform.join(' ') + ')" ';
      }
      if (this.type === 'linear') {
        markup = [
          '<linearGradient ',
          commonAttributes,
          ' x1="', coords.x1,
          '" y1="', coords.y1,
          '" x2="', coords.x2,
          '" y2="', coords.y2,
          '">\n'
        ];
      }
      else if (this.type === 'radial') {
        // svg radial gradient has just 1 radius. the biggest.
        markup = [
          '<radialGradient ',
          commonAttributes,
          ' cx="', needsSwap ? coords.x1 : coords.x2,
          '" cy="', needsSwap ? coords.y1 : coords.y2,
          '" r="', needsSwap ? coords.r1 : coords.r2,
          '" fx="', needsSwap ? coords.x2 : coords.x1,
          '" fy="', needsSwap ? coords.y2 : coords.y1,
          '">\n'
        ];
      }

      if (this.type === 'radial') {
        if (needsSwap) {
          // svg goes from internal to external radius. if radius are inverted, swap color stops.
          colorStops = colorStops.concat();
          colorStops.reverse();
          for (i = 0, len = colorStops.length; i < len; i++) {
            colorStops[i].offset = 1 - colorStops[i].offset;
          }
        }
        var minRadius = Math.min(coords.r1, coords.r2);
        if (minRadius > 0) {
          // i have to shift all colorStops and add new one in 0.
          var maxRadius = Math.max(coords.r1, coords.r2),
              percentageShift = minRadius / maxRadius;
          for (i = 0, len = colorStops.length; i < len; i++) {
            colorStops[i].offset += percentageShift * (1 - colorStops[i].offset);
          }
        }
      }

      for (i = 0, len = colorStops.length; i < len; i++) {
        var colorStop = colorStops[i];
        markup.push(
          '<stop ',
            'offset="', (colorStop.offset * 100) + '%',
            '" style="stop-color:', colorStop.color,
            (colorStop.opacity !== null ? ';stop-opacity: ' + colorStop.opacity : ';'),
          '"/>\n'
        );
      }

      markup.push((this.type === 'linear' ? '</linearGradient>\n' : '</radialGradient>\n'));

      return markup.join('');
    },
    /* _TO_SVG_END_ */

    /**
     * Returns an instance of CanvasGradient
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @return {CanvasGradient}
     */
    toLive: function(ctx) {
      var gradient, coords = fabric.util.object.clone(this.coords), i, len;

      if (!this.type) {
        return;
      }

      if (this.type === 'linear') {
        gradient = ctx.createLinearGradient(
          coords.x1, coords.y1, coords.x2, coords.y2);
      }
      else if (this.type === 'radial') {
        gradient = ctx.createRadialGradient(
          coords.x1, coords.y1, coords.r1, coords.x2, coords.y2, coords.r2);
      }

      for (i = 0, len = this.colorStops.length; i < len; i++) {
        var color = this.colorStops[i].color,
            opacity = this.colorStops[i].opacity,
            offset = this.colorStops[i].offset;

        if (typeof opacity !== 'undefined') {
          color = new fabric.Color(color).setAlpha(opacity).toRgba();
        }
        gradient.addColorStop(offset, color);
      }

      return gradient;
    }
  });

  fabric.util.object.extend(fabric.Gradient, {

    /* _FROM_SVG_START_ */
    /**
     * Returns {@link fabric.Gradient} instance from an SVG element
     * @static
     * @memberOf fabric.Gradient
     * @param {SVGGradientElement} el SVG gradient element
     * @param {fabric.Object} instance
     * @return {fabric.Gradient} Gradient instance
     * @see http://www.w3.org/TR/SVG/pservers.html#LinearGradientElement
     * @see http://www.w3.org/TR/SVG/pservers.html#RadialGradientElement
     */
    fromElement: function(el, instance) {

      /**
       *  @example:
       *
       *  <linearGradient id="linearGrad1">
       *    <stop offset="0%" stop-color="white"/>
       *    <stop offset="100%" stop-color="black"/>
       *  </linearGradient>
       *
       *  OR
       *
       *  <linearGradient id="linearGrad2">
       *    <stop offset="0" style="stop-color:rgb(255,255,255)"/>
       *    <stop offset="1" style="stop-color:rgb(0,0,0)"/>
       *  </linearGradient>
       *
       *  OR
       *
       *  <radialGradient id="radialGrad1">
       *    <stop offset="0%" stop-color="white" stop-opacity="1" />
       *    <stop offset="50%" stop-color="black" stop-opacity="0.5" />
       *    <stop offset="100%" stop-color="white" stop-opacity="1" />
       *  </radialGradient>
       *
       *  OR
       *
       *  <radialGradient id="radialGrad2">
       *    <stop offset="0" stop-color="rgb(255,255,255)" />
       *    <stop offset="0.5" stop-color="rgb(0,0,0)" />
       *    <stop offset="1" stop-color="rgb(255,255,255)" />
       *  </radialGradient>
       *
       */

      var colorStopEls = el.getElementsByTagName('stop'),
          type,
          gradientUnits = el.getAttribute('gradientUnits') || 'objectBoundingBox',
          gradientTransform = el.getAttribute('gradientTransform'),
          colorStops = [],
          coords, ellipseMatrix, i;

      if (el.nodeName === 'linearGradient' || el.nodeName === 'LINEARGRADIENT') {
        type = 'linear';
      }
      else {
        type = 'radial';
      }

      if (type === 'linear') {
        coords = getLinearCoords(el);
      }
      else if (type === 'radial') {
        coords = getRadialCoords(el);
      }

      for (i = colorStopEls.length; i--; ) {
        colorStops.push(getColorStop(colorStopEls[i]));
      }

      ellipseMatrix = _convertPercentUnitsToValues(instance, coords, gradientUnits);

      var gradient = new fabric.Gradient({
        type: type,
        coords: coords,
        colorStops: colorStops,
        offsetX: -instance.left,
        offsetY: -instance.top
      });

      if (gradientTransform || ellipseMatrix !== '') {
        gradient.gradientTransform = fabric.parseTransformAttribute((gradientTransform || '') + ellipseMatrix);
      }

      return gradient;
    },
    /* _FROM_SVG_END_ */

    /**
     * Returns {@link fabric.Gradient} instance from its object representation
     * @static
     * @memberOf fabric.Gradient
     * @param {Object} obj
     * @param {Object} [options] Options object
     */
    forObject: function(obj, options) {
      options || (options = { });
      _convertPercentUnitsToValues(obj, options.coords, 'userSpaceOnUse');
      return new fabric.Gradient(options);
    }
  });

  /**
   * @private
   */
  function _convertPercentUnitsToValues(object, options, gradientUnits) {
    var propValue, addFactor = 0, multFactor = 1, ellipseMatrix = '';
    for (var prop in options) {
      if (options[prop] === 'Infinity') {
        options[prop] = 1;
      }
      else if (options[prop] === '-Infinity') {
        options[prop] = 0;
      }
      propValue = parseFloat(options[prop], 10);
      if (typeof options[prop] === 'string' && /^\d+%$/.test(options[prop])) {
        multFactor = 0.01;
      }
      else {
        multFactor = 1;
      }
      if (prop === 'x1' || prop === 'x2' || prop === 'r2') {
        multFactor *= gradientUnits === 'objectBoundingBox' ? object.width : 1;
        addFactor = gradientUnits === 'objectBoundingBox' ? object.left || 0 : 0;
      }
      else if (prop === 'y1' || prop === 'y2') {
        multFactor *= gradientUnits === 'objectBoundingBox' ? object.height : 1;
        addFactor = gradientUnits === 'objectBoundingBox' ? object.top || 0 : 0;
      }
      options[prop] = propValue * multFactor + addFactor;
    }
    if (object.type === 'ellipse' &&
        options.r2 !== null &&
        gradientUnits === 'objectBoundingBox' &&
        object.rx !== object.ry) {

      var scaleFactor = object.ry / object.rx;
      ellipseMatrix = ' scale(1, ' + scaleFactor + ')';
      if (options.y1) {
        options.y1 /= scaleFactor;
      }
      if (options.y2) {
        options.y2 /= scaleFactor;
      }
    }
    return ellipseMatrix;
  }
})();


(function() {

  'use strict';

  var toFixed = fabric.util.toFixed;

  /**
   * Pattern class
   * @class fabric.Pattern
   * @see {@link http://fabricjs.com/patterns|Pattern demo}
   * @see {@link http://fabricjs.com/dynamic-patterns|DynamicPattern demo}
   * @see {@link fabric.Pattern#initialize} for constructor definition
   */


  fabric.Pattern = fabric.util.createClass(/** @lends fabric.Pattern.prototype */ {

    /**
     * Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
     * @type String
     * @default
     */
    repeat: 'repeat',

    /**
     * Pattern horizontal offset from object's left/top corner
     * @type Number
     * @default
     */
    offsetX: 0,

    /**
     * Pattern vertical offset from object's left/top corner
     * @type Number
     * @default
     */
    offsetY: 0,

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @param {Function} [callback] function to invoke after callback init.
     * @return {fabric.Pattern} thisArg
     */
    initialize: function(options, callback) {
      options || (options = { });

      this.id = fabric.Object.__uid++;
      this.setOptions(options);
      if (!options.source || (options.source && typeof options.source !== 'string')) {
        callback && callback(this);
        return;
      }
      // function string
      if (typeof fabric.util.getFunctionBody(options.source) !== 'undefined') {
        this.source = new Function(fabric.util.getFunctionBody(options.source));
        callback && callback(this);
      }
      else {
        // img src string
        var _this = this;
        this.source = fabric.util.createImage();
        fabric.util.loadImage(options.source, function(img) {
          _this.source = img;
          callback && callback(_this);
        });
      }
    },

    /**
     * Returns object representation of a pattern
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of a pattern instance
     */
    toObject: function(propertiesToInclude) {
      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
          source, object;

      // callback
      if (typeof this.source === 'function') {
        source = String(this.source);
      }
      // <img> element
      else if (typeof this.source.src === 'string') {
        source = this.source.src;
      }
      // <canvas> element
      else if (typeof this.source === 'object' && this.source.toDataURL) {
        source = this.source.toDataURL();
      }

      object = {
        type: 'pattern',
        source: source,
        repeat: this.repeat,
        offsetX: toFixed(this.offsetX, NUM_FRACTION_DIGITS),
        offsetY: toFixed(this.offsetY, NUM_FRACTION_DIGITS),
      };
      fabric.util.populateWithProperties(this, object, propertiesToInclude);

      return object;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of a pattern
     * @param {fabric.Object} object
     * @return {String} SVG representation of a pattern
     */
    toSVG: function(object) {
      var patternSource = typeof this.source === 'function' ? this.source() : this.source,
          patternWidth = patternSource.width / object.width,
          patternHeight = patternSource.height / object.height,
          patternOffsetX = this.offsetX / object.width,
          patternOffsetY = this.offsetY / object.height,
          patternImgSrc = '';
      if (this.repeat === 'repeat-x' || this.repeat === 'no-repeat') {
        patternHeight = 1;
      }
      if (this.repeat === 'repeat-y' || this.repeat === 'no-repeat') {
        patternWidth = 1;
      }
      if (patternSource.src) {
        patternImgSrc = patternSource.src;
      }
      else if (patternSource.toDataURL) {
        patternImgSrc = patternSource.toDataURL();
      }

      return '<pattern id="SVGID_' + this.id +
                    '" x="' + patternOffsetX +
                    '" y="' + patternOffsetY +
                    '" width="' + patternWidth +
                    '" height="' + patternHeight + '">\n' +
               '<image x="0" y="0"' +
                      ' width="' + patternSource.width +
                      '" height="' + patternSource.height +
                      '" xlink:href="' + patternImgSrc +
               '"></image>\n' +
             '</pattern>\n';
    },
    /* _TO_SVG_END_ */

    setOptions: function(options) {
      for (var prop in options) {
        this[prop] = options[prop];
      }
    },

    /**
     * Returns an instance of CanvasPattern
     * @param {CanvasRenderingContext2D} ctx Context to create pattern
     * @return {CanvasPattern}
     */
    toLive: function(ctx) {
      var source = typeof this.source === 'function' ? this.source() : this.source;

      // if the image failed to load, return, and allow rest to continue loading
      if (!source) {
        return '';
      }

      // if an image
      if (typeof source.src !== 'undefined') {
        if (!source.complete) {
          return '';
        }
        if (source.naturalWidth === 0 || source.naturalHeight === 0) {
          return '';
        }
      }
      return ctx.createPattern(source, this.repeat);
    }
  });
})();


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      toFixed = fabric.util.toFixed;

  if (fabric.Shadow) {
    fabric.warn('fabric.Shadow is already defined.');
    return;
  }

  /**
   * Shadow class
   * @class fabric.Shadow
   * @see {@link http://fabricjs.com/shadows|Shadow demo}
   * @see {@link fabric.Shadow#initialize} for constructor definition
   */
  fabric.Shadow = fabric.util.createClass(/** @lends fabric.Shadow.prototype */ {

    /**
     * Shadow color
     * @type String
     * @default
     */
    color: 'rgb(0,0,0)',

    /**
     * Shadow blur
     * @type Number
     */
    blur: 0,

    /**
     * Shadow horizontal offset
     * @type Number
     * @default
     */
    offsetX: 0,

    /**
     * Shadow vertical offset
     * @type Number
     * @default
     */
    offsetY: 0,

    /**
     * Whether the shadow should affect stroke operations
     * @type Boolean
     * @default
     */
    affectStroke: false,

    /**
     * Indicates whether toObject should include default values
     * @type Boolean
     * @default
     */
    includeDefaultValues: true,

    /**
     * Constructor
     * @param {Object|String} [options] Options object with any of color, blur, offsetX, offsetX properties or string (e.g. "rgba(0,0,0,0.2) 2px 2px 10px, "2px 2px 10px rgba(0,0,0,0.2)")
     * @return {fabric.Shadow} thisArg
     */
    initialize: function(options) {

      if (typeof options === 'string') {
        options = this._parseShadow(options);
      }

      for (var prop in options) {
        this[prop] = options[prop];
      }

      this.id = fabric.Object.__uid++;
    },

    /**
     * @private
     * @param {String} shadow Shadow value to parse
     * @return {Object} Shadow object with color, offsetX, offsetY and blur
     */
    _parseShadow: function(shadow) {
      var shadowStr = shadow.trim(),
          offsetsAndBlur = fabric.Shadow.reOffsetsAndBlur.exec(shadowStr) || [],
          color = shadowStr.replace(fabric.Shadow.reOffsetsAndBlur, '') || 'rgb(0,0,0)';

      return {
        color: color.trim(),
        offsetX: parseInt(offsetsAndBlur[1], 10) || 0,
        offsetY: parseInt(offsetsAndBlur[2], 10) || 0,
        blur: parseInt(offsetsAndBlur[3], 10) || 0
      };
    },

    /**
     * Returns a string representation of an instance
     * @see http://www.w3.org/TR/css-text-decor-3/#text-shadow
     * @return {String} Returns CSS3 text-shadow declaration
     */
    toString: function() {
      return [this.offsetX, this.offsetY, this.blur, this.color].join('px ');
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of a shadow
     * @param {fabric.Object} object
     * @return {String} SVG representation of a shadow
     */
    toSVG: function(object) {
      var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,
          offset = fabric.util.rotateVector(
            { x: this.offsetX, y: this.offsetY },
            fabric.util.degreesToRadians(-object.angle)),
          BLUR_BOX = 20;

      if (object.width && object.height) {
        //http://www.w3.org/TR/SVG/filters.html#FilterEffectsRegion
        // we add some extra space to filter box to contain the blur ( 20 )
        fBoxX = toFixed((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
        fBoxY = toFixed((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
      }
      if (object.flipX) {
        offset.x *= -1;
      }
      if (object.flipY) {
        offset.y *= -1;
      }
      return (
        '<filter id="SVGID_' + this.id + '" y="-' + fBoxY + '%" height="' + (100 + 2 * fBoxY) + '%" ' +
          'x="-' + fBoxX + '%" width="' + (100 + 2 * fBoxX) + '%" ' + '>\n' +
          '\t<feGaussianBlur in="SourceAlpha" stdDeviation="' +
            toFixed(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '"></feGaussianBlur>\n' +
          '\t<feOffset dx="' + toFixed(offset.x, NUM_FRACTION_DIGITS) +
          '" dy="' + toFixed(offset.y, NUM_FRACTION_DIGITS) + '" result="oBlur" ></feOffset>\n' +
          '\t<feFlood flood-color="' + this.color + '"/>\n' +
          '\t<feComposite in2="oBlur" operator="in" />\n' +
          '\t<feMerge>\n' +
            '\t\t<feMergeNode></feMergeNode>\n' +
            '\t\t<feMergeNode in="SourceGraphic"></feMergeNode>\n' +
          '\t</feMerge>\n' +
        '</filter>\n');
    },
    /* _TO_SVG_END_ */

    /**
     * Returns object representation of a shadow
     * @return {Object} Object representation of a shadow instance
     */
    toObject: function() {
      if (this.includeDefaultValues) {
        return {
          color: this.color,
          blur: this.blur,
          offsetX: this.offsetX,
          offsetY: this.offsetY,
          affectStroke: this.affectStroke
        };
      }
      var obj = { }, proto = fabric.Shadow.prototype;

      ['color', 'blur', 'offsetX', 'offsetY', 'affectStroke'].forEach(function(prop) {
        if (this[prop] !== proto[prop]) {
          obj[prop] = this[prop];
        }
      }, this);

      return obj;
    }
  });

  /**
   * Regex matching shadow offsetX, offsetY and blur (ex: "2px 2px 10px rgba(0,0,0,0.2)", "rgb(0,255,0) 2px 2px")
   * @static
   * @field
   * @memberOf fabric.Shadow
   */
  // eslint-disable-next-line max-len
  fabric.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:px)?(?:\s?|$))?(-?\d+(?:px)?(?:\s?|$))?(\d+(?:px)?)?(?:\s?|$)(?:$|\s)/;

})( true ? exports : this);


(function () {

  'use strict';

  if (fabric.StaticCanvas) {
    fabric.warn('fabric.StaticCanvas is already defined.');
    return;
  }

  // aliases for faster resolution
  var extend = fabric.util.object.extend,
      getElementOffset = fabric.util.getElementOffset,
      removeFromArray = fabric.util.removeFromArray,
      toFixed = fabric.util.toFixed,
      transformPoint = fabric.util.transformPoint,
      invertTransform = fabric.util.invertTransform,

      CANVAS_INIT_ERROR = new Error('Could not initialize `canvas` element');

  /**
   * Static canvas class
   * @class fabric.StaticCanvas
   * @mixes fabric.Collection
   * @mixes fabric.Observable
   * @see {@link http://fabricjs.com/static_canvas|StaticCanvas demo}
   * @see {@link fabric.StaticCanvas#initialize} for constructor definition
   * @fires before:render
   * @fires after:render
   * @fires canvas:cleared
   * @fires object:added
   * @fires object:removed
   */
  fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Constructor
     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(el, options) {
      options || (options = { });
      this.renderAndResetBound = this.renderAndReset.bind(this);
      this.requestRenderAllBound = this.requestRenderAll.bind(this);
      this._initStatic(el, options);
    },

    /**
     * Background color of canvas instance.
     * Should be set via {@link fabric.StaticCanvas#setBackgroundColor}.
     * @type {(String|fabric.Pattern)}
     * @default
     */
    backgroundColor: '',

    /**
     * Background image of canvas instance.
     * Should be set via {@link fabric.StaticCanvas#setBackgroundImage}.
     * <b>Backwards incompatibility note:</b> The "backgroundImageOpacity"
     * and "backgroundImageStretch" properties are deprecated since 1.3.9.
     * Use {@link fabric.Image#opacity}, {@link fabric.Image#width} and {@link fabric.Image#height}.
     * @type fabric.Image
     * @default
     */
    backgroundImage: null,

    /**
     * Overlay color of canvas instance.
     * Should be set via {@link fabric.StaticCanvas#setOverlayColor}
     * @since 1.3.9
     * @type {(String|fabric.Pattern)}
     * @default
     */
    overlayColor: '',

    /**
     * Overlay image of canvas instance.
     * Should be set via {@link fabric.StaticCanvas#setOverlayImage}.
     * <b>Backwards incompatibility note:</b> The "overlayImageLeft"
     * and "overlayImageTop" properties are deprecated since 1.3.9.
     * Use {@link fabric.Image#left} and {@link fabric.Image#top}.
     * @type fabric.Image
     * @default
     */
    overlayImage: null,

    /**
     * Indicates whether toObject/toDatalessObject should include default values
     * @type Boolean
     * @default
     */
    includeDefaultValues: true,

    /**
     * Indicates whether objects' state should be saved
     * @type Boolean
     * @default
     */
    stateful: false,

    /**
     * Indicates whether {@link fabric.Collection.add}, {@link fabric.Collection.insertAt} and {@link fabric.Collection.remove},
     * {@link fabric.StaticCanvas.moveTo}, {@link fabric.StaticCanvas.clear} and many more, should also re-render canvas.
     * Disabling this option will not give a performance boost when adding/removing a lot of objects to/from canvas at once
     * since the renders are quequed and executed one per frame.
     * Disabling is suggested anyway and managing the renders of the app manually is not a big effort ( canvas.requestRenderAll() )
     * Left default to true to do not break documentation and old app, fiddles.
     * @type Boolean
     * @default
     */
    renderOnAddRemove: true,

    /**
     * Function that determines clipping of entire canvas area
     * Being passed context as first argument. See clipping canvas area in {@link https://github.com/kangax/fabric.js/wiki/FAQ}
     * @deprecated since 2.0.0
     * @type Function
     * @default
     */
    clipTo: null,

    /**
     * Indicates whether object controls (borders/controls) are rendered above overlay image
     * @type Boolean
     * @default
     */
    controlsAboveOverlay: false,

    /**
     * Indicates whether the browser can be scrolled when using a touchscreen and dragging on the canvas
     * @type Boolean
     * @default
     */
    allowTouchScrolling: false,

    /**
     * Indicates whether this canvas will use image smoothing, this is on by default in browsers
     * @type Boolean
     * @default
     */
    imageSmoothingEnabled: true,

    /**
     * The transformation (in the format of Canvas transform) which focuses the viewport
     * @type Array
     * @default
     */
    viewportTransform: fabric.iMatrix.concat(),

    /**
     * if set to false background image is not affected by viewport transform
     * @since 1.6.3
     * @type Boolean
     * @default
     */
    backgroundVpt: true,

    /**
     * if set to false overlya image is not affected by viewport transform
     * @since 1.6.3
     * @type Boolean
     * @default
     */
    overlayVpt: true,

    /**
     * Callback; invoked right before object is about to be scaled/rotated
     */
    onBeforeScaleRotate: function () {
      /* NOOP */
    },

    /**
     * When true, canvas is scaled by devicePixelRatio for better rendering on retina screens
     * @type Boolean
     * @default
     */
    enableRetinaScaling: true,

    /**
     * Describe canvas element extension over design
     * properties are tl,tr,bl,br.
     * if canvas is not zoomed/panned those points are the four corner of canvas
     * if canvas is viewportTransformed you those points indicate the extension
     * of canvas element in plain untrasformed coordinates
     * The coordinates get updated with @method calcViewportBoundaries.
     * @memberOf fabric.StaticCanvas.prototype
     */
    vptCoords: { },

    /**
     * Based on vptCoords and object.aCoords, skip rendering of objects that
     * are not included in current viewport.
     * May greatly help in applications with crowded canvas and use of zoom/pan
     * If One of the corner of the bounding box of the object is on the canvas
     * the objects get rendered.
     * @memberOf fabric.StaticCanvas.prototype
     * @type Boolean
     * @default
     */
    skipOffscreen: true,

    /**
     * @private
     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
     * @param {Object} [options] Options object
     */
    _initStatic: function(el, options) {
      var cb = this.requestRenderAllBound;
      this._objects = [];
      this._createLowerCanvas(el);
      this._initOptions(options);
      this._setImageSmoothing();
      // only initialize retina scaling once
      if (!this.interactive) {
        this._initRetinaScaling();
      }

      if (options.overlayImage) {
        this.setOverlayImage(options.overlayImage, cb);
      }
      if (options.backgroundImage) {
        this.setBackgroundImage(options.backgroundImage, cb);
      }
      if (options.backgroundColor) {
        this.setBackgroundColor(options.backgroundColor, cb);
      }
      if (options.overlayColor) {
        this.setOverlayColor(options.overlayColor, cb);
      }
      this.calcOffset();
    },

    /**
     * @private
     */
    _isRetinaScaling: function() {
      return (fabric.devicePixelRatio !== 1 && this.enableRetinaScaling);
    },

    /**
     * @private
     * @return {Number} retinaScaling if applied, otherwise 1;
     */
    getRetinaScaling: function() {
      return this._isRetinaScaling() ? fabric.devicePixelRatio : 1;
    },

    /**
     * @private
     */
    _initRetinaScaling: function() {
      if (!this._isRetinaScaling()) {
        return;
      }
      this.lowerCanvasEl.setAttribute('width', this.width * fabric.devicePixelRatio);
      this.lowerCanvasEl.setAttribute('height', this.height * fabric.devicePixelRatio);

      this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio);
    },

    /**
     * Calculates canvas element offset relative to the document
     * This method is also attached as "resize" event handler of window
     * @return {fabric.Canvas} instance
     * @chainable
     */
    calcOffset: function () {
      this._offset = getElementOffset(this.lowerCanvasEl);
      return this;
    },

    /**
     * Sets {@link fabric.StaticCanvas#overlayImage|overlay image} for this canvas
     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set overlay to
     * @param {Function} callback callback to invoke when image is loaded and set as an overlay
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|overlay image}.
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/MnzHT/|jsFiddle demo}
     * @example <caption>Normal overlayImage with left/top = 0</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   // Needed to position overlayImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>overlayImage with different properties</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>Stretched overlayImage #1 - width/height correspond to canvas width/height</caption>
     * fabric.Image.fromURL('http://fabricjs.com/assets/jail_cell_bars.png', function(img) {
     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
     *    canvas.setOverlayImage(img, canvas.renderAll.bind(canvas));
     * });
     * @example <caption>Stretched overlayImage #2 - width/height correspond to canvas width/height</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   width: canvas.width,
     *   height: canvas.height,
     *   // Needed to position overlayImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>overlayImage loaded from cross-origin</caption>
     * canvas.setOverlayImage('http://fabricjs.com/assets/jail_cell_bars.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top',
     *   crossOrigin: 'anonymous'
     * });
     */
    setOverlayImage: function (image, callback, options) {
      return this.__setBgOverlayImage('overlayImage', image, callback, options);
    },

    /**
     * Sets {@link fabric.StaticCanvas#backgroundImage|background image} for this canvas
     * @param {(fabric.Image|String)} image fabric.Image instance or URL of an image to set background to
     * @param {Function} callback Callback to invoke when image is loaded and set as background
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|background image}.
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/YH9yD/|jsFiddle demo}
     * @example <caption>Normal backgroundImage with left/top = 0</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   // Needed to position backgroundImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>backgroundImage with different properties</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>Stretched backgroundImage #1 - width/height correspond to canvas width/height</caption>
     * fabric.Image.fromURL('http://fabricjs.com/assets/honey_im_subtle.png', function(img) {
     *    img.set({width: canvas.width, height: canvas.height, originX: 'left', originY: 'top'});
     *    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
     * });
     * @example <caption>Stretched backgroundImage #2 - width/height correspond to canvas width/height</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   width: canvas.width,
     *   height: canvas.height,
     *   // Needed to position backgroundImage at 0/0
     *   originX: 'left',
     *   originY: 'top'
     * });
     * @example <caption>backgroundImage loaded from cross-origin</caption>
     * canvas.setBackgroundImage('http://fabricjs.com/assets/honey_im_subtle.png', canvas.renderAll.bind(canvas), {
     *   opacity: 0.5,
     *   angle: 45,
     *   left: 400,
     *   top: 400,
     *   originX: 'left',
     *   originY: 'top',
     *   crossOrigin: 'anonymous'
     * });
     */
    setBackgroundImage: function (image, callback, options) {
      return this.__setBgOverlayImage('backgroundImage', image, callback, options);
    },

    /**
     * Sets {@link fabric.StaticCanvas#overlayColor|background color} for this canvas
     * @param {(String|fabric.Pattern)} overlayColor Color or pattern to set background color to
     * @param {Function} callback Callback to invoke when background color is set
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/pB55h/|jsFiddle demo}
     * @example <caption>Normal overlayColor - color value</caption>
     * canvas.setOverlayColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as overlayColor</caption>
     * canvas.setOverlayColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
     * }, canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as overlayColor with repeat and offset</caption>
     * canvas.setOverlayColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
     *   repeat: 'repeat',
     *   offsetX: 200,
     *   offsetY: 100
     * }, canvas.renderAll.bind(canvas));
     */
    setOverlayColor: function(overlayColor, callback) {
      return this.__setBgOverlayColor('overlayColor', overlayColor, callback);
    },

    /**
     * Sets {@link fabric.StaticCanvas#backgroundColor|background color} for this canvas
     * @param {(String|fabric.Pattern)} backgroundColor Color or pattern to set background color to
     * @param {Function} callback Callback to invoke when background color is set
     * @return {fabric.Canvas} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/hXzvk/|jsFiddle demo}
     * @example <caption>Normal backgroundColor - color value</caption>
     * canvas.setBackgroundColor('rgba(255, 73, 64, 0.6)', canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as backgroundColor</caption>
     * canvas.setBackgroundColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png'
     * }, canvas.renderAll.bind(canvas));
     * @example <caption>fabric.Pattern used as backgroundColor with repeat and offset</caption>
     * canvas.setBackgroundColor({
     *   source: 'http://fabricjs.com/assets/escheresque_ste.png',
     *   repeat: 'repeat',
     *   offsetX: 200,
     *   offsetY: 100
     * }, canvas.renderAll.bind(canvas));
     */
    setBackgroundColor: function(backgroundColor, callback) {
      return this.__setBgOverlayColor('backgroundColor', backgroundColor, callback);
    },

    /**
     * @private
     * @see {@link http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-imagesmoothingenabled|WhatWG Canvas Standard}
     */
    _setImageSmoothing: function() {
      var ctx = this.getContext();

      ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled
        || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;
      ctx.imageSmoothingEnabled = this.imageSmoothingEnabled;
    },

    /**
     * @private
     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundImage|backgroundImage}
     * or {@link fabric.StaticCanvas#overlayImage|overlayImage})
     * @param {(fabric.Image|String|null)} image fabric.Image instance, URL of an image or null to set background or overlay to
     * @param {Function} callback Callback to invoke when image is loaded and set as background or overlay
     * @param {Object} [options] Optional options to set for the {@link fabric.Image|image}.
     */
    __setBgOverlayImage: function(property, image, callback, options) {
      if (typeof image === 'string') {
        fabric.util.loadImage(image, function(img) {
          img && (this[property] = new fabric.Image(img, options));
          callback && callback(img);
        }, this, options && options.crossOrigin);
      }
      else {
        options && image.setOptions(options);
        this[property] = image;
        callback && callback(image);
      }

      return this;
    },

    /**
     * @private
     * @param {String} property Property to set ({@link fabric.StaticCanvas#backgroundColor|backgroundColor}
     * or {@link fabric.StaticCanvas#overlayColor|overlayColor})
     * @param {(Object|String|null)} color Object with pattern information, color value or null
     * @param {Function} [callback] Callback is invoked when color is set
     */
    __setBgOverlayColor: function(property, color, callback) {
      this[property] = color;
      this._initGradient(color, property);
      this._initPattern(color, property, callback);
      return this;
    },

    /**
     * @private
     */
    _createCanvasElement: function() {
      var element = fabric.util.createCanvasElement();
      if (!element) {
        throw CANVAS_INIT_ERROR;
      }
      if (!element.style) {
        element.style = { };
      }
      if (typeof element.getContext === 'undefined') {
        throw CANVAS_INIT_ERROR;
      }
      return element;
    },

    /**
     * @private
     * @param {Object} [options] Options object
     */
    _initOptions: function (options) {
      this._setOptions(options);

      this.width = this.width || parseInt(this.lowerCanvasEl.width, 10) || 0;
      this.height = this.height || parseInt(this.lowerCanvasEl.height, 10) || 0;

      if (!this.lowerCanvasEl.style) {
        return;
      }

      this.lowerCanvasEl.width = this.width;
      this.lowerCanvasEl.height = this.height;

      this.lowerCanvasEl.style.width = this.width + 'px';
      this.lowerCanvasEl.style.height = this.height + 'px';

      this.viewportTransform = this.viewportTransform.slice();
    },

    /**
     * Creates a bottom canvas
     * @private
     * @param {HTMLElement} [canvasEl]
     */
    _createLowerCanvas: function (canvasEl) {
      // canvasEl === 'HTMLCanvasElement' does not work on jsdom/node
      if (canvasEl && canvasEl.getContext) {
        this.lowerCanvasEl = canvasEl;
      }
      else {
        this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();
      }

      fabric.util.addClass(this.lowerCanvasEl, 'lower-canvas');

      if (this.interactive) {
        this._applyCanvasStyle(this.lowerCanvasEl);
      }

      this.contextContainer = this.lowerCanvasEl.getContext('2d');
    },

    /**
     * Returns canvas width (in px)
     * @return {Number}
     */
    getWidth: function () {
      return this.width;
    },

    /**
     * Returns canvas height (in px)
     * @return {Number}
     */
    getHeight: function () {
      return this.height;
    },

    /**
     * Sets width of this canvas instance
     * @param {Number|String} value                         Value to set width to
     * @param {Object}        [options]                     Options object
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setWidth: function (value, options) {
      return this.setDimensions({ width: value }, options);
    },

    /**
     * Sets height of this canvas instance
     * @param {Number|String} value                         Value to set height to
     * @param {Object}        [options]                     Options object
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setHeight: function (value, options) {
      return this.setDimensions({ height: value }, options);
    },

    /**
     * Sets dimensions (width, height) of this canvas instance. when options.cssOnly flag active you should also supply the unit of measure (px/%/em)
     * @param {Object}        dimensions                    Object with width/height properties
     * @param {Number|String} [dimensions.width]            Width of canvas element
     * @param {Number|String} [dimensions.height]           Height of canvas element
     * @param {Object}        [options]                     Options object
     * @param {Boolean}       [options.backstoreOnly=false] Set the given dimensions only as canvas backstore dimensions
     * @param {Boolean}       [options.cssOnly=false]       Set the given dimensions only as css dimensions
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    setDimensions: function (dimensions, options) {
      var cssValue;

      options = options || {};

      for (var prop in dimensions) {
        cssValue = dimensions[prop];

        if (!options.cssOnly) {
          this._setBackstoreDimension(prop, dimensions[prop]);
          cssValue += 'px';
        }

        if (!options.backstoreOnly) {
          this._setCssDimension(prop, cssValue);
        }
      }
      this._initRetinaScaling();
      this._setImageSmoothing();
      this.calcOffset();

      if (!options.cssOnly) {
        this.requestRenderAll();
      }

      return this;
    },

    /**
     * Helper for setting width/height
     * @private
     * @param {String} prop property (width|height)
     * @param {Number} value value to set property to
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    _setBackstoreDimension: function (prop, value) {
      this.lowerCanvasEl[prop] = value;

      if (this.upperCanvasEl) {
        this.upperCanvasEl[prop] = value;
      }

      if (this.cacheCanvasEl) {
        this.cacheCanvasEl[prop] = value;
      }

      this[prop] = value;

      return this;
    },

    /**
     * Helper for setting css width/height
     * @private
     * @param {String} prop property (width|height)
     * @param {String} value value to set property to
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    _setCssDimension: function (prop, value) {
      this.lowerCanvasEl.style[prop] = value;

      if (this.upperCanvasEl) {
        this.upperCanvasEl.style[prop] = value;
      }

      if (this.wrapperEl) {
        this.wrapperEl.style[prop] = value;
      }

      return this;
    },

    /**
     * Returns canvas zoom level
     * @return {Number}
     */
    getZoom: function () {
      return this.viewportTransform[0];
    },

    /**
     * Sets viewport transform of this canvas instance
     * @param {Array} vpt the transform in the form of context.transform
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setViewportTransform: function (vpt) {
      var activeObject = this._activeObject, object, ignoreVpt = false, skipAbsolute = true, i, len;
      this.viewportTransform = vpt;
      for (i = 0, len = this._objects.length; i < len; i++) {
        object = this._objects[i];
        object.group || object.setCoords(ignoreVpt, skipAbsolute);
      }
      if (activeObject && activeObject.type === 'activeSelection') {
        activeObject.setCoords(ignoreVpt, skipAbsolute);
      }
      this.calcViewportBoundaries();
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Sets zoom level of this canvas instance, zoom centered around point
     * @param {fabric.Point} point to zoom with respect to
     * @param {Number} value to set zoom to, less than 1 zooms out
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    zoomToPoint: function (point, value) {
      // TODO: just change the scale, preserve other transformations
      var before = point, vpt = this.viewportTransform.slice(0);
      point = transformPoint(point, invertTransform(this.viewportTransform));
      vpt[0] = value;
      vpt[3] = value;
      var after = transformPoint(point, vpt);
      vpt[4] += before.x - after.x;
      vpt[5] += before.y - after.y;
      return this.setViewportTransform(vpt);
    },

    /**
     * Sets zoom level of this canvas instance
     * @param {Number} value to set zoom to, less than 1 zooms out
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    setZoom: function (value) {
      this.zoomToPoint(new fabric.Point(0, 0), value);
      return this;
    },

    /**
     * Pan viewport so as to place point at top left corner of canvas
     * @param {fabric.Point} point to move to
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    absolutePan: function (point) {
      var vpt = this.viewportTransform.slice(0);
      vpt[4] = -point.x;
      vpt[5] = -point.y;
      return this.setViewportTransform(vpt);
    },

    /**
     * Pans viewpoint relatively
     * @param {fabric.Point} point (position vector) to move by
     * @return {fabric.Canvas} instance
     * @chainable true
     */
    relativePan: function (point) {
      return this.absolutePan(new fabric.Point(
        -point.x - this.viewportTransform[4],
        -point.y - this.viewportTransform[5]
      ));
    },

    /**
     * Returns &lt;canvas> element corresponding to this instance
     * @return {HTMLCanvasElement}
     */
    getElement: function () {
      return this.lowerCanvasEl;
    },

    /**
     * @private
     * @param {fabric.Object} obj Object that was added
     */
    _onObjectAdded: function(obj) {
      this.stateful && obj.setupState();
      obj._set('canvas', this);
      obj.setCoords();
      this.fire('object:added', { target: obj });
      obj.fire('added');
    },

    /**
     * @private
     * @param {fabric.Object} obj Object that was removed
     */
    _onObjectRemoved: function(obj) {
      this.fire('object:removed', { target: obj });
      obj.fire('removed');
      delete obj.canvas;
    },

    /**
     * Clears specified context of canvas element
     * @param {CanvasRenderingContext2D} ctx Context to clear
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    clearContext: function(ctx) {
      ctx.clearRect(0, 0, this.width, this.height);
      return this;
    },

    /**
     * Returns context of canvas where objects are drawn
     * @return {CanvasRenderingContext2D}
     */
    getContext: function () {
      return this.contextContainer;
    },

    /**
     * Clears all contexts (background, main, top) of an instance
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    clear: function () {
      this._objects.length = 0;
      this.backgroundImage = null;
      this.overlayImage = null;
      this.backgroundColor = '';
      this.overlayColor = '';
      if (this._hasITextHandlers) {
        this.off('mouse:up', this._mouseUpITextHandler);
        this._iTextInstances = null;
        this._hasITextHandlers = false;
      }
      this.clearContext(this.contextContainer);
      this.fire('canvas:cleared');
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Renders the canvas
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderAll: function () {
      var canvasToDrawOn = this.contextContainer;
      if (this.isRendering) {
        fabric.util.cancelAnimFrame(this.isRendering);
      }
      this.renderCanvas(canvasToDrawOn, this._objects);
      return this;
    },

    /**
     * Function created to be instance bound at initialization
     * used in requestAnimationFrame rendering
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderAndReset: function() {
      this.isRendering = 0;
      this.renderAll();
    },

    /**
     * Append a renderAll request to next animation frame.
     * a boolean flag will avoid appending more.
     * @return {fabric.Canvas} instance
     * @chainable
     */
    requestRenderAll: function () {
      if (!this.isRendering) {
        this.isRendering = fabric.util.requestAnimFrame(this.renderAndResetBound);
      }
      return this;
    },

    /**
     * Calculate the position of the 4 corner of canvas with current viewportTransform.
     * helps to determinate when an object is in the current rendering viewport using
     * object absolute coordinates ( aCoords )
     * @return {Object} points.tl
     * @chainable
     */
    calcViewportBoundaries: function() {
      var points = { }, width = this.width, height = this.height,
          iVpt = invertTransform(this.viewportTransform);
      points.tl = transformPoint({ x: 0, y: 0 }, iVpt);
      points.br = transformPoint({ x: width, y: height }, iVpt);
      points.tr = new fabric.Point(points.br.x, points.tl.y);
      points.bl = new fabric.Point(points.tl.x, points.br.y);
      this.vptCoords = points;
      return points;
    },

    /**
     * Renders background, objects, overlay and controls.
     * @param {CanvasRenderingContext2D} ctx
     * @param {Array} objects to render
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderCanvas: function(ctx, objects) {
      this.calcViewportBoundaries();
      this.clearContext(ctx);
      this.fire('before:render');
      if (this.clipTo) {
        fabric.util.clipContext(this, ctx);
      }
      this._renderBackground(ctx);

      ctx.save();
      //apply viewport transform once for all rendering process
      ctx.transform.apply(ctx, this.viewportTransform);
      this._renderObjects(ctx, objects);
      ctx.restore();
      if (!this.controlsAboveOverlay && this.interactive) {
        this.drawControls(ctx);
      }
      if (this.clipTo) {
        ctx.restore();
      }
      this._renderOverlay(ctx);
      if (this.controlsAboveOverlay && this.interactive) {
        this.drawControls(ctx);
      }
      this.fire('after:render');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Array} objects to render
     */
    _renderObjects: function(ctx, objects) {
      var i, len;
      for (i = 0, len = objects.length; i < len; ++i) {
        objects[i] && objects[i].render(ctx);
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {string} property 'background' or 'overlay'
     */
    _renderBackgroundOrOverlay: function(ctx, property) {
      var object = this[property + 'Color'];
      if (object) {
        ctx.fillStyle = object.toLive
          ? object.toLive(ctx, this)
          : object;

        ctx.fillRect(
          object.offsetX || 0,
          object.offsetY || 0,
          this.width,
          this.height);
      }
      object = this[property + 'Image'];
      if (object) {
        if (this[property + 'Vpt']) {
          ctx.save();
          ctx.transform.apply(ctx, this.viewportTransform);
        }
        object.render(ctx);
        this[property + 'Vpt'] && ctx.restore();
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderBackground: function(ctx) {
      this._renderBackgroundOrOverlay(ctx, 'background');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderOverlay: function(ctx) {
      this._renderBackgroundOrOverlay(ctx, 'overlay');
    },

    /**
     * Returns coordinates of a center of canvas.
     * Returned value is an object with top and left properties
     * @return {Object} object with "top" and "left" number values
     */
    getCenter: function () {
      return {
        top: this.height / 2,
        left: this.width / 2
      };
    },

    /**
     * Centers object horizontally in the canvas
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @param {fabric.Object} object Object to center horizontally
     * @return {fabric.Canvas} thisArg
     */
    centerObjectH: function (object) {
      return this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));
    },

    /**
     * Centers object vertically in the canvas
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @param {fabric.Object} object Object to center vertically
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    centerObjectV: function (object) {
      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));
    },

    /**
     * Centers object vertically and horizontally in the canvas
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    centerObject: function(object) {
      var center = this.getCenter();

      return this._centerObject(object, new fabric.Point(center.left, center.top));
    },

    /**
     * Centers object vertically and horizontally in the viewport
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    viewportCenterObject: function(object) {
      var vpCenter = this.getVpCenter();

      return this._centerObject(object, vpCenter);
    },

    /**
     * Centers object horizontally in the viewport, object.top is unchanged
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    viewportCenterObjectH: function(object) {
      var vpCenter = this.getVpCenter();
      this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));
      return this;
    },

    /**
     * Centers object Vertically in the viewport, object.top is unchanged
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @param {fabric.Object} object Object to center vertically and horizontally
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    viewportCenterObjectV: function(object) {
      var vpCenter = this.getVpCenter();

      return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));
    },

    /**
     * Calculate the point in canvas that correspond to the center of actual viewport.
     * @return {fabric.Point} vpCenter, viewport center
     * @chainable
     */
    getVpCenter: function() {
      var center = this.getCenter(),
          iVpt = invertTransform(this.viewportTransform);
      return transformPoint({ x: center.left, y: center.top }, iVpt);
    },

    /**
     * @private
     * @param {fabric.Object} object Object to center
     * @param {fabric.Point} center Center point
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    _centerObject: function(object, center) {
      object.setPositionByOrigin(center, 'center', 'center');
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Returs dataless JSON representation of canvas
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {String} json string
     */
    toDatalessJSON: function (propertiesToInclude) {
      return this.toDatalessObject(propertiesToInclude);
    },

    /**
     * Returns object representation of canvas
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function (propertiesToInclude) {
      return this._toObjectMethod('toObject', propertiesToInclude);
    },

    /**
     * Returns dataless object representation of canvas
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toDatalessObject: function (propertiesToInclude) {
      return this._toObjectMethod('toDatalessObject', propertiesToInclude);
    },

    /**
     * @private
     */
    _toObjectMethod: function (methodName, propertiesToInclude) {

      var data = {
        objects: this._toObjects(methodName, propertiesToInclude)
      };

      extend(data, this.__serializeBgOverlay(methodName, propertiesToInclude));

      fabric.util.populateWithProperties(this, data, propertiesToInclude);

      return data;
    },

    /**
     * @private
     */
    _toObjects: function(methodName, propertiesToInclude) {
      return this.getObjects().filter(function(object) {
        return !object.excludeFromExport;
      }).map(function(instance) {
        return this._toObject(instance, methodName, propertiesToInclude);
      }, this);
    },

    /**
     * @private
     */
    _toObject: function(instance, methodName, propertiesToInclude) {
      var originalValue;

      if (!this.includeDefaultValues) {
        originalValue = instance.includeDefaultValues;
        instance.includeDefaultValues = false;
      }

      var object = instance[methodName](propertiesToInclude);
      if (!this.includeDefaultValues) {
        instance.includeDefaultValues = originalValue;
      }
      return object;
    },

    /**
     * @private
     */
    __serializeBgOverlay: function(methodName, propertiesToInclude) {
      var data = { }, bgImage = this.backgroundImage, overlay = this.overlayImage;

      if (this.backgroundColor) {
        data.background = this.backgroundColor.toObject
          ? this.backgroundColor.toObject(propertiesToInclude)
          : this.backgroundColor;
      }

      if (this.overlayColor) {
        data.overlay = this.overlayColor.toObject
          ? this.overlayColor.toObject(propertiesToInclude)
          : this.overlayColor;
      }
      if (bgImage && !bgImage.excludeFromExport) {
        data.backgroundImage = this._toObject(bgImage, methodName, propertiesToInclude);
      }
      if (overlay && !overlay.excludeFromExport) {
        data.overlayImage = this._toObject(overlay, methodName, propertiesToInclude);
      }

      return data;
    },

    /* _TO_SVG_START_ */
    /**
     * When true, getSvgTransform() will apply the StaticCanvas.viewportTransform to the SVG transformation. When true,
     * a zoomed canvas will then produce zoomed SVG output.
     * @type Boolean
     * @default
     */
    svgViewportTransformation: true,

    /**
     * Returns SVG representation of canvas
     * @function
     * @param {Object} [options] Options object for SVG output
     * @param {Boolean} [options.suppressPreamble=false] If true xml tag is not included
     * @param {Object} [options.viewBox] SVG viewbox object
     * @param {Number} [options.viewBox.x] x-cooridnate of viewbox
     * @param {Number} [options.viewBox.y] y-coordinate of viewbox
     * @param {Number} [options.viewBox.width] Width of viewbox
     * @param {Number} [options.viewBox.height] Height of viewbox
     * @param {String} [options.encoding=UTF-8] Encoding of SVG output
     * @param {String} [options.width] desired width of svg with or without units
     * @param {String} [options.height] desired height of svg with or without units
     * @param {Function} [reviver] Method for further parsing of svg elements, called after each fabric object converted into svg representation.
     * @return {String} SVG string
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
     * @see {@link http://jsfiddle.net/fabricjs/jQ3ZZ/|jsFiddle demo}
     * @example <caption>Normal SVG output</caption>
     * var svg = canvas.toSVG();
     * @example <caption>SVG output without preamble (without &lt;?xml ../>)</caption>
     * var svg = canvas.toSVG({suppressPreamble: true});
     * @example <caption>SVG output with viewBox attribute</caption>
     * var svg = canvas.toSVG({
     *   viewBox: {
     *     x: 100,
     *     y: 100,
     *     width: 200,
     *     height: 300
     *   }
     * });
     * @example <caption>SVG output with different encoding (default: UTF-8)</caption>
     * var svg = canvas.toSVG({encoding: 'ISO-8859-1'});
     * @example <caption>Modify SVG output with reviver function</caption>
     * var svg = canvas.toSVG(null, function(svg) {
     *   return svg.replace('stroke-dasharray: ; stroke-linecap: butt; stroke-linejoin: miter; stroke-miterlimit: 10; ', '');
     * });
     */
    toSVG: function(options, reviver) {
      options || (options = { });

      var markup = [];

      this._setSVGPreamble(markup, options);
      this._setSVGHeader(markup, options);

      this._setSVGBgOverlayColor(markup, 'backgroundColor');
      this._setSVGBgOverlayImage(markup, 'backgroundImage', reviver);

      this._setSVGObjects(markup, reviver);

      this._setSVGBgOverlayColor(markup, 'overlayColor');
      this._setSVGBgOverlayImage(markup, 'overlayImage', reviver);

      markup.push('</svg>');

      return markup.join('');
    },

    /**
     * @private
     */
    _setSVGPreamble: function(markup, options) {
      if (options.suppressPreamble) {
        return;
      }
      markup.push(
        '<?xml version="1.0" encoding="', (options.encoding || 'UTF-8'), '" standalone="no" ?>\n',
          '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',
            '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n'
      );
    },

    /**
     * @private
     */
    _setSVGHeader: function(markup, options) {
      var width = options.width || this.width,
          height = options.height || this.height,
          vpt, viewBox = 'viewBox="0 0 ' + this.width + ' ' + this.height + '" ',
          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

      if (options.viewBox) {
        viewBox = 'viewBox="' +
                options.viewBox.x + ' ' +
                options.viewBox.y + ' ' +
                options.viewBox.width + ' ' +
                options.viewBox.height + '" ';
      }
      else {
        if (this.svgViewportTransformation) {
          vpt = this.viewportTransform;
          viewBox = 'viewBox="' +
                  toFixed(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                  toFixed(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + ' ' +
                  toFixed(this.width / vpt[0], NUM_FRACTION_DIGITS) + ' ' +
                  toFixed(this.height / vpt[3], NUM_FRACTION_DIGITS) + '" ';
        }
      }

      markup.push(
        '<svg ',
          'xmlns="http://www.w3.org/2000/svg" ',
          'xmlns:xlink="http://www.w3.org/1999/xlink" ',
          'version="1.1" ',
          'width="', width, '" ',
          'height="', height, '" ',
          viewBox,
          'xml:space="preserve">\n',
        '<desc>Created with Fabric.js ', fabric.version, '</desc>\n',
        '<defs>\n',
          this.createSVGFontFacesMarkup(),
          this.createSVGRefElementsMarkup(),
        '</defs>\n'
      );
    },

    /**
     * Creates markup containing SVG referenced elements like patterns, gradients etc.
     * @return {String}
     */
    createSVGRefElementsMarkup: function() {
      var _this = this,
          markup = ['backgroundColor', 'overlayColor'].map(function(prop) {
            var fill = _this[prop];
            if (fill && fill.toLive) {
              return fill.toSVG(_this, false);
            }
          });
      return markup.join('');
    },

    /**
     * Creates markup containing SVG font faces,
     * font URLs for font faces must be collected by developers
     * and are not extracted from the DOM by fabricjs
     * @param {Array} objects Array of fabric objects
     * @return {String}
     */
    createSVGFontFacesMarkup: function() {
      var markup = '', fontList = { }, obj, fontFamily,
          style, row, rowIndex, _char, charIndex, i, len,
          fontPaths = fabric.fontPaths, objects = this.getObjects();

      for (i = 0, len = objects.length; i < len; i++) {
        obj = objects[i];
        fontFamily = obj.fontFamily;
        if (obj.type.indexOf('text') === -1 || fontList[fontFamily] || !fontPaths[fontFamily]) {
          continue;
        }
        fontList[fontFamily] = true;
        if (!obj.styles) {
          continue;
        }
        style = obj.styles;
        for (rowIndex in style) {
          row = style[rowIndex];
          for (charIndex in row) {
            _char = row[charIndex];
            fontFamily = _char.fontFamily;
            if (!fontList[fontFamily] && fontPaths[fontFamily]) {
              fontList[fontFamily] = true;
            }
          }
        }
      }

      for (var j in fontList) {
        markup += [
          '\t\t@font-face {\n',
          '\t\t\tfont-family: \'', j, '\';\n',
          '\t\t\tsrc: url(\'', fontPaths[j], '\');\n',
          '\t\t}\n'
        ].join('');
      }

      if (markup) {
        markup = [
          '\t<style type="text/css">',
          '<![CDATA[\n',
          markup,
          ']]>',
          '</style>\n'
        ].join('');
      }

      return markup;
    },

    /**
     * @private
     */
    _setSVGObjects: function(markup, reviver) {
      var instance, i, len, objects = this.getObjects();
      for (i = 0, len = objects.length; i < len; i++) {
        instance = objects[i];
        if (instance.excludeFromExport) {
          continue;
        }
        this._setSVGObject(markup, instance, reviver);
      }
    },

    /**
     * @private
     */
    _setSVGObject: function(markup, instance, reviver) {
      markup.push(instance.toSVG(reviver));
    },

    /**
     * @private
     */
    _setSVGBgOverlayImage: function(markup, property, reviver) {
      if (this[property] && this[property].toSVG) {
        markup.push(this[property].toSVG(reviver));
      }
    },

    /**
     * @private
     */
    _setSVGBgOverlayColor: function(markup, property) {
      var filler = this[property];
      if (!filler) {
        return;
      }
      if (filler.toLive) {
        var repeat = filler.repeat;
        markup.push(
          '<rect transform="translate(', this.width / 2, ',', this.height / 2, ')"',
            ' x="', filler.offsetX - this.width / 2, '" y="', filler.offsetY - this.height / 2, '" ',
            'width="',
              (repeat === 'repeat-y' || repeat === 'no-repeat'
                ? filler.source.width
                : this.width),
            '" height="',
              (repeat === 'repeat-x' || repeat === 'no-repeat'
                ? filler.source.height
                : this.height),
            '" fill="url(#SVGID_' + filler.id + ')"',
          '></rect>\n'
        );
      }
      else {
        markup.push(
          '<rect x="0" y="0" ',
            'width="', this.width,
            '" height="', this.height,
            '" fill="', this[property], '"',
          '></rect>\n'
        );
      }
    },
    /* _TO_SVG_END_ */

    /**
     * Moves an object or the objects of a multiple selection
     * to the bottom of the stack of drawn objects
     * @param {fabric.Object} object Object to send to back
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    sendToBack: function (object) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, objs;
      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = objs.length; i--;) {
          obj = objs[i];
          removeFromArray(this._objects, obj);
          this._objects.unshift(obj);
        }
      }
      else {
        removeFromArray(this._objects, object);
        this._objects.unshift(object);
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Moves an object or the objects of a multiple selection
     * to the top of the stack of drawn objects
     * @param {fabric.Object} object Object to send
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    bringToFront: function (object) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, objs;
      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = 0; i < objs.length; i++) {
          obj = objs[i];
          removeFromArray(this._objects, obj);
          this._objects.push(obj);
        }
      }
      else {
        removeFromArray(this._objects, object);
        this._objects.push(object);
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * Moves an object or a selection down in stack of drawn objects
     * @param {fabric.Object} object Object to send
     * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    sendBackwards: function (object, intersecting) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, idx, newIdx, objs, objsMoved = 0;

      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = 0; i < objs.length; i++) {
          obj = objs[i];
          idx = this._objects.indexOf(obj);
          if (idx > 0 + objsMoved) {
            newIdx = idx - 1;
            removeFromArray(this._objects, obj);
            this._objects.splice(newIdx, 0, obj);
          }
          objsMoved++;
        }
      }
      else {
        idx = this._objects.indexOf(object);
        if (idx !== 0) {
          // if object is not on the bottom of stack
          newIdx = this._findNewLowerIndex(object, idx, intersecting);
          removeFromArray(this._objects, object);
          this._objects.splice(newIdx, 0, object);
        }
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * @private
     */
    _findNewLowerIndex: function(object, idx, intersecting) {
      var newIdx, i;

      if (intersecting) {
        newIdx = idx;

        // traverse down the stack looking for the nearest intersecting object
        for (i = idx - 1; i >= 0; --i) {

          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
                               object.isContainedWithinObject(this._objects[i]) ||
                               this._objects[i].isContainedWithinObject(object);

          if (isIntersecting) {
            newIdx = i;
            break;
          }
        }
      }
      else {
        newIdx = idx - 1;
      }

      return newIdx;
    },

    /**
     * Moves an object or a selection up in stack of drawn objects
     * @param {fabric.Object} object Object to send
     * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    bringForward: function (object, intersecting) {
      if (!object) {
        return this;
      }
      var activeSelection = this._activeObject,
          i, obj, idx, newIdx, objs, objsMoved = 0;

      if (object === activeSelection && object.type === 'activeSelection') {
        objs = activeSelection._objects;
        for (i = objs.length; i--;) {
          obj = objs[i];
          idx = this._objects.indexOf(obj);
          if (idx < this._objects.length - 1 - objsMoved) {
            newIdx = idx + 1;
            removeFromArray(this._objects, obj);
            this._objects.splice(newIdx, 0, obj);
          }
          objsMoved++;
        }
      }
      else {
        idx = this._objects.indexOf(object);
        if (idx !== this._objects.length - 1) {
          // if object is not on top of stack (last item in an array)
          newIdx = this._findNewUpperIndex(object, idx, intersecting);
          removeFromArray(this._objects, object);
          this._objects.splice(newIdx, 0, object);
        }
      }
      this.renderOnAddRemove && this.requestRenderAll();
      return this;
    },

    /**
     * @private
     */
    _findNewUpperIndex: function(object, idx, intersecting) {
      var newIdx, i, len;

      if (intersecting) {
        newIdx = idx;

        // traverse up the stack looking for the nearest intersecting object
        for (i = idx + 1, len = this._objects.length; i < len; ++i) {

          var isIntersecting = object.intersectsWithObject(this._objects[i]) ||
                               object.isContainedWithinObject(this._objects[i]) ||
                               this._objects[i].isContainedWithinObject(object);

          if (isIntersecting) {
            newIdx = i;
            break;
          }
        }
      }
      else {
        newIdx = idx + 1;
      }

      return newIdx;
    },

    /**
     * Moves an object to specified level in stack of drawn objects
     * @param {fabric.Object} object Object to send
     * @param {Number} index Position to move to
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    moveTo: function (object, index) {
      removeFromArray(this._objects, object);
      this._objects.splice(index, 0, object);
      return this.renderOnAddRemove && this.requestRenderAll();
    },

    /**
     * Clears a canvas element and removes all event listeners
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    dispose: function () {
      this.clear();
      return this;
    },

    /**
     * Returns a string representation of an instance
     * @return {String} string representation of an instance
     */
    toString: function () {
      return '#<fabric.Canvas (' + this.complexity() + '): ' +
               '{ objects: ' + this.getObjects().length + ' }>';
    }
  });

  extend(fabric.StaticCanvas.prototype, fabric.Observable);
  extend(fabric.StaticCanvas.prototype, fabric.Collection);
  extend(fabric.StaticCanvas.prototype, fabric.DataURLExporter);

  extend(fabric.StaticCanvas, /** @lends fabric.StaticCanvas */ {

    /**
     * @static
     * @type String
     * @default
     */
    EMPTY_JSON: '{"objects": [], "background": "white"}',

    /**
     * Provides a way to check support of some of the canvas methods
     * (either those of HTMLCanvasElement itself, or rendering context)
     *
     * @param {String} methodName Method to check support for;
     *                            Could be one of "getImageData", "toDataURL", "toDataURLWithQuality" or "setLineDash"
     * @return {Boolean | null} `true` if method is supported (or at least exists),
     *                          `null` if canvas element or context can not be initialized
     */
    supports: function (methodName) {
      var el = fabric.util.createCanvasElement();

      if (!el || !el.getContext) {
        return null;
      }

      var ctx = el.getContext('2d');
      if (!ctx) {
        return null;
      }

      switch (methodName) {

        case 'getImageData':
          return typeof ctx.getImageData !== 'undefined';

        case 'setLineDash':
          return typeof ctx.setLineDash !== 'undefined';

        case 'toDataURL':
          return typeof el.toDataURL !== 'undefined';

        case 'toDataURLWithQuality':
          try {
            el.toDataURL('image/jpeg', 0);
            return true;
          }
          catch (e) { }
          return false;

        default:
          return null;
      }
    }
  });

  /**
   * Returns JSON representation of canvas
   * @function
   * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
   * @return {String} JSON string
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#serialization}
   * @see {@link http://jsfiddle.net/fabricjs/pec86/|jsFiddle demo}
   * @example <caption>JSON without additional properties</caption>
   * var json = canvas.toJSON();
   * @example <caption>JSON with additional properties included</caption>
   * var json = canvas.toJSON(['lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'lockUniScaling']);
   * @example <caption>JSON without default values</caption>
   * canvas.includeDefaultValues = false;
   * var json = canvas.toJSON();
   */
  fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;

})();


/**
 * BaseBrush class
 * @class fabric.BaseBrush
 * @see {@link http://fabricjs.com/freedrawing|Freedrawing demo}
 */
fabric.BaseBrush = fabric.util.createClass(/** @lends fabric.BaseBrush.prototype */ {

  /**
   * Color of a brush
   * @type String
   * @default
   */
  color: 'rgb(0, 0, 0)',

  /**
   * Width of a brush
   * @type Number
   * @default
   */
  width: 1,

  /**
   * Shadow object representing shadow of this shape.
   * <b>Backwards incompatibility note:</b> This property replaces "shadowColor" (String), "shadowOffsetX" (Number),
   * "shadowOffsetY" (Number) and "shadowBlur" (Number) since v1.2.12
   * @type fabric.Shadow
   * @default
   */
  shadow: null,

  /**
   * Line endings style of a brush (one of "butt", "round", "square")
   * @type String
   * @default
   */
  strokeLineCap: 'round',

  /**
   * Corner style of a brush (one of "bevil", "round", "miter")
   * @type String
   * @default
   */
  strokeLineJoin: 'round',

  /**
   * Stroke Dash Array.
   * @type Array
   * @default
   */
  strokeDashArray: null,

  /**
   * Sets shadow of an object
   * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
   * @return {fabric.Object} thisArg
   * @chainable
   */
  setShadow: function(options) {
    this.shadow = new fabric.Shadow(options);
    return this;
  },

  /**
   * Sets brush styles
   * @private
   */
  _setBrushStyles: function() {
    var ctx = this.canvas.contextTop;

    ctx.strokeStyle = this.color;
    ctx.lineWidth = this.width;
    ctx.lineCap = this.strokeLineCap;
    ctx.lineJoin = this.strokeLineJoin;
    if (this.strokeDashArray && fabric.StaticCanvas.supports('setLineDash')) {
      ctx.setLineDash(this.strokeDashArray);
    }
  },

  /**
   * Sets brush shadow styles
   * @private
   */
  _setShadow: function() {
    if (!this.shadow) {
      return;
    }

    var ctx = this.canvas.contextTop,
        zoom = this.canvas.getZoom();

    ctx.shadowColor = this.shadow.color;
    ctx.shadowBlur = this.shadow.blur * zoom;
    ctx.shadowOffsetX = this.shadow.offsetX * zoom;
    ctx.shadowOffsetY = this.shadow.offsetY * zoom;
  },

  /**
   * Removes brush shadow styles
   * @private
   */
  _resetShadow: function() {
    var ctx = this.canvas.contextTop;

    ctx.shadowColor = '';
    ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
  }
});


(function() {

  /**
   * PencilBrush class
   * @class fabric.PencilBrush
   * @extends fabric.BaseBrush
   */
  fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.PencilBrush.prototype */ {

    /**
     * Constructor
     * @param {fabric.Canvas} canvas
     * @return {fabric.PencilBrush} Instance of a pencil brush
     */
    initialize: function(canvas) {
      this.canvas = canvas;
      this._points = [];
    },

    /**
     * Inovoked on mouse down
     * @param {Object} pointer
     */
    onMouseDown: function(pointer) {
      this._prepareForDrawing(pointer);
      // capture coordinates immediately
      // this allows to draw dots (when movement never occurs)
      this._captureDrawingPath(pointer);
      this._render();
    },

    /**
     * Inovoked on mouse move
     * @param {Object} pointer
     */
    onMouseMove: function(pointer) {
      this._captureDrawingPath(pointer);
      // redraw curve
      // clear top canvas
      this.canvas.clearContext(this.canvas.contextTop);
      this._render();
    },

    /**
     * Invoked on mouse up
     */
    onMouseUp: function() {
      this._finalizeAndAddPath();
    },

    /**
     * @private
     * @param {Object} pointer Actual mouse position related to the canvas.
     */
    _prepareForDrawing: function(pointer) {

      var p = new fabric.Point(pointer.x, pointer.y);

      this._reset();
      this._addPoint(p);

      this.canvas.contextTop.moveTo(p.x, p.y);
    },

    /**
     * @private
     * @param {fabric.Point} point Point to be added to points array
     */
    _addPoint: function(point) {
      this._points.push(point);
    },

    /**
     * Clear points array and set contextTop canvas style.
     * @private
     */
    _reset: function() {
      this._points.length = 0;

      this._setBrushStyles();
      this._setShadow();
    },

    /**
     * @private
     * @param {Object} pointer Actual mouse position related to the canvas.
     */
    _captureDrawingPath: function(pointer) {
      var pointerPoint = new fabric.Point(pointer.x, pointer.y);
      this._addPoint(pointerPoint);
    },

    /**
     * Draw a smooth path on the topCanvas using quadraticCurveTo
     * @private
     */
    _render: function() {
      var ctx  = this.canvas.contextTop, i, len,
          v = this.canvas.viewportTransform,
          p1 = this._points[0],
          p2 = this._points[1];

      ctx.save();
      ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
      ctx.beginPath();

      //if we only have 2 points in the path and they are the same
      //it means that the user only clicked the canvas without moving the mouse
      //then we should be drawing a dot. A path isn't drawn between two identical dots
      //that's why we set them apart a bit
      if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {
        p1.x -= 0.5;
        p2.x += 0.5;
      }
      ctx.moveTo(p1.x, p1.y);

      for (i = 1, len = this._points.length; i < len; i++) {
        // we pick the point between pi + 1 & pi + 2 as the
        // end point and p1 as our control point.
        var midPoint = p1.midPointFrom(p2);
        ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);

        p1 = this._points[i];
        p2 = this._points[i + 1];
      }
      // Draw last line as a straight line while
      // we wait for the next point to be able to calculate
      // the bezier control point
      ctx.lineTo(p1.x, p1.y);
      ctx.stroke();
      ctx.restore();
    },

    /**
     * Converts points to SVG path
     * @param {Array} points Array of points
     * @return {String} SVG path
     */
    convertPointsToSVGPath: function(points) {
      var path = [], i, len,
          p1 = new fabric.Point(points[0].x, points[0].y),
          p2 = new fabric.Point(points[1].x, points[1].y);

      path.push('M ', points[0].x, ' ', points[0].y, ' ');
      for (i = 1, len = points.length; i < len; i++) {
        var midPoint = p1.midPointFrom(p2);
        // p1 is our bezier control point
        // midpoint is our endpoint
        // start point is p(i-1) value.
        path.push('Q ', p1.x, ' ', p1.y, ' ', midPoint.x, ' ', midPoint.y, ' ');
        p1 = new fabric.Point(points[i].x, points[i].y);
        if ((i + 1) < points.length) {
          p2 = new fabric.Point(points[i + 1].x, points[i + 1].y);
        }
      }
      path.push('L ', p1.x, ' ', p1.y, ' ');
      return path;
    },

    /**
     * Creates fabric.Path object to add on canvas
     * @param {String} pathData Path data
     * @return {fabric.Path} Path to add on canvas
     */
    createPath: function(pathData) {
      var path = new fabric.Path(pathData, {
        fill: null,
        stroke: this.color,
        strokeWidth: this.width,
        strokeLineCap: this.strokeLineCap,
        strokeLineJoin: this.strokeLineJoin,
        strokeDashArray: this.strokeDashArray,
        originX: 'center',
        originY: 'center'
      });

      if (this.shadow) {
        this.shadow.affectStroke = true;
        path.setShadow(this.shadow);
      }

      return path;
    },

    /**
     * On mouseup after drawing the path on contextTop canvas
     * we use the points captured to create an new fabric path object
     * and add it to the fabric canvas.
     */
    _finalizeAndAddPath: function() {
      var ctx = this.canvas.contextTop;
      ctx.closePath();

      var pathData = this.convertPointsToSVGPath(this._points).join('');
      if (pathData === 'M 0 0 Q 0 0 0 0 L 0 0') {
        // do not create 0 width/height paths, as they are
        // rendered inconsistently across browsers
        // Firefox 4, for example, renders a dot,
        // whereas Chrome 10 renders nothing
        this.canvas.requestRenderAll();
        return;
      }

      var path = this.createPath(pathData);

      this.canvas.add(path);
      path.setCoords();

      this.canvas.clearContext(this.canvas.contextTop);
      this._resetShadow();
      this.canvas.requestRenderAll();

      // fire event 'path' created
      this.canvas.fire('path:created', { path: path });
    }
  });
})();


/**
 * CircleBrush class
 * @class fabric.CircleBrush
 */
fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, /** @lends fabric.CircleBrush.prototype */ {

  /**
   * Width of a brush
   * @type Number
   * @default
   */
  width: 10,

  /**
   * Constructor
   * @param {fabric.Canvas} canvas
   * @return {fabric.CircleBrush} Instance of a circle brush
   */
  initialize: function(canvas) {
    this.canvas = canvas;
    this.points = [];
  },

  /**
   * Invoked inside on mouse down and mouse move
   * @param {Object} pointer
   */
  drawDot: function(pointer) {
    var point = this.addPoint(pointer),
        ctx = this.canvas.contextTop,
        v = this.canvas.viewportTransform;
    ctx.save();
    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);

    ctx.fillStyle = point.fill;
    ctx.beginPath();
    ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  },

  /**
   * Invoked on mouse down
   */
  onMouseDown: function(pointer) {
    this.points.length = 0;
    this.canvas.clearContext(this.canvas.contextTop);
    this._setShadow();
    this.drawDot(pointer);
  },

  /**
   * Invoked on mouse move
   * @param {Object} pointer
   */
  onMouseMove: function(pointer) {
    this.drawDot(pointer);
  },

  /**
   * Invoked on mouse up
   */
  onMouseUp: function() {
    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove, i, len;
    this.canvas.renderOnAddRemove = false;

    var circles = [];

    for (i = 0, len = this.points.length; i < len; i++) {
      var point = this.points[i],
          circle = new fabric.Circle({
            radius: point.radius,
            left: point.x,
            top: point.y,
            originX: 'center',
            originY: 'center',
            fill: point.fill
          });

      this.shadow && circle.setShadow(this.shadow);

      circles.push(circle);
    }
    var group = new fabric.Group(circles, { originX: 'center', originY: 'center' });
    group.canvas = this.canvas;

    this.canvas.add(group);
    this.canvas.fire('path:created', { path: group });

    this.canvas.clearContext(this.canvas.contextTop);
    this._resetShadow();
    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
    this.canvas.requestRenderAll();
  },

  /**
   * @param {Object} pointer
   * @return {fabric.Point} Just added pointer point
   */
  addPoint: function(pointer) {
    var pointerPoint = new fabric.Point(pointer.x, pointer.y),

        circleRadius = fabric.util.getRandomInt(
                        Math.max(0, this.width - 20), this.width + 20) / 2,

        circleColor = new fabric.Color(this.color)
                        .setAlpha(fabric.util.getRandomInt(0, 100) / 100)
                        .toRgba();

    pointerPoint.radius = circleRadius;
    pointerPoint.fill = circleColor;

    this.points.push(pointerPoint);

    return pointerPoint;
  }
});


/**
 * SprayBrush class
 * @class fabric.SprayBrush
 */
fabric.SprayBrush = fabric.util.createClass( fabric.BaseBrush, /** @lends fabric.SprayBrush.prototype */ {

  /**
   * Width of a spray
   * @type Number
   * @default
   */
  width:              10,

  /**
   * Density of a spray (number of dots per chunk)
   * @type Number
   * @default
   */
  density:            20,

  /**
   * Width of spray dots
   * @type Number
   * @default
   */
  dotWidth:           1,

  /**
   * Width variance of spray dots
   * @type Number
   * @default
   */
  dotWidthVariance:   1,

  /**
   * Whether opacity of a dot should be random
   * @type Boolean
   * @default
   */
  randomOpacity:        false,

  /**
   * Whether overlapping dots (rectangles) should be removed (for performance reasons)
   * @type Boolean
   * @default
   */
  optimizeOverlapping:  true,

  /**
   * Constructor
   * @param {fabric.Canvas} canvas
   * @return {fabric.SprayBrush} Instance of a spray brush
   */
  initialize: function(canvas) {
    this.canvas = canvas;
    this.sprayChunks = [];
  },

  /**
   * Invoked on mouse down
   * @param {Object} pointer
   */
  onMouseDown: function(pointer) {
    this.sprayChunks.length = 0;
    this.canvas.clearContext(this.canvas.contextTop);
    this._setShadow();

    this.addSprayChunk(pointer);
    this.render();
  },

  /**
   * Invoked on mouse move
   * @param {Object} pointer
   */
  onMouseMove: function(pointer) {
    this.addSprayChunk(pointer);
    this.render();
  },

  /**
   * Invoked on mouse up
   */
  onMouseUp: function() {
    var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
    this.canvas.renderOnAddRemove = false;

    var rects = [];

    for (var i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
      var sprayChunk = this.sprayChunks[i];

      for (var j = 0, jlen = sprayChunk.length; j < jlen; j++) {

        var rect = new fabric.Rect({
          width: sprayChunk[j].width,
          height: sprayChunk[j].width,
          left: sprayChunk[j].x + 1,
          top: sprayChunk[j].y + 1,
          originX: 'center',
          originY: 'center',
          fill: this.color
        });

        this.shadow && rect.setShadow(this.shadow);
        rects.push(rect);
      }
    }

    if (this.optimizeOverlapping) {
      rects = this._getOptimizedRects(rects);
    }

    var group = new fabric.Group(rects, { originX: 'center', originY: 'center' });
    group.canvas = this.canvas;

    this.canvas.add(group);
    this.canvas.fire('path:created', { path: group });

    this.canvas.clearContext(this.canvas.contextTop);
    this._resetShadow();
    this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
    this.canvas.requestRenderAll();
  },

  /**
   * @private
   * @param {Array} rects
   */
  _getOptimizedRects: function(rects) {

    // avoid creating duplicate rects at the same coordinates
    var uniqueRects = { }, key, i, len;

    for (i = 0, len = rects.length; i < len; i++) {
      key = rects[i].left + '' + rects[i].top;
      if (!uniqueRects[key]) {
        uniqueRects[key] = rects[i];
      }
    }
    var uniqueRectsArray = [];
    for (key in uniqueRects) {
      uniqueRectsArray.push(uniqueRects[key]);
    }

    return uniqueRectsArray;
  },

  /**
   * Renders brush
   */
  render: function() {
    var ctx = this.canvas.contextTop;
    ctx.fillStyle = this.color;

    var v = this.canvas.viewportTransform, i, len;
    ctx.save();
    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);

    for (i = 0, len = this.sprayChunkPoints.length; i < len; i++) {
      var point = this.sprayChunkPoints[i];
      if (typeof point.opacity !== 'undefined') {
        ctx.globalAlpha = point.opacity;
      }
      ctx.fillRect(point.x, point.y, point.width, point.width);
    }
    ctx.restore();
  },

  /**
   * @param {Object} pointer
   */
  addSprayChunk: function(pointer) {
    this.sprayChunkPoints = [];

    var x, y, width, radius = this.width / 2, i;

    for (i = 0; i < this.density; i++) {

      x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);
      y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);

      if (this.dotWidthVariance) {
        width = fabric.util.getRandomInt(
          // bottom clamp width to 1
          Math.max(1, this.dotWidth - this.dotWidthVariance),
          this.dotWidth + this.dotWidthVariance);
      }
      else {
        width = this.dotWidth;
      }

      var point = new fabric.Point(x, y);
      point.width = width;

      if (this.randomOpacity) {
        point.opacity = fabric.util.getRandomInt(0, 100) / 100;
      }

      this.sprayChunkPoints.push(point);
    }

    this.sprayChunks.push(this.sprayChunkPoints);
  }
});


/**
 * PatternBrush class
 * @class fabric.PatternBrush
 * @extends fabric.BaseBrush
 */
fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, /** @lends fabric.PatternBrush.prototype */ {

  getPatternSrc: function() {

    var dotWidth = 20,
        dotDistance = 5,
        patternCanvas = fabric.document.createElement('canvas'),
        patternCtx = patternCanvas.getContext('2d');

    patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;

    patternCtx.fillStyle = this.color;
    patternCtx.beginPath();
    patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);
    patternCtx.closePath();
    patternCtx.fill();

    return patternCanvas;
  },

  getPatternSrcFunction: function() {
    return String(this.getPatternSrc).replace('this.color', '"' + this.color + '"');
  },

  /**
   * Creates "pattern" instance property
   */
  getPattern: function() {
    return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), 'repeat');
  },

  /**
   * Sets brush styles
   */
  _setBrushStyles: function() {
    this.callSuper('_setBrushStyles');
    this.canvas.contextTop.strokeStyle = this.getPattern();
  },

  /**
   * Creates path
   */
  createPath: function(pathData) {
    var path = this.callSuper('createPath', pathData),
        topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);

    path.stroke = new fabric.Pattern({
      source: this.source || this.getPatternSrcFunction(),
      offsetX: -topLeft.x,
      offsetY: -topLeft.y
    });
    return path;
  }
});


(function() {

  var getPointer = fabric.util.getPointer,
      degreesToRadians = fabric.util.degreesToRadians,
      radiansToDegrees = fabric.util.radiansToDegrees,
      atan2 = Math.atan2,
      abs = Math.abs,
      supportLineDash = fabric.StaticCanvas.supports('setLineDash'),

      STROKE_OFFSET = 0.5;

  /**
   * Canvas class
   * @class fabric.Canvas
   * @extends fabric.StaticCanvas
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#canvas}
   * @see {@link fabric.Canvas#initialize} for constructor definition
   *
   * @fires object:added
   * @fires object:modified
   * @fires object:rotating
   * @fires object:scaling
   * @fires object:moving
   * @fires object:selected
   *
   * @fires before:selection:cleared
   * @fires selection:cleared
   *
   * @fires path:created
   * @fires mouse:down
   * @fires mouse:move
   * @fires mouse:up
   * @fires mouse:over
   * @fires mouse:out
   * @fires mouse:dblclick
   *
   */
  fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, /** @lends fabric.Canvas.prototype */ {

    /**
     * Constructor
     * @param {HTMLElement | String} el &lt;canvas> element to initialize instance on
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(el, options) {
      options || (options = { });
      this.renderAndResetBound = this.renderAndReset.bind(this);
      this._initStatic(el, options);
      this._initInteractive();
      this._createCacheCanvas();
    },

    /**
     * When true, objects can be transformed by one side (unproportionally)
     * @type Boolean
     * @default
     */
    uniScaleTransform:      false,

    /**
     * Indicates which key enable unproportional scaling
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled feature disabled.
     * @since 1.6.2
     * @type String
     * @default
     */
    uniScaleKey:           'shiftKey',

    /**
     * When true, objects use center point as the origin of scale transformation.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredScaling:        false,

    /**
     * When true, objects use center point as the origin of rotate transformation.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredRotation:       false,

    /**
     * Indicates which key enable centered Transform
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled feature disabled.
     * @since 1.6.2
     * @type String
     * @default
     */
    centeredKey:           'altKey',

    /**
     * Indicates which key enable alternate action on corner
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled feature disabled.
     * @since 1.6.2
     * @type String
     * @default
     */
    altActionKey:           'shiftKey',

    /**
     * Indicates that canvas is interactive. This property should not be changed.
     * @type Boolean
     * @default
     */
    interactive:            true,

    /**
     * Indicates whether group selection should be enabled
     * @type Boolean
     * @default
     */
    selection:              true,

    /**
     * Indicates which key enable multiple click selection
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled feature disabled.
     * @since 1.6.2
     * @type String
     * @default
     */
    selectionKey:           'shiftKey',

    /**
     * Indicates which key enable alternative selection
     * in case of target overlapping with active object
     * values: 'altKey', 'shiftKey', 'ctrlKey'.
     * If `null` or 'none' or any other string that is not a modifier key
     * feature is disabled feature disabled.
     * @since 1.6.5
     * @type null|String
     * @default
     */
    altSelectionKey:           null,

    /**
     * Color of selection
     * @type String
     * @default
     */
    selectionColor:         'rgba(100, 100, 255, 0.3)', // blue

    /**
     * Default dash array pattern
     * If not empty the selection border is dashed
     * @type Array
     */
    selectionDashArray:     [],

    /**
     * Color of the border of selection (usually slightly darker than color of selection itself)
     * @type String
     * @default
     */
    selectionBorderColor:   'rgba(255, 255, 255, 0.3)',

    /**
     * Width of a line used in object/group selection
     * @type Number
     * @default
     */
    selectionLineWidth:     1,

    /**
     * Default cursor value used when hovering over an object on canvas
     * @type String
     * @default
     */
    hoverCursor:            'move',

    /**
     * Default cursor value used when moving an object on canvas
     * @type String
     * @default
     */
    moveCursor:             'move',

    /**
     * Default cursor value used for the entire canvas
     * @type String
     * @default
     */
    defaultCursor:          'default',

    /**
     * Cursor value used during free drawing
     * @type String
     * @default
     */
    freeDrawingCursor:      'crosshair',

    /**
     * Cursor value used for rotation point
     * @type String
     * @default
     */
    rotationCursor:         'crosshair',

    /**
     * Cursor value used for disabled elements ( corners with disabled action )
     * @type String
     * @since 2.0.0
     * @default
     */
    notAllowedCursor:         'not-allowed',

    /**
     * Default element class that's given to wrapper (div) element of canvas
     * @type String
     * @default
     */
    containerClass:         'canvas-container',

    /**
     * When true, object detection happens on per-pixel basis rather than on per-bounding-box
     * @type Boolean
     * @default
     */
    perPixelTargetFind:     false,

    /**
     * Number of pixels around target pixel to tolerate (consider active) during object detection
     * @type Number
     * @default
     */
    targetFindTolerance:    0,

    /**
     * When true, target detection is skipped when hovering over canvas. This can be used to improve performance.
     * @type Boolean
     * @default
     */
    skipTargetFind:         false,

    /**
     * When true, mouse events on canvas (mousedown/mousemove/mouseup) result in free drawing.
     * After mousedown, mousemove creates a shape,
     * and then mouseup finalizes it and adds an instance of `fabric.Path` onto canvas.
     * @tutorial {@link http://fabricjs.com/fabric-intro-part-4#free_drawing}
     * @type Boolean
     * @default
     */
    isDrawingMode:          false,

    /**
     * Indicates whether objects should remain in current stack position when selected.
     * When false objects are brought to top and rendered as part of the selection group
     * @type Boolean
     * @default
     */
    preserveObjectStacking: false,

    /**
     * Indicates the angle that an object will lock to while rotating.
     * @type Number
     * @since 1.6.7
     * @default
     */
    snapAngle: 0,

    /**
     * Indicates the distance from the snapAngle the rotation will lock to the snapAngle.
     * When `null`, the snapThreshold will default to the snapAngle.
     * @type null|Number
     * @since 1.6.7
     * @default
     */
    snapThreshold: null,

    /**
     * Indicates if the right click on canvas can output the context menu or not
     * @type Boolean
     * @since 1.6.5
     * @default
     */
    stopContextMenu: false,

    /**
     * Indicates if the canvas can fire right click events
     * @type Boolean
     * @since 1.6.5
     * @default
     */
    fireRightClick: false,

    /**
     * Indicates if the canvas can fire middle click events
     * @type Boolean
     * @since 1.7.8
     * @default
     */
    fireMiddleClick: false,

    /**
     * @private
     */
    _initInteractive: function() {
      this._currentTransform = null;
      this._groupSelector = null;
      this._initWrapperElement();
      this._createUpperCanvas();
      this._initEventListeners();

      this._initRetinaScaling();

      this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);

      this.calcOffset();
    },

    /**
     * Divides objects in two groups, one to render immediately
     * and one to render as activeGroup.
     * @return {Array} objects to render immediately and pushes the other in the activeGroup.
     */
    _chooseObjectsToRender: function() {
      var activeObjects = this.getActiveObjects(),
          object, objsToRender, activeGroupObjects;

      if (activeObjects.length > 0 && !this.preserveObjectStacking) {
        objsToRender = [];
        activeGroupObjects = [];
        for (var i = 0, length = this._objects.length; i < length; i++) {
          object = this._objects[i];
          if (activeObjects.indexOf(object) === -1 ) {
            objsToRender.push(object);
          }
          else {
            activeGroupObjects.push(object);
          }
        }
        if (activeObjects.length > 1) {
          this._activeObject._objects = activeGroupObjects;
        }
        objsToRender.push.apply(objsToRender, activeGroupObjects);
      }
      else {
        objsToRender = this._objects;
      }
      return objsToRender;
    },

    /**
     * Renders both the top canvas and the secondary container canvas.
     * @return {fabric.Canvas} instance
     * @chainable
     */
    renderAll: function () {
      if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {
        this.clearContext(this.contextTop);
        this.contextTopDirty = false;
      }
      var canvasToDrawOn = this.contextContainer;
      this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());
      return this;
    },

    /**
     * Method to render only the top canvas.
     * Also used to render the group selection box.
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    renderTop: function () {
      var ctx = this.contextTop;
      this.clearContext(ctx);

      // we render the top context - last object
      if (this.selection && this._groupSelector) {
        this._drawSelection(ctx);
      }

      this.fire('after:render');
      this.contextTopDirty = true;
      return this;
    },

    /**
     * Resets the current transform to its original values and chooses the type of resizing based on the event
     * @private
     */
    _resetCurrentTransform: function() {
      var t = this._currentTransform;

      t.target.set({
        scaleX: t.original.scaleX,
        scaleY: t.original.scaleY,
        skewX: t.original.skewX,
        skewY: t.original.skewY,
        left: t.original.left,
        top: t.original.top
      });

      if (this._shouldCenterTransform(t.target)) {
        if (t.action === 'rotate') {
          this._setOriginToCenter(t.target);
        }
        else {
          if (t.originX !== 'center') {
            if (t.originX === 'right') {
              t.mouseXSign = -1;
            }
            else {
              t.mouseXSign = 1;
            }
          }
          if (t.originY !== 'center') {
            if (t.originY === 'bottom') {
              t.mouseYSign = -1;
            }
            else {
              t.mouseYSign = 1;
            }
          }

          t.originX = 'center';
          t.originY = 'center';
        }
      }
      else {
        t.originX = t.original.originX;
        t.originY = t.original.originY;
      }
    },

    /**
     * Checks if point is contained within an area of given object
     * @param {Event} e Event object
     * @param {fabric.Object} target Object to test against
     * @param {Object} [point] x,y object of point coordinates we want to check.
     * @return {Boolean} true if point is contained within an area of given object
     */
    containsPoint: function (e, target, point) {
      var ignoreZoom = true,
          pointer = point || this.getPointer(e, ignoreZoom),
          xy;

      if (target.group && target.group === this._activeObject && target.group.type === 'activeSelection') {
        xy = this._normalizePointer(target.group, pointer);
      }
      else {
        xy = { x: pointer.x, y: pointer.y };
      }
      // http://www.geog.ubc.ca/courses/klink/gis.notes/ncgia/u32.html
      // http://idav.ucdavis.edu/~okreylos/TAship/Spring2000/PointInPolygon.html
      return (target.containsPoint(xy) || target._findTargetCorner(pointer));
    },

    /**
     * @private
     */
    _normalizePointer: function (object, pointer) {
      var m = object.calcTransformMatrix(),
          invertedM = fabric.util.invertTransform(m),
          vptPointer = this.restorePointerVpt(pointer);
      return fabric.util.transformPoint(vptPointer, invertedM);
    },

    /**
     * Returns true if object is transparent at a certain location
     * @param {fabric.Object} target Object to check
     * @param {Number} x Left coordinate
     * @param {Number} y Top coordinate
     * @return {Boolean}
     */
    isTargetTransparent: function (target, x, y) {
      var hasBorders = target.hasBorders,
          transparentCorners = target.transparentCorners,
          ctx = this.contextCache,
          originalColor = target.selectionBackgroundColor;

      target.hasBorders = target.transparentCorners = false;
      target.selectionBackgroundColor = '';

      ctx.save();
      ctx.transform.apply(ctx, this.viewportTransform);
      target.render(ctx);
      ctx.restore();

      target.active && target._renderControls(ctx);

      target.hasBorders = hasBorders;
      target.transparentCorners = transparentCorners;
      target.selectionBackgroundColor = originalColor;

      var isTransparent = fabric.util.isTransparent(
        ctx, x, y, this.targetFindTolerance);

      this.clearContext(ctx);

      return isTransparent;
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     */
    _shouldClearSelection: function (e, target) {
      var activeObjects = this.getActiveObjects(),
          activeObject = this._activeObject;
      return (
        !target
        ||
        (target &&
          activeObject &&
          activeObjects.length > 1 &&
          activeObjects.indexOf(target) === -1 &&
          activeObject !== target &&
          !e[this.selectionKey])
        ||
        (target && !target.evented)
        ||
        (target &&
          !target.selectable &&
          activeObject &&
          activeObject !== target)
      );
    },

    /**
     * @private
     * @param {fabric.Object} target
     */
    _shouldCenterTransform: function (target) {
      if (!target) {
        return;
      }

      var t = this._currentTransform,
          centerTransform;

      if (t.action === 'scale' || t.action === 'scaleX' || t.action === 'scaleY') {
        centerTransform = this.centeredScaling || target.centeredScaling;
      }
      else if (t.action === 'rotate') {
        centerTransform = this.centeredRotation || target.centeredRotation;
      }

      return centerTransform ? !t.altKey : t.altKey;
    },

    /**
     * @private
     */
    _getOriginFromCorner: function(target, corner) {
      var origin = {
        x: target.originX,
        y: target.originY
      };

      if (corner === 'ml' || corner === 'tl' || corner === 'bl') {
        origin.x = 'right';
      }
      else if (corner === 'mr' || corner === 'tr' || corner === 'br') {
        origin.x = 'left';
      }

      if (corner === 'tl' || corner === 'mt' || corner === 'tr') {
        origin.y = 'bottom';
      }
      else if (corner === 'bl' || corner === 'mb' || corner === 'br') {
        origin.y = 'top';
      }

      return origin;
    },

    /**
     * @private
     */
    _getActionFromCorner: function(target, corner, e) {
      if (!corner) {
        return 'drag';
      }

      switch (corner) {
        case 'mtr':
          return 'rotate';
        case 'ml':
        case 'mr':
          return e[this.altActionKey] ? 'skewY' : 'scaleX';
        case 'mt':
        case 'mb':
          return e[this.altActionKey] ? 'skewX' : 'scaleY';
        default:
          return 'scale';
      }
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     */
    _setupCurrentTransform: function (e, target) {
      if (!target) {
        return;
      }

      var pointer = this.getPointer(e),
          corner = target._findTargetCorner(this.getPointer(e, true)),
          action = this._getActionFromCorner(target, corner, e),
          origin = this._getOriginFromCorner(target, corner);

      this._currentTransform = {
        target: target,
        action: action,
        corner: corner,
        scaleX: target.scaleX,
        scaleY: target.scaleY,
        skewX: target.skewX,
        skewY: target.skewY,
        offsetX: pointer.x - target.left,
        offsetY: pointer.y - target.top,
        originX: origin.x,
        originY: origin.y,
        ex: pointer.x,
        ey: pointer.y,
        lastX: pointer.x,
        lastY: pointer.y,
        left: target.left,
        top: target.top,
        theta: degreesToRadians(target.angle),
        width: target.width * target.scaleX,
        mouseXSign: 1,
        mouseYSign: 1,
        shiftKey: e.shiftKey,
        altKey: e[this.centeredKey]
      };

      this._currentTransform.original = {
        left: target.left,
        top: target.top,
        scaleX: target.scaleX,
        scaleY: target.scaleY,
        skewX: target.skewX,
        skewY: target.skewY,
        originX: origin.x,
        originY: origin.y
      };

      this._resetCurrentTransform();
    },

    /**
     * Translates object by "setting" its left/top
     * @private
     * @param {Number} x pointer's x coordinate
     * @param {Number} y pointer's y coordinate
     * @return {Boolean} true if the translation occurred
     */
    _translateObject: function (x, y) {
      var transform = this._currentTransform,
          target = transform.target,
          newLeft = x - transform.offsetX,
          newTop = y - transform.offsetY,
          moveX = !target.get('lockMovementX') && target.left !== newLeft,
          moveY = !target.get('lockMovementY') && target.top !== newTop;

      moveX && target.set('left', newLeft);
      moveY && target.set('top', newTop);
      return moveX || moveY;
    },

    /**
     * Check if we are increasing a positive skew or lower it,
     * checking mouse direction and pressed corner.
     * @private
     */
    _changeSkewTransformOrigin: function(mouseMove, t, by) {
      var property = 'originX', origins = { 0: 'center' },
          skew = t.target.skewX, originA = 'left', originB = 'right',
          corner = t.corner === 'mt' || t.corner === 'ml' ? 1 : -1,
          flipSign = 1;

      mouseMove = mouseMove > 0 ? 1 : -1;
      if (by === 'y') {
        skew = t.target.skewY;
        originA = 'top';
        originB = 'bottom';
        property = 'originY';
      }
      origins[-1] = originA;
      origins[1] = originB;

      t.target.flipX && (flipSign *= -1);
      t.target.flipY && (flipSign *= -1);

      if (skew === 0) {
        t.skewSign = -corner * mouseMove * flipSign;
        t[property] = origins[-mouseMove];
      }
      else {
        skew = skew > 0 ? 1 : -1;
        t.skewSign = skew;
        t[property] = origins[skew * corner * flipSign];
      }
    },

    /**
     * Skew object by mouse events
     * @private
     * @param {Number} x pointer's x coordinate
     * @param {Number} y pointer's y coordinate
     * @param {String} by Either 'x' or 'y'
     * @return {Boolean} true if the skewing occurred
     */
    _skewObject: function (x, y, by) {
      var t = this._currentTransform,
          target = t.target, skewed = false,
          lockSkewingX = target.get('lockSkewingX'),
          lockSkewingY = target.get('lockSkewingY');

      if ((lockSkewingX && by === 'x') || (lockSkewingY && by === 'y')) {
        return false;
      }

      // Get the constraint point
      var center = target.getCenterPoint(),
          actualMouseByCenter = target.toLocalPoint(new fabric.Point(x, y), 'center', 'center')[by],
          lastMouseByCenter = target.toLocalPoint(new fabric.Point(t.lastX, t.lastY), 'center', 'center')[by],
          actualMouseByOrigin, constraintPosition, dim = target._getTransformedDimensions();

      this._changeSkewTransformOrigin(actualMouseByCenter - lastMouseByCenter, t, by);
      actualMouseByOrigin = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY)[by];
      constraintPosition = target.translateToOriginPoint(center, t.originX, t.originY);
      // Actually skew the object
      skewed = this._setObjectSkew(actualMouseByOrigin, t, by, dim);
      t.lastX = x;
      t.lastY = y;
      // Make sure the constraints apply
      target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
      return skewed;
    },

    /**
     * Set object skew
     * @private
     * @return {Boolean} true if the skewing occurred
     */
    _setObjectSkew: function(localMouse, transform, by, _dim) {
      var target = transform.target, newValue, skewed = false,
          skewSign = transform.skewSign, newDim, dimNoSkew,
          otherBy, _otherBy, _by, newDimMouse, skewX, skewY;

      if (by === 'x') {
        otherBy = 'y';
        _otherBy = 'Y';
        _by = 'X';
        skewX = 0;
        skewY = target.skewY;
      }
      else {
        otherBy = 'x';
        _otherBy = 'X';
        _by = 'Y';
        skewX = target.skewX;
        skewY = 0;
      }

      dimNoSkew = target._getTransformedDimensions(skewX, skewY);
      newDimMouse = 2 * Math.abs(localMouse) - dimNoSkew[by];
      if (newDimMouse <= 2) {
        newValue = 0;
      }
      else {
        newValue = skewSign * Math.atan((newDimMouse / target['scale' + _by]) /
                                        (dimNoSkew[otherBy] / target['scale' + _otherBy]));
        newValue = fabric.util.radiansToDegrees(newValue);
      }
      skewed = target['skew' + _by] !== newValue;
      target.set('skew' + _by, newValue);
      if (target['skew' + _otherBy] !== 0) {
        newDim = target._getTransformedDimensions();
        newValue = (_dim[otherBy] / newDim[otherBy]) * target['scale' + _otherBy];
        target.set('scale' + _otherBy, newValue);
      }
      return skewed;
    },

    /**
     * Scales object by invoking its scaleX/scaleY methods
     * @private
     * @param {Number} x pointer's x coordinate
     * @param {Number} y pointer's y coordinate
     * @param {String} by Either 'x' or 'y' - specifies dimension constraint by which to scale an object.
     *                    When not provided, an object is scaled by both dimensions equally
     * @return {Boolean} true if the scaling occurred
     */
    _scaleObject: function (x, y, by) {
      var t = this._currentTransform,
          target = t.target,
          lockScalingX = target.get('lockScalingX'),
          lockScalingY = target.get('lockScalingY'),
          lockScalingFlip = target.get('lockScalingFlip');

      if (lockScalingX && lockScalingY) {
        return false;
      }

      // Get the constraint point
      var constraintPosition = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY),
          localMouse = target.toLocalPoint(new fabric.Point(x, y), t.originX, t.originY),
          dim = target._getTransformedDimensions(), scaled = false;

      this._setLocalMouse(localMouse, t);

      // Actually scale the object
      scaled = this._setObjectScale(localMouse, t, lockScalingX, lockScalingY, by, lockScalingFlip, dim);

      // Make sure the constraints apply
      target.setPositionByOrigin(constraintPosition, t.originX, t.originY);
      return scaled;
    },

    /**
     * @private
     * @return {Boolean} true if the scaling occurred
     */
    _setObjectScale: function(localMouse, transform, lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {
      var target = transform.target, forbidScalingX = false, forbidScalingY = false, scaled = false,
          changeX, changeY, scaleX, scaleY;

      scaleX = localMouse.x * target.scaleX / _dim.x;
      scaleY = localMouse.y * target.scaleY / _dim.y;
      changeX = target.scaleX !== scaleX;
      changeY = target.scaleY !== scaleY;

      if (lockScalingFlip && scaleX <= 0 && scaleX < target.scaleX) {
        forbidScalingX = true;
      }

      if (lockScalingFlip && scaleY <= 0 && scaleY < target.scaleY) {
        forbidScalingY = true;
      }

      if (by === 'equally' && !lockScalingX && !lockScalingY) {
        forbidScalingX || forbidScalingY || (scaled = this._scaleObjectEqually(localMouse, target, transform, _dim));
      }
      else if (!by) {
        forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) && (scaled = scaled || changeX));
        forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) && (scaled = scaled || changeY));
      }
      else if (by === 'x' && !target.get('lockUniScaling')) {
        forbidScalingX || lockScalingX || (target.set('scaleX', scaleX) && (scaled = scaled || changeX));
      }
      else if (by === 'y' && !target.get('lockUniScaling')) {
        forbidScalingY || lockScalingY || (target.set('scaleY', scaleY) && (scaled = scaled || changeY));
      }
      transform.newScaleX = scaleX;
      transform.newScaleY = scaleY;
      forbidScalingX || forbidScalingY || this._flipObject(transform, by);
      return scaled;
    },

    /**
     * @private
     * @return {Boolean} true if the scaling occurred
     */
    _scaleObjectEqually: function(localMouse, target, transform, _dim) {

      var dist = localMouse.y + localMouse.x,
          lastDist = _dim.y * transform.original.scaleY / target.scaleY +
                     _dim.x * transform.original.scaleX / target.scaleX,
          scaled;

      // We use transform.scaleX/Y instead of target.scaleX/Y
      // because the object may have a min scale and we'll loose the proportions
      transform.newScaleX = transform.original.scaleX * dist / lastDist;
      transform.newScaleY = transform.original.scaleY * dist / lastDist;
      scaled = transform.newScaleX !== target.scaleX || transform.newScaleY !== target.scaleY;
      target.set('scaleX', transform.newScaleX);
      target.set('scaleY', transform.newScaleY);
      return scaled;
    },

    /**
     * @private
     */
    _flipObject: function(transform, by) {
      if (transform.newScaleX < 0 && by !== 'y') {
        if (transform.originX === 'left') {
          transform.originX = 'right';
        }
        else if (transform.originX === 'right') {
          transform.originX = 'left';
        }
      }

      if (transform.newScaleY < 0 && by !== 'x') {
        if (transform.originY === 'top') {
          transform.originY = 'bottom';
        }
        else if (transform.originY === 'bottom') {
          transform.originY = 'top';
        }
      }
    },

    /**
     * @private
     */
    _setLocalMouse: function(localMouse, t) {
      var target = t.target, zoom = this.getZoom(),
          padding = target.padding / zoom;

      if (t.originX === 'right') {
        localMouse.x *= -1;
      }
      else if (t.originX === 'center') {
        localMouse.x *= t.mouseXSign * 2;
        if (localMouse.x < 0) {
          t.mouseXSign = -t.mouseXSign;
        }
      }

      if (t.originY === 'bottom') {
        localMouse.y *= -1;
      }
      else if (t.originY === 'center') {
        localMouse.y *= t.mouseYSign * 2;
        if (localMouse.y < 0) {
          t.mouseYSign = -t.mouseYSign;
        }
      }

      // adjust the mouse coordinates when dealing with padding
      if (abs(localMouse.x) > padding) {
        if (localMouse.x < 0) {
          localMouse.x += padding;
        }
        else {
          localMouse.x -= padding;
        }
      }
      else { // mouse is within the padding, set to 0
        localMouse.x = 0;
      }

      if (abs(localMouse.y) > padding) {
        if (localMouse.y < 0) {
          localMouse.y += padding;
        }
        else {
          localMouse.y -= padding;
        }
      }
      else {
        localMouse.y = 0;
      }
    },

    /**
     * Rotates object by invoking its rotate method
     * @private
     * @param {Number} x pointer's x coordinate
     * @param {Number} y pointer's y coordinate
     * @return {Boolean} true if the rotation occurred
     */
    _rotateObject: function (x, y) {

      var t = this._currentTransform;

      if (t.target.get('lockRotation')) {
        return false;
      }

      var lastAngle = atan2(t.ey - t.top, t.ex - t.left),
          curAngle = atan2(y - t.top, x - t.left),
          angle = radiansToDegrees(curAngle - lastAngle + t.theta),
          hasRoated = true;

      if (t.target.snapAngle > 0) {
        var snapAngle  = t.target.snapAngle,
            snapThreshold  = t.target.snapThreshold || snapAngle,
            rightAngleLocked = Math.ceil(angle / snapAngle) * snapAngle,
            leftAngleLocked = Math.floor(angle / snapAngle) * snapAngle;

        if (Math.abs(angle - leftAngleLocked) < snapThreshold) {
          angle = leftAngleLocked;
        }
        else if (Math.abs(angle - rightAngleLocked) < snapThreshold) {
          angle = rightAngleLocked;
        }
      }

      // normalize angle to positive value
      if (angle < 0) {
        angle = 360 + angle;
      }
      angle %= 360;

      if (t.target.angle === angle) {
        hasRoated = false;
      }
      else {
        t.target.angle = angle;
      }

      return hasRoated;
    },

    /**
     * Set the cursor type of the canvas element
     * @param {String} value Cursor type of the canvas element.
     * @see http://www.w3.org/TR/css3-ui/#cursor
     */
    setCursor: function (value) {
      this.upperCanvasEl.style.cursor = value;
    },

    /**
     * @param {fabric.Object} target to reset transform
     * @private
     */
    _resetObjectTransform: function (target) {
      target.scaleX = 1;
      target.scaleY = 1;
      target.skewX = 0;
      target.skewY = 0;
      target.rotate(0);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx to draw the selection on
     */
    _drawSelection: function (ctx) {
      var groupSelector = this._groupSelector,
          left = groupSelector.left,
          top = groupSelector.top,
          aleft = abs(left),
          atop = abs(top);

      if (this.selectionColor) {
        ctx.fillStyle = this.selectionColor;

        ctx.fillRect(
          groupSelector.ex - ((left > 0) ? 0 : -left),
          groupSelector.ey - ((top > 0) ? 0 : -top),
          aleft,
          atop
        );
      }

      if (!this.selectionLineWidth || !this.selectionBorderColor) {
        return;
      }
      ctx.lineWidth = this.selectionLineWidth;
      ctx.strokeStyle = this.selectionBorderColor;

      // selection border
      if (this.selectionDashArray.length > 1 && !supportLineDash) {

        var px = groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
            py = groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop);

        ctx.beginPath();

        fabric.util.drawDashedLine(ctx, px, py, px + aleft, py, this.selectionDashArray);
        fabric.util.drawDashedLine(ctx, px, py + atop - 1, px + aleft, py + atop - 1, this.selectionDashArray);
        fabric.util.drawDashedLine(ctx, px, py, px, py + atop, this.selectionDashArray);
        fabric.util.drawDashedLine(ctx, px + aleft - 1, py, px + aleft - 1, py + atop, this.selectionDashArray);

        ctx.closePath();
        ctx.stroke();
      }
      else {
        fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);
        ctx.strokeRect(
          groupSelector.ex + STROKE_OFFSET - ((left > 0) ? 0 : aleft),
          groupSelector.ey + STROKE_OFFSET - ((top > 0) ? 0 : atop),
          aleft,
          atop
        );
      }
    },

    /**
     * Method that determines what object we are clicking on
     * the skipGroup parameter is for internal use, is needed for shift+click action
     * @param {Event} e mouse event
     * @param {Boolean} skipGroup when true, activeGroup is skipped and only objects are traversed through
     */
    findTarget: function (e, skipGroup) {
      if (this.skipTargetFind) {
        return;
      }

      var ignoreZoom = true,
          pointer = this.getPointer(e, ignoreZoom),
          activeObject = this._activeObject,
          aObjects = this.getActiveObjects(),
          activeTarget;
      // first check current group (if one exists)
      // active group does not check sub targets like normal groups.
      // if active group just exits.
      this.targets = [];

      if (aObjects.length > 1 && !skipGroup && activeObject === this._searchPossibleTargets([activeObject], pointer)) {
        this._fireOverOutEvents(activeObject, e);
        return activeObject;
      }
      // if we hit the corner of an activeObject, let's return that.
      if (aObjects.length === 1 && activeObject._findTargetCorner(pointer)) {
        this._fireOverOutEvents(activeObject, e);
        return activeObject;
      }
      if (aObjects.length === 1 &&
        activeObject === this._searchPossibleTargets([activeObject], pointer)) {
        if (!this.preserveObjectStacking) {
          this._fireOverOutEvents(activeObject, e);
          return activeObject;
        }
        else {
          activeTarget = activeObject;
        }
      }
      var target = this._searchPossibleTargets(this._objects, pointer);
      if (e[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {
        target = activeTarget;
      }
      this._fireOverOutEvents(target, e);
      return target;
    },

    /**
     * @private
     */
    _fireOverOutEvents: function(target, e) {
      var overOpt, outOpt, hoveredTarget = this._hoveredTarget;
      if (hoveredTarget !== target) {
        overOpt = { e: e, target: target, previousTarget: this._hoveredTarget };
        outOpt = { e: e, target: this._hoveredTarget, nextTarget: target };
        this._hoveredTarget = target;
      }
      if (target) {
        if (hoveredTarget !== target) {
          if (hoveredTarget) {
            this.fire('mouse:out', outOpt);
            hoveredTarget.fire('mouseout', outOpt);
          }
          this.fire('mouse:over', overOpt);
          target.fire('mouseover', overOpt);
        }
      }
      else if (hoveredTarget) {
        this.fire('mouse:out', outOpt);
        hoveredTarget.fire('mouseout', outOpt);
      }
    },

    /**
     * @private
     */
    _checkTarget: function(pointer, obj) {
      if (obj &&
          obj.visible &&
          obj.evented &&
          this.containsPoint(null, obj, pointer)){
        if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {
          var isTransparent = this.isTargetTransparent(obj, pointer.x, pointer.y);
          if (!isTransparent) {
            return true;
          }
        }
        else {
          return true;
        }
      }
    },

    /**
     * @private
     */
    _searchPossibleTargets: function(objects, pointer) {

      // Cache all targets where their bounding box contains point.
      var target, i = objects.length, normalizedPointer, subTarget;
      // Do not check for currently grouped objects, since we check the parent group itself.
      // until we call this function specifically to search inside the activeGroup
      while (i--) {
        if (this._checkTarget(pointer, objects[i])) {
          target = objects[i];
          if (target.type === 'group' && target.subTargetCheck) {
            normalizedPointer = this._normalizePointer(target, pointer);
            subTarget = this._searchPossibleTargets(target._objects, normalizedPointer);
            subTarget && this.targets.push(subTarget);
          }
          break;
        }
      }
      return target;
    },

    /**
     * Returns pointer coordinates without the effect of the viewport
     * @param {Object} pointer with "x" and "y" number values
     * @return {Object} object with "x" and "y" number values
     */
    restorePointerVpt: function(pointer) {
      return fabric.util.transformPoint(
        pointer,
        fabric.util.invertTransform(this.viewportTransform)
      );
    },

    /**
     * Returns pointer coordinates relative to canvas.
     * Can return coordinates with or without viewportTransform.
     * ignoreZoom false gives back coordinates that represent
     * the point clicked on canvas element.
     * ignoreZoom true gives back coordinates after being processed
     * by the viewportTransform ( sort of coordinates of what is displayed
     * on the canvas where you are clicking.
     * To interact with your shapes top and left you want to use ignoreZoom true
     * most of the time, while ignoreZoom false will give you coordinates
     * compatible with the object.oCoords system.
     * of the time.
     * @param {Event} e
     * @param {Boolean} ignoreZoom
     * @return {Object} object with "x" and "y" number values
     */
    getPointer: function (e, ignoreZoom, upperCanvasEl) {
      if (!upperCanvasEl) {
        upperCanvasEl = this.upperCanvasEl;
      }
      var pointer = getPointer(e),
          bounds = upperCanvasEl.getBoundingClientRect(),
          boundsWidth = bounds.width || 0,
          boundsHeight = bounds.height || 0,
          cssScale;

      if (!boundsWidth || !boundsHeight ) {
        if ('top' in bounds && 'bottom' in bounds) {
          boundsHeight = Math.abs( bounds.top - bounds.bottom );
        }
        if ('right' in bounds && 'left' in bounds) {
          boundsWidth = Math.abs( bounds.right - bounds.left );
        }
      }

      this.calcOffset();

      pointer.x = pointer.x - this._offset.left;
      pointer.y = pointer.y - this._offset.top;
      if (!ignoreZoom) {
        pointer = this.restorePointerVpt(pointer);
      }

      if (boundsWidth === 0 || boundsHeight === 0) {
        // If bounds are not available (i.e. not visible), do not apply scale.
        cssScale = { width: 1, height: 1 };
      }
      else {
        cssScale = {
          width: upperCanvasEl.width / boundsWidth,
          height: upperCanvasEl.height / boundsHeight
        };
      }

      return {
        x: pointer.x * cssScale.width,
        y: pointer.y * cssScale.height
      };
    },

    /**
     * @private
     * @throws {CANVAS_INIT_ERROR} If canvas can not be initialized
     */
    _createUpperCanvas: function () {
      var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, '');

      // there is no need to create a new upperCanvas element if we have already one.
      if (this.upperCanvasEl) {
        this.upperCanvasEl.className = '';
      }
      else {
        this.upperCanvasEl = this._createCanvasElement();
      }
      fabric.util.addClass(this.upperCanvasEl, 'upper-canvas ' + lowerCanvasClass);

      this.wrapperEl.appendChild(this.upperCanvasEl);

      this._copyCanvasStyle(this.lowerCanvasEl, this.upperCanvasEl);
      this._applyCanvasStyle(this.upperCanvasEl);
      this.contextTop = this.upperCanvasEl.getContext('2d');
    },

    /**
     * @private
     */
    _createCacheCanvas: function () {
      this.cacheCanvasEl = this._createCanvasElement();
      this.cacheCanvasEl.setAttribute('width', this.width);
      this.cacheCanvasEl.setAttribute('height', this.height);
      this.contextCache = this.cacheCanvasEl.getContext('2d');
    },

    /**
     * @private
     */
    _initWrapperElement: function () {
      this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, 'div', {
        'class': this.containerClass
      });
      fabric.util.setStyle(this.wrapperEl, {
        width: this.width + 'px',
        height: this.height + 'px',
        position: 'relative'
      });
      fabric.util.makeElementUnselectable(this.wrapperEl);
    },

    /**
     * @private
     * @param {HTMLElement} element canvas element to apply styles on
     */
    _applyCanvasStyle: function (element) {
      var width = this.width || element.width,
          height = this.height || element.height;

      fabric.util.setStyle(element, {
        position: 'absolute',
        width: width + 'px',
        height: height + 'px',
        left: 0,
        top: 0,
        'touch-action': 'none'
      });
      element.width = width;
      element.height = height;
      fabric.util.makeElementUnselectable(element);
    },

    /**
     * Copy the entire inline style from one element (fromEl) to another (toEl)
     * @private
     * @param {Element} fromEl Element style is copied from
     * @param {Element} toEl Element copied style is applied to
     */
    _copyCanvasStyle: function (fromEl, toEl) {
      toEl.style.cssText = fromEl.style.cssText;
    },

    /**
     * Returns context of canvas where object selection is drawn
     * @return {CanvasRenderingContext2D}
     */
    getSelectionContext: function() {
      return this.contextTop;
    },

    /**
     * Returns &lt;canvas> element on which object selection is drawn
     * @return {HTMLCanvasElement}
     */
    getSelectionElement: function () {
      return this.upperCanvasEl;
    },

    /**
     * Returns currently active object
     * @return {fabric.Object} active object
     */
    getActiveObject: function () {
      return this._activeObject;
    },

    /**
     * Returns an array with the current selected objects
     * @return {fabric.Object} active object
     */
    getActiveObjects: function () {
      var active = this._activeObject;
      if (active) {
        if (active.type === 'activeSelection' && active._objects) {
          return active._objects;
        }
        else {
          return [active];
        }
      }
      return [];
    },

    /**
     * @private
     * @param {fabric.Object} obj Object that was removed
     */
    _onObjectRemoved: function(obj) {
      // removing active object should fire "selection:cleared" events
      if (obj === this._activeObject) {
        this.fire('before:selection:cleared', { target: obj });
        this._discardActiveObject();
        this.fire('selection:cleared', { target: obj });
        obj.fire('deselected');
      }
      if (this._hoveredTarget === obj) {
        this._hoveredTarget = null;
      }
      this.callSuper('_onObjectRemoved', obj);
    },

    /**
     * Sets given object as the only active object on canvas
     * @param {fabric.Object} object Object to set as an active one
     * @param {Event} [e] Event (passed along when firing "object:selected")
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    setActiveObject: function (object, e) {
      var currentActiveObject = this._activeObject;
      if (object === currentActiveObject) {
        return this;
      }
      if (this._setActiveObject(object, e)) {
        currentActiveObject && currentActiveObject.fire('deselected', { e: e });
        this.fire('object:selected', { target: object, e: e });
        object.fire('selected', { e: e });
      }
      return this;
    },

    /**
     * @private
     * @param {Object} object to set as active
     * @param {Event} [e] Event (passed along when firing "object:selected")
     */
    _setActiveObject: function(object, e) {
      var active = this._activeObject;
      if (active === object || object.onSelect({ e: e })) {
        return false;
      }
      if (this._discardActiveObject(e)) {
        this._activeObject = object;
        object.set('active', true);
        return true;
      }
      return false;
    },

    /**
     * @private
     */
    _discardActiveObject: function(e) {
      var obj = this._activeObject;
      if (obj && obj.onDeselect && typeof obj.onDeselect === 'function') {
        // onDeselect return TRUE to cancel selection;
        if (obj.onDeselect({ e: e })) {
          return false;
        }
        obj.set('active', false);
        this._activeObject = null;
      }
      return true;
    },

    /**
     * Discards currently active object and fire events. If the function is called by fabric
     * as a consequence of a mouse event, the event is passed as a parameter and
     * sent to the fire function for the custom events. When used as a method the
     * e param does not have any application.
     * @param {event} e
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    discardActiveObject: function (e) {
      var activeObject = this._activeObject;
      if (activeObject) {
        this.fire('before:selection:cleared', { target: activeObject, e: e });
        if (this._discardActiveObject(e)) {
          this.fire('selection:cleared', { e: e });
          activeObject.fire('deselected', { e: e });
        }
      }
      return this;
    },

    /**
     * Clears a canvas element and removes all event listeners
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    dispose: function () {
      fabric.StaticCanvas.prototype.dispose.call(this);
      var wrapper = this.wrapperEl;
      this.removeListeners();
      wrapper.removeChild(this.upperCanvasEl);
      wrapper.removeChild(this.lowerCanvasEl);
      delete this.upperCanvasEl;
      if (wrapper.parentNode) {
        wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);
      }
      delete this.wrapperEl;
      return this;
    },

    /**
     * Clears all contexts (background, main, top) of an instance
     * @return {fabric.Canvas} thisArg
     * @chainable
     */
    clear: function () {
      // this.discardActiveGroup();
      this.discardActiveObject();
      this.clearContext(this.contextTop);
      return this.callSuper('clear');
    },

    /**
     * Draws objects' controls (borders/controls)
     * @param {CanvasRenderingContext2D} ctx Context to render controls on
     */
    drawControls: function(ctx) {
      var activeObject = this._activeObject;

      if (activeObject) {
        activeObject._renderControls(ctx);
      }
    },

    /**
     * @private
     */
    _toObject: function(instance, methodName, propertiesToInclude) {
      //If the object is part of the current selection group, it should
      //be transformed appropriately
      //i.e. it should be serialised as it would appear if the selection group
      //were to be destroyed.
      var originalProperties = this._realizeGroupTransformOnObject(instance),
          object = this.callSuper('_toObject', instance, methodName, propertiesToInclude);
      //Undo the damage we did by changing all of its properties
      this._unwindGroupTransformOnObject(instance, originalProperties);
      return object;
    },

    /**
     * Realises an object's group transformation on it
     * @private
     * @param {fabric.Object} [instance] the object to transform (gets mutated)
     * @returns the original values of instance which were changed
     */
    _realizeGroupTransformOnObject: function(instance) {
      if (instance.group && instance.group.type === 'activeSelection' && this._activeObject === instance.group) {
        var layoutProps = ['angle', 'flipX', 'flipY', 'left', 'scaleX', 'scaleY', 'skewX', 'skewY', 'top'];
        //Copy all the positionally relevant properties across now
        var originalValues = {};
        layoutProps.forEach(function(prop) {
          originalValues[prop] = instance[prop];
        });
        this._activeObject.realizeTransform(instance);
        return originalValues;
      }
      else {
        return null;
      }
    },

    /**
     * Restores the changed properties of instance
     * @private
     * @param {fabric.Object} [instance] the object to un-transform (gets mutated)
     * @param {Object} [originalValues] the original values of instance, as returned by _realizeGroupTransformOnObject
     */
    _unwindGroupTransformOnObject: function(instance, originalValues) {
      if (originalValues) {
        instance.set(originalValues);
      }
    },

    /**
     * @private
     */
    _setSVGObject: function(markup, instance, reviver) {
      //If the object is in a selection group, simulate what would happen to that
      //object when the group is deselected
      var originalProperties = this._realizeGroupTransformOnObject(instance);
      this.callSuper('_setSVGObject', markup, instance, reviver);
      this._unwindGroupTransformOnObject(instance, originalProperties);
    },
  });

  // copying static properties manually to work around Opera's bug,
  // where "prototype" property is enumerable and overrides existing prototype
  for (var prop in fabric.StaticCanvas) {
    if (prop !== 'prototype') {
      fabric.Canvas[prop] = fabric.StaticCanvas[prop];
    }
  }

  if (fabric.isTouchSupported) {
    /** @ignore */
    fabric.Canvas.prototype._setCursorFromEvent = function() { };
  }
})();


(function() {

  var cursorOffset = {
        mt: 0, // n
        tr: 1, // ne
        mr: 2, // e
        br: 3, // se
        mb: 4, // s
        bl: 5, // sw
        ml: 6, // w
        tl: 7 // nw
      },
      addListener = fabric.util.addListener,
      removeListener = fabric.util.removeListener,
      RIGHT_CLICK = 3, MIDDLE_CLICK = 2, LEFT_CLICK = 1;

  function checkClick(e, value) {
    return 'which' in e ? e.which === value : e.button === value - 1;
  }

  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {

    /**
     * Map of cursor style values for each of the object controls
     * @private
     */
    cursorMap: [
      'n-resize',
      'ne-resize',
      'e-resize',
      'se-resize',
      's-resize',
      'sw-resize',
      'w-resize',
      'nw-resize'
    ],

    /**
     * Adds mouse listeners to canvas
     * @private
     */
    _initEventListeners: function () {
      // in case we initialized the class twice. This should not happen normally
      // but in some kind of applications where the canvas element may be changed
      // this is a workaround to having double listeners.
      this.removeListeners();
      this._bindEvents();

      addListener(fabric.window, 'resize', this._onResize);

      // mouse events
      addListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);
      addListener(this.upperCanvasEl, 'dblclick', this._onDoubleClick);
      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);
      addListener(this.upperCanvasEl, 'mouseout', this._onMouseOut);
      addListener(this.upperCanvasEl, 'mouseenter', this._onMouseEnter);
      addListener(this.upperCanvasEl, 'wheel', this._onMouseWheel);
      addListener(this.upperCanvasEl, 'contextmenu', this._onContextMenu);

      // touch events
      addListener(this.upperCanvasEl, 'touchstart', this._onMouseDown, { passive: false });
      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove, { passive: false });

      if (typeof eventjs !== 'undefined' && 'add' in eventjs) {
        eventjs.add(this.upperCanvasEl, 'gesture', this._onGesture);
        eventjs.add(this.upperCanvasEl, 'drag', this._onDrag);
        eventjs.add(this.upperCanvasEl, 'orientation', this._onOrientationChange);
        eventjs.add(this.upperCanvasEl, 'shake', this._onShake);
        eventjs.add(this.upperCanvasEl, 'longpress', this._onLongPress);
      }
    },

    /**
     * @private
     */
    _bindEvents: function() {
      if (this.eventsBinded) {
        // for any reason we pass here twice we do not want to bind events twice.
        return;
      }
      this._onMouseDown = this._onMouseDown.bind(this);
      this._onMouseMove = this._onMouseMove.bind(this);
      this._onMouseUp = this._onMouseUp.bind(this);
      this._onResize = this._onResize.bind(this);
      this._onGesture = this._onGesture.bind(this);
      this._onDrag = this._onDrag.bind(this);
      this._onShake = this._onShake.bind(this);
      this._onLongPress = this._onLongPress.bind(this);
      this._onOrientationChange = this._onOrientationChange.bind(this);
      this._onMouseWheel = this._onMouseWheel.bind(this);
      this._onMouseOut = this._onMouseOut.bind(this);
      this._onMouseEnter = this._onMouseEnter.bind(this);
      this._onContextMenu = this._onContextMenu.bind(this);
      this._onDoubleClick = this._onDoubleClick.bind(this);
      this.eventsBinded = true;
    },

    /**
     * Removes all event listeners
     */
    removeListeners: function() {
      removeListener(fabric.window, 'resize', this._onResize);

      removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);
      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);
      removeListener(this.upperCanvasEl, 'mouseout', this._onMouseOut);
      removeListener(this.upperCanvasEl, 'mouseenter', this._onMouseEnter);
      removeListener(this.upperCanvasEl, 'wheel', this._onMouseWheel);
      removeListener(this.upperCanvasEl, 'contextmenu', this._onContextMenu);
      removeListener(this.upperCanvasEl, 'doubleclick', this._onDoubleClick);
      removeListener(this.upperCanvasEl, 'touchstart', this._onMouseDown);
      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);

      if (typeof eventjs !== 'undefined' && 'remove' in eventjs) {
        eventjs.remove(this.upperCanvasEl, 'gesture', this._onGesture);
        eventjs.remove(this.upperCanvasEl, 'drag', this._onDrag);
        eventjs.remove(this.upperCanvasEl, 'orientation', this._onOrientationChange);
        eventjs.remove(this.upperCanvasEl, 'shake', this._onShake);
        eventjs.remove(this.upperCanvasEl, 'longpress', this._onLongPress);
      }
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js gesture
     * @param {Event} [self] Inner Event object
     */
    _onGesture: function(e, self) {
      this.__onTransformGesture && this.__onTransformGesture(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js drag
     * @param {Event} [self] Inner Event object
     */
    _onDrag: function(e, self) {
      this.__onDrag && this.__onDrag(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on wheel event
     */
    _onMouseWheel: function(e) {
      this.__onMouseWheel(e);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onMouseOut: function(e) {
      var target = this._hoveredTarget;
      this.fire('mouse:out', { target: target, e: e });
      this._hoveredTarget = null;
      target && target.fire('mouseout', { e: e });
      if (this._iTextInstances) {
        this._iTextInstances.forEach(function(obj) {
          if (obj.isEditing) {
            obj.hiddenTextarea.focus();
          }
        });
      }
    },

    /**
     * @private
     * @param {Event} e Event object fired on mouseenter
     */
    _onMouseEnter: function(e) {
      if (!this.findTarget(e)) {
        this.fire('mouse:over', { target: null, e: e });
        this._hoveredTarget = null;
      }
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js orientation change
     * @param {Event} [self] Inner Event object
     */
    _onOrientationChange: function(e, self) {
      this.__onOrientationChange && this.__onOrientationChange(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js shake
     * @param {Event} [self] Inner Event object
     */
    _onShake: function(e, self) {
      this.__onShake && this.__onShake(e, self);
    },

    /**
     * @private
     * @param {Event} [e] Event object fired on Event.js shake
     * @param {Event} [self] Inner Event object
     */
    _onLongPress: function(e, self) {
      this.__onLongPress && this.__onLongPress(e, self);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onContextMenu: function (e) {
      if (this.stopContextMenu) {
        e.stopPropagation();
        e.preventDefault();
      }
      return false;
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onDoubleClick: function (e) {
      var target;
      this._handleEvent(e, 'dblclick', target);
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onMouseDown: function (e) {
      this.__onMouseDown(e);
      addListener(fabric.document, 'touchend', this._onMouseUp, { passive: false });
      addListener(fabric.document, 'touchmove', this._onMouseMove, { passive: false });

      removeListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);
      removeListener(this.upperCanvasEl, 'touchmove', this._onMouseMove);

      if (e.type === 'touchstart') {
        // Unbind mousedown to prevent double triggers from touch devices
        removeListener(this.upperCanvasEl, 'mousedown', this._onMouseDown);
      }
      else {
        addListener(fabric.document, 'mouseup', this._onMouseUp);
        addListener(fabric.document, 'mousemove', this._onMouseMove);
      }
    },

    /**
     * @private
     * @param {Event} e Event object fired on mouseup
     */
    _onMouseUp: function (e) {
      this.__onMouseUp(e);

      removeListener(fabric.document, 'mouseup', this._onMouseUp);
      removeListener(fabric.document, 'touchend', this._onMouseUp);

      removeListener(fabric.document, 'mousemove', this._onMouseMove);
      removeListener(fabric.document, 'touchmove', this._onMouseMove);

      addListener(this.upperCanvasEl, 'mousemove', this._onMouseMove);
      addListener(this.upperCanvasEl, 'touchmove', this._onMouseMove, { passive: false });

      if (e.type === 'touchend') {
        // Wait 400ms before rebinding mousedown to prevent double triggers
        // from touch devices
        var _this = this;
        setTimeout(function() {
          addListener(_this.upperCanvasEl, 'mousedown', _this._onMouseDown);
        }, 400);
      }
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousemove
     */
    _onMouseMove: function (e) {
      !this.allowTouchScrolling && e.preventDefault && e.preventDefault();
      this.__onMouseMove(e);
    },

    /**
     * @private
     */
    _onResize: function () {
      this.calcOffset();
    },

    /**
     * Decides whether the canvas should be redrawn in mouseup and mousedown events.
     * @private
     * @param {Object} target
     * @param {Object} pointer
     */
    _shouldRender: function(target, pointer) {
      var activeObject = this._activeObject;

      if (activeObject && activeObject.isEditing && target === activeObject) {
        // if we mouse up/down over a editing textbox a cursor change,
        // there is no need to re render
        return false;
      }
      return !!(
        (target && (
          target.isMoving ||
          target !== activeObject))
        ||
        (!target && !!activeObject)
        ||
        (!target && !activeObject && !this._groupSelector)
        ||
        (pointer &&
          this._previousPointer &&
          this.selection && (
          pointer.x !== this._previousPointer.x ||
          pointer.y !== this._previousPointer.y))
      );
    },

    /**
     * Method that defines the actions when mouse is released on canvas.
     * The method resets the currentTransform parameters, store the image corner
     * position in the image object and render the canvas on top.
     * @private
     * @param {Event} e Event object fired on mouseup
     */
    __onMouseUp: function (e) {

      var target;
      // if right/middle click just fire events and return
      // target undefined will make the _handleEvent search the target
      if (checkClick(e, RIGHT_CLICK)) {
        if (this.fireRightClick) {
          this._handleEvent(e, 'up', target, RIGHT_CLICK);
        }
        return;
      }

      if (checkClick(e, MIDDLE_CLICK)) {
        if (this.fireMiddleClick) {
          this._handleEvent(e, 'up', target, MIDDLE_CLICK);
        }
        return;
      }

      if (this.isDrawingMode && this._isCurrentlyDrawing) {
        this._onMouseUpInDrawingMode(e);
        return;
      }

      var searchTarget = true, transform = this._currentTransform,
          groupSelector = this._groupSelector,
          isClick = (!groupSelector || (groupSelector.left === 0 && groupSelector.top === 0));

      if (transform) {
        this._finalizeCurrentTransform(e);
        searchTarget = !transform.actionPerformed;
      }

      target = searchTarget ? this.findTarget(e, true) : transform.target;

      var shouldRender = this._shouldRender(target, this.getPointer(e));

      if (target || !isClick) {
        this._maybeGroupObjects(e);
      }
      else {
        // those are done by default on mouse up
        // by _maybeGroupObjects, we are skipping it in case of no target find
        this._groupSelector = null;
        this._currentTransform = null;
      }

      if (target) {
        target.isMoving = false;
      }
      this._setCursorFromEvent(e, target);
      this._handleEvent(e, 'up', target ? target : null, LEFT_CLICK, isClick);
      target && (target.__corner = 0);
      shouldRender && this.requestRenderAll();
    },

    /**
     * @private
     * Handle event firing for target and subtargets
     * @param {Event} e event from mouse
     * @param {String} eventType event to fire (up, down or move)
     * @param {fabric.Object} targetObj receiving event
     * @param {Number} [button] button used in the event 1 = left, 2 = middle, 3 = right
     * @param {Boolean} isClick for left button only, indicates that the mouse up happened without move.
     */
    _handleEvent: function(e, eventType, targetObj, button, isClick) {
      var target = typeof targetObj === 'undefined' ? this.findTarget(e) : targetObj,
          targets = this.targets || [],
          options = {
            e: e,
            target: target,
            subTargets: targets,
            button: button || LEFT_CLICK,
            isClick: isClick || false
          };
      this.fire('mouse:' + eventType, options);
      target && target.fire('mouse' + eventType, options);
      for (var i = 0; i < targets.length; i++) {
        targets[i].fire('mouse' + eventType, options);
      }
    },

    /**
     * @private
     * @param {Event} e send the mouse event that generate the finalize down, so it can be used in the event
     */
    _finalizeCurrentTransform: function(e) {

      var transform = this._currentTransform,
          target = transform.target;

      if (target._scaling) {
        target._scaling = false;
      }

      target.setCoords();
      this._restoreOriginXY(target);

      if (transform.actionPerformed || (this.stateful && target.hasStateChanged())) {
        this.fire('object:modified', { target: target, e: e });
        target.fire('modified', { e: e });
      }
    },

    /**
     * @private
     * @param {Object} target Object to restore
     */
    _restoreOriginXY: function(target) {
      if (this._previousOriginX && this._previousOriginY) {

        var originPoint = target.translateToOriginPoint(
          target.getCenterPoint(),
          this._previousOriginX,
          this._previousOriginY);

        target.originX = this._previousOriginX;
        target.originY = this._previousOriginY;

        target.left = originPoint.x;
        target.top = originPoint.y;

        this._previousOriginX = null;
        this._previousOriginY = null;
      }
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    _onMouseDownInDrawingMode: function(e) {
      this._isCurrentlyDrawing = true;
      this.discardActiveObject(e).requestRenderAll();
      if (this.clipTo) {
        fabric.util.clipContext(this, this.contextTop);
      }
      var pointer = this.getPointer(e);
      this.freeDrawingBrush.onMouseDown(pointer);
      this._handleEvent(e, 'down');
    },

    /**
     * @private
     * @param {Event} e Event object fired on mousemove
     */
    _onMouseMoveInDrawingMode: function(e) {
      if (this._isCurrentlyDrawing) {
        var pointer = this.getPointer(e);
        this.freeDrawingBrush.onMouseMove(pointer);
      }
      this.setCursor(this.freeDrawingCursor);
      this._handleEvent(e, 'move');
    },

    /**
     * @private
     * @param {Event} e Event object fired on mouseup
     */
    _onMouseUpInDrawingMode: function(e) {
      this._isCurrentlyDrawing = false;
      if (this.clipTo) {
        this.contextTop.restore();
      }
      this.freeDrawingBrush.onMouseUp();
      this._handleEvent(e, 'up');
    },

    /**
     * Method that defines the actions when mouse is clicked on canvas.
     * The method inits the currentTransform parameters and renders all the
     * canvas so the current image can be placed on the top canvas and the rest
     * in on the container one.
     * @private
     * @param {Event} e Event object fired on mousedown
     */
    __onMouseDown: function (e) {

      var target = this.findTarget(e);

      // if right click just fire events
      if (checkClick(e, RIGHT_CLICK)) {
        if (this.fireRightClick) {
          this._handleEvent(e, 'down', target ? target : null, RIGHT_CLICK);
        }
        return;
      }

      if (checkClick(e, MIDDLE_CLICK)) {
        if (this.fireMiddleClick) {
          this._handleEvent(e, 'down', target ? target : null, MIDDLE_CLICK);
        }
        return;
      }

      if (this.isDrawingMode) {
        this._onMouseDownInDrawingMode(e);
        return;
      }

      // ignore if some object is being transformed at this moment
      if (this._currentTransform) {
        return;
      }

      // save pointer for check in __onMouseUp event
      var pointer = this.getPointer(e, true);
      this._previousPointer = pointer;
      var shouldRender = this._shouldRender(target, pointer),
          shouldGroup = this._shouldGroup(e, target);
      if (this._shouldClearSelection(e, target)) {
        this.discardActiveObject(e);
      }
      else if (shouldGroup) {
        this._handleGrouping(e, target);
        target = this._activeObject;
      }

      if (this.selection && (!target ||
        (!target.selectable && !target.isEditing && target !== this._activeObject))) {
        this._groupSelector = {
          ex: pointer.x,
          ey: pointer.y,
          top: 0,
          left: 0
        };
      }

      if (target) {
        if ((target.selectable || target === this._activeObject) && (target.__corner || !shouldGroup)) {
          this._beforeTransform(e, target);
          this._setupCurrentTransform(e, target);
        }
        if (target.selectable) {
          this.setActiveObject(target, e);
        }
      }
      this._handleEvent(e, 'down', target ? target : null);
      // we must renderAll so that we update the visuals
      shouldRender && this.requestRenderAll();
    },

    /**
     * @private
     */
    _beforeTransform: function(e, target) {
      this.stateful && target.saveState();

      // determine if it's a drag or rotate case
      if (target._findTargetCorner(this.getPointer(e))) {
        this.onBeforeScaleRotate(target);
      }

    },

    /**
     * @private
     * @param {Object} target Object for that origin is set to center
     */
    _setOriginToCenter: function(target) {
      this._previousOriginX = this._currentTransform.target.originX;
      this._previousOriginY = this._currentTransform.target.originY;

      var center = target.getCenterPoint();

      target.originX = 'center';
      target.originY = 'center';

      target.left = center.x;
      target.top = center.y;

      this._currentTransform.left = target.left;
      this._currentTransform.top = target.top;
    },

    /**
     * @private
     * @param {Object} target Object for that center is set to origin
     */
    _setCenterToOrigin: function(target) {
      var originPoint = target.translateToOriginPoint(
        target.getCenterPoint(),
        this._previousOriginX,
        this._previousOriginY);

      target.originX = this._previousOriginX;
      target.originY = this._previousOriginY;

      target.left = originPoint.x;
      target.top = originPoint.y;

      this._previousOriginX = null;
      this._previousOriginY = null;
    },

    /**
     * Method that defines the actions when mouse is hovering the canvas.
     * The currentTransform parameter will definde whether the user is rotating/scaling/translating
     * an image or neither of them (only hovering). A group selection is also possible and would cancel
     * all any other type of action.
     * In case of an image transformation only the top canvas will be rendered.
     * @private
     * @param {Event} e Event object fired on mousemove
     */
    __onMouseMove: function (e) {

      var target, pointer;

      if (this.isDrawingMode) {
        this._onMouseMoveInDrawingMode(e);
        return;
      }
      if (typeof e.touches !== 'undefined' && e.touches.length > 1) {
        return;
      }

      var groupSelector = this._groupSelector;

      // We initially clicked in an empty area, so we draw a box for multiple selection
      if (groupSelector) {
        pointer = this.getPointer(e, true);

        groupSelector.left = pointer.x - groupSelector.ex;
        groupSelector.top = pointer.y - groupSelector.ey;

        this.renderTop();
      }
      else if (!this._currentTransform) {
        target = this.findTarget(e);
        this._setCursorFromEvent(e, target);
      }
      else {
        this._transformObject(e);
      }
      this._handleEvent(e, 'move', target ? target : null);
    },

    /**
     * Method that defines actions when an Event Mouse Wheel
     * @param {Event} e Event object fired on mouseup
     */
    __onMouseWheel: function(e) {
      this._handleEvent(e, 'wheel');
    },

    /**
     * @private
     * @param {Event} e Event fired on mousemove
     */
    _transformObject: function(e) {
      var pointer = this.getPointer(e),
          transform = this._currentTransform;

      transform.reset = false;
      transform.target.isMoving = true;
      transform.shiftKey = e.shiftKey;
      transform.altKey = e[this.centeredKey];

      this._beforeScaleTransform(e, transform);
      this._performTransformAction(e, transform, pointer);

      transform.actionPerformed && this.requestRenderAll();
    },

    /**
     * @private
     */
    _performTransformAction: function(e, transform, pointer) {
      var x = pointer.x,
          y = pointer.y,
          target = transform.target,
          action = transform.action,
          actionPerformed = false;

      if (action === 'rotate') {
        (actionPerformed = this._rotateObject(x, y)) && this._fire('rotating', target, e);
      }
      else if (action === 'scale') {
        (actionPerformed = this._onScale(e, transform, x, y)) && this._fire('scaling', target, e);
      }
      else if (action === 'scaleX') {
        (actionPerformed = this._scaleObject(x, y, 'x')) && this._fire('scaling', target, e);
      }
      else if (action === 'scaleY') {
        (actionPerformed = this._scaleObject(x, y, 'y')) && this._fire('scaling', target, e);
      }
      else if (action === 'skewX') {
        (actionPerformed = this._skewObject(x, y, 'x')) && this._fire('skewing', target, e);
      }
      else if (action === 'skewY') {
        (actionPerformed = this._skewObject(x, y, 'y')) && this._fire('skewing', target, e);
      }
      else {
        actionPerformed = this._translateObject(x, y);
        if (actionPerformed) {
          this._fire('moving', target, e);
          this.setCursor(target.moveCursor || this.moveCursor);
        }
      }
      transform.actionPerformed = transform.actionPerformed || actionPerformed;
    },

    /**
     * @private
     */
    _fire: function(eventName, target, e) {
      this.fire('object:' + eventName, { target: target, e: e });
      target.fire(eventName, { e: e });
    },

    /**
     * @private
     */
    _beforeScaleTransform: function(e, transform) {
      if (transform.action === 'scale' || transform.action === 'scaleX' || transform.action === 'scaleY') {
        var centerTransform = this._shouldCenterTransform(transform.target);

        // Switch from a normal resize to center-based
        if ((centerTransform && (transform.originX !== 'center' || transform.originY !== 'center')) ||
           // Switch from center-based resize to normal one
           (!centerTransform && transform.originX === 'center' && transform.originY === 'center')
        ) {
          this._resetCurrentTransform();
          transform.reset = true;
        }
      }
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {Object} transform current tranform
     * @param {Number} x mouse position x from origin
     * @param {Number} y mouse poistion y from origin
     * @return {Boolean} true if the scaling occurred
     */
    _onScale: function(e, transform, x, y) {
      if (this._isUniscalePossible(e, transform.target)) {
        transform.currentAction = 'scale';
        return this._scaleObject(x, y);
      }
      else {
        // Switch from a normal resize to proportional
        if (!transform.reset && transform.currentAction === 'scale') {
          this._resetCurrentTransform();
        }

        transform.currentAction = 'scaleEqually';
        return this._scaleObject(x, y, 'equally');
      }
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target current target
     * @return {Boolean} true if unproportional scaling is possible
     */
    _isUniscalePossible: function(e, target) {
      return (e[this.uniScaleKey] || this.uniScaleTransform) && !target.get('lockUniScaling');
    },

    /**
     * Sets the cursor depending on where the canvas is being hovered.
     * Note: very buggy in Opera
     * @param {Event} e Event object
     * @param {Object} target Object that the mouse is hovering, if so.
     */
    _setCursorFromEvent: function (e, target) {
      if (!target) {
        this.setCursor(this.defaultCursor);
        return false;
      }

      var hoverCursor = target.hoverCursor || this.hoverCursor,
          activeSelection = this._activeObject && this._activeObject.type === 'activeSelection' ?
            this._activeObject : null,
          // only show proper corner when group selection is not active
          corner = (!activeSelection || !activeSelection.contains(target))
                    && target._findTargetCorner(this.getPointer(e, true));

      if (!corner) {
        this.setCursor(hoverCursor);
      }
      else {
        this.setCursor(this.getCornerCursor(corner, target, e));
      }
    },

    /**
     * @private
     */
    getCornerCursor: function(corner, target, e) {
      if (this.actionIsDisabled(corner, target, e)) {
        return this.notAllowedCursor;
      }
      else if (corner in cursorOffset) {
        return this._getRotatedCornerCursor(corner, target, e);
      }
      else if (corner === 'mtr' && target.hasRotatingPoint) {
        return this.rotationCursor;
      }
      else {
        return this.defaultCursor;
      }
    },

    actionIsDisabled: function(corner, target, e) {
      if (corner === 'mt' || corner === 'mb') {
        return e[this.altActionKey] ? target.lockSkewingX : target.lockScalingY;
      }
      else if (corner === 'ml' || corner === 'mr') {
        return e[this.altActionKey] ? target.lockSkewingY : target.lockScalingX;
      }
      else if (corner === 'mtr') {
        return target.lockRotation;
      }
      else {
        return this._isUniscalePossible(e, target) ?
          target.lockScalingX && target.lockScalingY : target.lockScalingX || target.lockScalingY;
      }
    },

    /**
     * @private
     */
    _getRotatedCornerCursor: function(corner, target, e) {
      var n = Math.round((target.angle % 360) / 45);

      if (n < 0) {
        n += 8; // full circle ahead
      }
      n += cursorOffset[corner];
      if (e[this.altActionKey] && cursorOffset[corner] % 2 === 0) {
        //if we are holding shift and we are on a mx corner...
        n += 2;
      }
      // normalize n to be from 0 to 7
      n %= 8;

      return this.cursorMap[n];
    }
  });
})();


(function() {

  var min = Math.min,
      max = Math.max;

  fabric.util.object.extend(fabric.Canvas.prototype, /** @lends fabric.Canvas.prototype */ {

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     * @return {Boolean}
     */
    _shouldGroup: function(e, target) {
      var activeObject = this._activeObject;
      return activeObject && e[this.selectionKey] && target && target.selectable && this.selection &&
            (activeObject !== target || activeObject.type === 'activeSelection');
    },

    /**
     * @private
     * @param {Event} e Event object
     * @param {fabric.Object} target
     */
    _handleGrouping: function (e, target) {
      var activeObject = this._activeObject;
      if (activeObject.__corner) {
        return;
      }
      if (target === activeObject) {
        // if it's a group, find target again, using activeGroup objects
        target = this.findTarget(e, true);
        // if even object is not found or we are on activeObjectCorner, bail out
        if (!target) {
          return;
        }
      }
      if (activeObject && activeObject.type === 'activeSelection') {
        this._updateActiveSelection(target, e);
      }
      else {
        this._createActiveSelection(target, e);
      }
    },

    /**
     * @private
     */
    _updateActiveSelection: function(target, e) {
      var activeSelection = this._activeObject;
      if (activeSelection.contains(target)) {
        activeSelection.removeWithUpdate(target);
        if (activeSelection.size() === 1) {
          // activate last remaining object
          this.setActiveObject(activeSelection.item(0), e);
          return;
        }
      }
      else {
        activeSelection.addWithUpdate(target);
      }
      this.fire('selection:created', { target: activeSelection, e: e });
    },

    /**
     * @private
     */
    _createActiveSelection: function(target, e) {
      var group = this._createGroup(target);
      this.setActiveObject(group, e);
      this.fire('selection:created', { target: group, e: e });
    },

    /**
     * @private
     * @param {Object} target
     */
    _createGroup: function(target) {
      var objects = this.getObjects(),
          isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target),
          groupObjects = isActiveLower
            ? [this._activeObject, target]
            : [target, this._activeObject];
      this._activeObject.isEditing && this._activeObject.exitEditing();
      return new fabric.ActiveSelection(groupObjects, {
        canvas: this
      });
    },

    /**
     * @private
     * @param {Event} e mouse event
     */
    _groupSelectedObjects: function (e) {

      var group = this._collectObjects();

      // do not create group for 1 element only
      if (group.length === 1) {
        this.setActiveObject(group[0], e);
      }
      else if (group.length > 1) {
        group = new fabric.ActiveSelection(group.reverse(), {
          canvas: this
        });
        this.setActiveObject(group, e);
        this.fire('selection:created', { target: group, e: e });
        this.requestRenderAll();
      }
    },

    /**
     * @private
     */
    _collectObjects: function() {
      var group = [],
          currentObject,
          x1 = this._groupSelector.ex,
          y1 = this._groupSelector.ey,
          x2 = x1 + this._groupSelector.left,
          y2 = y1 + this._groupSelector.top,
          selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)),
          selectionX2Y2 = new fabric.Point(max(x1, x2), max(y1, y2)),
          isClick = x1 === x2 && y1 === y2;

      for (var i = this._objects.length; i--; ) {
        currentObject = this._objects[i];

        if (!currentObject || !currentObject.selectable || !currentObject.visible) {
          continue;
        }

        if (currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2) ||
            currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2) ||
            currentObject.containsPoint(selectionX1Y1) ||
            currentObject.containsPoint(selectionX2Y2)
        ) {
          group.push(currentObject);

          // only add one object if it's a click
          if (isClick) {
            break;
          }
        }
      }

      return group;
    },

    /**
     * @private
     */
    _maybeGroupObjects: function(e) {
      if (this.selection && this._groupSelector) {
        this._groupSelectedObjects(e);
      }
      this.setCursor(this.defaultCursor);
      // clear selection and current transformation
      this._groupSelector = null;
      this._currentTransform = null;
    }
  });

})();


(function () {

  var supportQuality = fabric.StaticCanvas.supports('toDataURLWithQuality');

  fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

    /**
     * Exports canvas element to a dataurl image. Note that when multiplier is used, cropping is scaled appropriately
     * @param {Object} [options] Options object
     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
     * @param {Number} [options.multiplier=1] Multiplier to scale by
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
     * @see {@link http://jsfiddle.net/fabricjs/NfZVb/|jsFiddle demo}
     * @example <caption>Generate jpeg dataURL with lower quality</caption>
     * var dataURL = canvas.toDataURL({
     *   format: 'jpeg',
     *   quality: 0.8
     * });
     * @example <caption>Generate cropped png dataURL (clipping of canvas)</caption>
     * var dataURL = canvas.toDataURL({
     *   format: 'png',
     *   left: 100,
     *   top: 100,
     *   width: 200,
     *   height: 200
     * });
     * @example <caption>Generate double scaled png dataURL</caption>
     * var dataURL = canvas.toDataURL({
     *   format: 'png',
     *   multiplier: 2
     * });
     */
    toDataURL: function (options) {
      options || (options = { });

      var format = options.format || 'png',
          quality = options.quality || 1,
          multiplier = options.multiplier || 1,
          cropping = {
            left: options.left || 0,
            top: options.top || 0,
            width: options.width || 0,
            height: options.height || 0,
          };
      return this.__toDataURLWithMultiplier(format, quality, cropping, multiplier);
    },

    /**
     * @private
     */
    __toDataURLWithMultiplier: function(format, quality, cropping, multiplier) {

      var origWidth = this.width,
          origHeight = this.height,
          scaledWidth = (cropping.width || this.width) * multiplier,
          scaledHeight = (cropping.height || this.height) * multiplier,
          zoom = this.getZoom(),
          newZoom = zoom * multiplier,
          vp = this.viewportTransform,
          translateX = (vp[4] - cropping.left) * multiplier,
          translateY = (vp[5] - cropping.top) * multiplier,
          newVp = [newZoom, 0, 0, newZoom, translateX, translateY],
          originalInteractive = this.interactive,
          originalSkipOffScreen = this.skipOffscreen;

      this.viewportTransform = newVp;
      this.skipOffscreen = false;
      // setting interactive to false avoid exporting controls
      this.interactive = false;
      if (origWidth !== scaledWidth || origHeight !== scaledHeight) {
        this.setDimensions({ width: scaledWidth, height: scaledHeight });
      }
      // call a renderAll to force sync update. This will cancel the scheduled requestRenderAll
      // from setDimensions
      this.renderAll();
      var data = this.__toDataURL(format, quality, cropping);
      this.interactive = originalInteractive;
      this.skipOffscreen = originalSkipOffScreen;
      this.viewportTransform = vp;
      //setDimensions with no option object is taking care of:
      //this.width, this.height, this.requestRenderAll()
      this.setDimensions({ width: origWidth, height: origHeight });
      return data;
    },

    /**
     * @private
     */
    __toDataURL: function(format, quality) {

      var canvasEl = this.contextContainer.canvas;
      // to avoid common confusion https://github.com/kangax/fabric.js/issues/806
      if (format === 'jpg') {
        format = 'jpeg';
      }

      var data = supportQuality
                ? canvasEl.toDataURL('image/' + format, quality)
                : canvasEl.toDataURL('image/' + format);

      return data;
    },
  });

})();


fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

  /**
   * Populates canvas with data from the specified dataless JSON.
   * JSON format must conform to the one of {@link fabric.Canvas#toDatalessJSON}
   * @deprecated since 1.2.2
   * @param {String|Object} json JSON string or object
   * @param {Function} callback Callback, invoked when json is parsed
   *                            and corresponding objects (e.g: {@link fabric.Image})
   *                            are initialized
   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
   * @return {fabric.Canvas} instance
   * @chainable
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
   */
  loadFromDatalessJSON: function (json, callback, reviver) {
    return this.loadFromJSON(json, callback, reviver);
  },

  /**
   * Populates canvas with data from the specified JSON.
   * JSON format must conform to the one of {@link fabric.Canvas#toJSON}
   * @param {String|Object} json JSON string or object
   * @param {Function} callback Callback, invoked when json is parsed
   *                            and corresponding objects (e.g: {@link fabric.Image})
   *                            are initialized
   * @param {Function} [reviver] Method for further parsing of JSON elements, called after each fabric object created.
   * @return {fabric.Canvas} instance
   * @chainable
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#deserialization}
   * @see {@link http://jsfiddle.net/fabricjs/fmgXt/|jsFiddle demo}
   * @example <caption>loadFromJSON</caption>
   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas));
   * @example <caption>loadFromJSON with reviver</caption>
   * canvas.loadFromJSON(json, canvas.renderAll.bind(canvas), function(o, object) {
   *   // `o` = json object
   *   // `object` = fabric.Object instance
   *   // ... do some stuff ...
   * });
   */
  loadFromJSON: function (json, callback, reviver) {
    if (!json) {
      return;
    }

    // serialize if it wasn't already
    var serialized = (typeof json === 'string')
      ? JSON.parse(json)
      : fabric.util.object.clone(json);

    var _this = this,
        renderOnAddRemove = this.renderOnAddRemove;
    this.renderOnAddRemove = false;

    this._enlivenObjects(serialized.objects, function (enlivenedObjects) {
      _this.clear();
      _this._setBgOverlay(serialized, function () {
        enlivenedObjects.forEach(function(obj, index) {
          // we splice the array just in case some custom classes restored from JSON
          // will add more object to canvas at canvas init.
          _this.insertAt(obj, index);
        });
        _this.renderOnAddRemove = renderOnAddRemove;
        // remove parts i cannot set as options
        delete serialized.objects;
        delete serialized.backgroundImage;
        delete serialized.overlayImage;
        delete serialized.background;
        delete serialized.overlay;
        // this._initOptions does too many things to just
        // call it. Normally loading an Object from JSON
        // create the Object instance. Here the Canvas is
        // already an instance and we are just loading things over it
        _this._setOptions(serialized);
        _this.renderAll();
        callback && callback();
      });
    }, reviver);
    return this;
  },

  /**
   * @private
   * @param {Object} serialized Object with background and overlay information
   * @param {Function} callback Invoked after all background and overlay images/patterns loaded
   */
  _setBgOverlay: function(serialized, callback) {
    var loaded = {
      backgroundColor: false,
      overlayColor: false,
      backgroundImage: false,
      overlayImage: false
    };

    if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {
      callback && callback();
      return;
    }

    var cbIfLoaded = function () {
      if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {
        callback && callback();
      }
    };

    this.__setBgOverlay('backgroundImage', serialized.backgroundImage, loaded, cbIfLoaded);
    this.__setBgOverlay('overlayImage', serialized.overlayImage, loaded, cbIfLoaded);
    this.__setBgOverlay('backgroundColor', serialized.background, loaded, cbIfLoaded);
    this.__setBgOverlay('overlayColor', serialized.overlay, loaded, cbIfLoaded);
  },

  /**
   * @private
   * @param {String} property Property to set (backgroundImage, overlayImage, backgroundColor, overlayColor)
   * @param {(Object|String)} value Value to set
   * @param {Object} loaded Set loaded property to true if property is set
   * @param {Object} callback Callback function to invoke after property is set
   */
  __setBgOverlay: function(property, value, loaded, callback) {
    var _this = this;

    if (!value) {
      loaded[property] = true;
      callback && callback();
      return;
    }

    if (property === 'backgroundImage' || property === 'overlayImage') {
      fabric.util.enlivenObjects([value], function(enlivedObject){
        _this[property] = enlivedObject[0];
        loaded[property] = true;
        callback && callback();
      });
    }
    else {
      this['set' + fabric.util.string.capitalize(property, true)](value, function() {
        loaded[property] = true;
        callback && callback();
      });
    }
  },

  /**
   * @private
   * @param {Array} objects
   * @param {Function} callback
   * @param {Function} [reviver]
   */
  _enlivenObjects: function (objects, callback, reviver) {
    if (!objects || objects.length === 0) {
      callback && callback([]);
      return;
    }

    fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
      callback && callback(enlivenedObjects);
    }, null, reviver);
  },

  /**
   * @private
   * @param {String} format
   * @param {Function} callback
   */
  _toDataURL: function (format, callback) {
    this.clone(function (clone) {
      callback(clone.toDataURL(format));
    });
  },

  /**
   * @private
   * @param {String} format
   * @param {Number} multiplier
   * @param {Function} callback
   */
  _toDataURLWithMultiplier: function (format, multiplier, callback) {
    this.clone(function (clone) {
      callback(clone.toDataURLWithMultiplier(format, multiplier));
    });
  },

  /**
   * Clones canvas instance
   * @param {Object} [callback] Receives cloned instance as a first argument
   * @param {Array} [properties] Array of properties to include in the cloned canvas and children
   */
  clone: function (callback, properties) {
    var data = JSON.stringify(this.toJSON(properties));
    this.cloneWithoutData(function(clone) {
      clone.loadFromJSON(data, function() {
        callback && callback(clone);
      });
    });
  },

  /**
   * Clones canvas instance without cloning existing data.
   * This essentially copies canvas dimensions, clipping properties, etc.
   * but leaves data empty (so that you can populate it with your own)
   * @param {Object} [callback] Receives cloned instance as a first argument
   */
  cloneWithoutData: function(callback) {
    var el = fabric.document.createElement('canvas');

    el.width = this.width;
    el.height = this.height;

    var clone = new fabric.Canvas(el);
    clone.clipTo = this.clipTo;
    if (this.backgroundImage) {
      clone.setBackgroundImage(this.backgroundImage.src, function() {
        clone.renderAll();
        callback && callback(clone);
      });
      clone.backgroundImageOpacity = this.backgroundImageOpacity;
      clone.backgroundImageStretch = this.backgroundImageStretch;
    }
    else {
      callback && callback(clone);
    }
  }
});


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      clone = fabric.util.object.clone,
      toFixed = fabric.util.toFixed,
      capitalize = fabric.util.string.capitalize,
      degreesToRadians = fabric.util.degreesToRadians,
      supportsLineDash = fabric.StaticCanvas.supports('setLineDash'),
      objectCaching = !fabric.isLikelyNode,
      ALIASING_LIMIT = 2;

  if (fabric.Object) {
    return;
  }

  /**
   * Root object class from which all 2d shape classes inherit from
   * @class fabric.Object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#objects}
   * @see {@link fabric.Object#initialize} for constructor definition
   *
   * @fires added
   * @fires removed
   *
   * @fires selected
   * @fires deselected
   * @fires modified
   * @fires rotating
   * @fires scaling
   * @fires moving
   * @fires skewing
   *
   * @fires mousedown
   * @fires mouseup
   * @fires mouseover
   * @fires mouseout
   * @fires mousewheel
   * @fires mousedblclick
   */
  fabric.Object = fabric.util.createClass(fabric.CommonMethods, /** @lends fabric.Object.prototype */ {

    /**
     * Type of an object (rect, circle, path, etc.).
     * Note that this property is meant to be read-only and not meant to be modified.
     * If you modify, certain parts of Fabric (such as JSON loading) won't work correctly.
     * @type String
     * @default
     */
    type:                     'object',

    /**
     * Horizontal origin of transformation of an object (one of "left", "right", "center")
     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
     * @type String
     * @default
     */
    originX:                  'left',

    /**
     * Vertical origin of transformation of an object (one of "top", "bottom", "center")
     * See http://jsfiddle.net/1ow02gea/244/ on how originX/originY affect objects in groups
     * @type String
     * @default
     */
    originY:                  'top',

    /**
     * Top position of an object. Note that by default it's relative to object top. You can change this by setting originY={top/center/bottom}
     * @type Number
     * @default
     */
    top:                      0,

    /**
     * Left position of an object. Note that by default it's relative to object left. You can change this by setting originX={left/center/right}
     * @type Number
     * @default
     */
    left:                     0,

    /**
     * Object width
     * @type Number
     * @default
     */
    width:                    0,

    /**
     * Object height
     * @type Number
     * @default
     */
    height:                   0,

    /**
     * Object scale factor (horizontal)
     * @type Number
     * @default
     */
    scaleX:                   1,

    /**
     * Object scale factor (vertical)
     * @type Number
     * @default
     */
    scaleY:                   1,

    /**
     * When true, an object is rendered as flipped horizontally
     * @type Boolean
     * @default
     */
    flipX:                    false,

    /**
     * When true, an object is rendered as flipped vertically
     * @type Boolean
     * @default
     */
    flipY:                    false,

    /**
     * Opacity of an object
     * @type Number
     * @default
     */
    opacity:                  1,

    /**
     * Angle of rotation of an object (in degrees)
     * @type Number
     * @default
     */
    angle:                    0,

    /**
     * Angle of skew on x axes of an object (in degrees)
     * @type Number
     * @default
     */
    skewX:                    0,

    /**
     * Angle of skew on y axes of an object (in degrees)
     * @type Number
     * @default
     */
    skewY:                    0,

    /**
     * Size of object's controlling corners (in pixels)
     * @type Number
     * @default
     */
    cornerSize:               13,

    /**
     * When true, object's controlling corners are rendered as transparent inside (i.e. stroke instead of fill)
     * @type Boolean
     * @default
     */
    transparentCorners:       true,

    /**
     * Default cursor value used when hovering over this object on canvas
     * @type String
     * @default
     */
    hoverCursor:              null,

    /**
     * Default cursor value used when moving this object on canvas
     * @type String
     * @default
     */
    moveCursor:               null,

    /**
     * Padding between object and its controlling borders (in pixels)
     * @type Number
     * @default
     */
    padding:                  0,

    /**
     * Color of controlling borders of an object (when it's active)
     * @type String
     * @default
     */
    borderColor:              'rgba(102,153,255,0.75)',

    /**
     * Array specifying dash pattern of an object's borders (hasBorder must be true)
     * @since 1.6.2
     * @type Array
     */
    borderDashArray:          null,

    /**
     * Color of controlling corners of an object (when it's active)
     * @type String
     * @default
     */
    cornerColor:              'rgba(102,153,255,0.5)',

    /**
     * Color of controlling corners of an object (when it's active and transparentCorners false)
     * @since 1.6.2
     * @type String
     * @default
     */
    cornerStrokeColor:        null,

    /**
     * Specify style of control, 'rect' or 'circle'
     * @since 1.6.2
     * @type String
     */
    cornerStyle:          'rect',

    /**
     * Array specifying dash pattern of an object's control (hasBorder must be true)
     * @since 1.6.2
     * @type Array
     */
    cornerDashArray:          null,

    /**
     * When true, this object will use center point as the origin of transformation
     * when being scaled via the controls.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredScaling:          false,

    /**
     * When true, this object will use center point as the origin of transformation
     * when being rotated via the controls.
     * <b>Backwards incompatibility note:</b> This property replaces "centerTransform" (Boolean).
     * @since 1.3.4
     * @type Boolean
     * @default
     */
    centeredRotation:         true,

    /**
     * Color of object's fill
     * @type String
     * @default
     */
    fill:                     'rgb(0,0,0)',

    /**
     * Fill rule used to fill an object
     * accepted values are nonzero, evenodd
     * <b>Backwards incompatibility note:</b> This property was used for setting globalCompositeOperation until v1.4.12 (use `fabric.Object#globalCompositeOperation` instead)
     * @type String
     * @default
     */
    fillRule:                 'nonzero',

    /**
     * Composite rule used for canvas globalCompositeOperation
     * @type String
     * @default
     */
    globalCompositeOperation: 'source-over',

    /**
     * Background color of an object.
     * @type String
     * @default
     */
    backgroundColor:          '',

    /**
     * Selection Background color of an object. colored layer behind the object when it is active.
     * does not mix good with globalCompositeOperation methods.
     * @type String
     * @default
     */
    selectionBackgroundColor:          '',

    /**
     * When defined, an object is rendered via stroke and this property specifies its color
     * @type String
     * @default
     */
    stroke:                   null,

    /**
     * Width of a stroke used to render this object
     * @type Number
     * @default
     */
    strokeWidth:              1,

    /**
     * Array specifying dash pattern of an object's stroke (stroke must be defined)
     * @type Array
     */
    strokeDashArray:          null,

    /**
     * Line endings style of an object's stroke (one of "butt", "round", "square")
     * @type String
     * @default
     */
    strokeLineCap:            'butt',

    /**
     * Corner style of an object's stroke (one of "bevil", "round", "miter")
     * @type String
     * @default
     */
    strokeLineJoin:           'miter',

    /**
     * Maximum miter length (used for strokeLineJoin = "miter") of an object's stroke
     * @type Number
     * @default
     */
    strokeMiterLimit:         10,

    /**
     * Shadow object representing shadow of this shape
     * @type fabric.Shadow
     * @default
     */
    shadow:                   null,

    /**
     * Opacity of object's controlling borders when object is active and moving
     * @type Number
     * @default
     */
    borderOpacityWhenMoving:  0.4,

    /**
     * Scale factor of object's controlling borders
     * @type Number
     * @default
     */
    borderScaleFactor:        1,

    /**
     * Transform matrix (similar to SVG's transform matrix)
     * @type Array
     */
    transformMatrix:          null,

    /**
     * Minimum allowed scale value of an object
     * @type Number
     * @default
     */
    minScaleLimit:            0.01,

    /**
     * When set to `false`, an object can not be selected for modification (using either point-click-based or group-based selection).
     * But events still fire on it.
     * @type Boolean
     * @default
     */
    selectable:               true,

    /**
     * When set to `false`, an object can not be a target of events. All events propagate through it. Introduced in v1.3.4
     * @type Boolean
     * @default
     */
    evented:                  true,

    /**
     * When set to `false`, an object is not rendered on canvas
     * @type Boolean
     * @default
     */
    visible:                  true,

    /**
     * When set to `false`, object's controls are not displayed and can not be used to manipulate object
     * @type Boolean
     * @default
     */
    hasControls:              true,

    /**
     * When set to `false`, object's controlling borders are not rendered
     * @type Boolean
     * @default
     */
    hasBorders:               true,

    /**
     * When set to `false`, object's controlling rotating point will not be visible or selectable
     * @type Boolean
     * @default
     */
    hasRotatingPoint:         true,

    /**
     * Offset for object's controlling rotating point (when enabled via `hasRotatingPoint`)
     * @type Number
     * @default
     */
    rotatingPointOffset:      40,

    /**
     * When set to `true`, objects are "found" on canvas on per-pixel basis rather than according to bounding box
     * @type Boolean
     * @default
     */
    perPixelTargetFind:       false,

    /**
     * When `false`, default object's values are not included in its serialization
     * @type Boolean
     * @default
     */
    includeDefaultValues:     true,

    /**
     * Function that determines clipping of an object (context is passed as a first argument)
     * Note that context origin is at the object's center point (not left/top corner)
     * @deprecated since 2.0.0
     * @type Function
     */
    clipTo:                   null,

    /**
     * When `true`, object horizontal movement is locked
     * @type Boolean
     * @default
     */
    lockMovementX:            false,

    /**
     * When `true`, object vertical movement is locked
     * @type Boolean
     * @default
     */
    lockMovementY:            false,

    /**
     * When `true`, object rotation is locked
     * @type Boolean
     * @default
     */
    lockRotation:             false,

    /**
     * When `true`, object horizontal scaling is locked
     * @type Boolean
     * @default
     */
    lockScalingX:             false,

    /**
     * When `true`, object vertical scaling is locked
     * @type Boolean
     * @default
     */
    lockScalingY:             false,

    /**
     * When `true`, object non-uniform scaling is locked
     * @type Boolean
     * @default
     */
    lockUniScaling:           false,

    /**
     * When `true`, object horizontal skewing is locked
     * @type Boolean
     * @default
     */
    lockSkewingX:             false,

    /**
     * When `true`, object vertical skewing is locked
     * @type Boolean
     * @default
     */
    lockSkewingY:             false,

    /**
     * When `true`, object cannot be flipped by scaling into negative values
     * @type Boolean
     * @default
     */
    lockScalingFlip:          false,

    /**
     * When `true`, object is not exported in SVG or OBJECT/JSON
     * since 1.6.3
     * @type Boolean
     * @default
     */
    excludeFromExport:        false,

    /**
     * When `true`, object is cached on an additional canvas.
     * default to true
     * since 1.7.0
     * @type Boolean
     * @default true
     */
    objectCaching:            objectCaching,

    /**
     * When `true`, object properties are checked for cache invalidation. In some particular
     * situation you may want this to be disabled ( spray brush, very big, groups)
     * or if your application does not allow you to modify properties for groups child you want
     * to disable it for groups.
     * default to false
     * since 1.7.0
     * @type Boolean
     * @default false
     */
    statefullCache:            false,

    /**
     * When `true`, cache does not get updated during scaling. The picture will get blocky if scaled
     * too much and will be redrawn with correct details at the end of scaling.
     * this setting is performance and application dependant.
     * default to true
     * since 1.7.0
     * @type Boolean
     * @default true
     */
    noScaleCache:              true,

    /**
     * When set to `true`, object's cache will be rerendered next render call.
     * since 1.7.0
     * @type Boolean
     * @default true
     */
    dirty:                true,

    /**
     * keeps the value of the last hovered coner during mouse move.
     * 0 is no corner, or 'mt', 'ml', 'mtr' etc..
     * It should be private, but there is no harm in using it as
     * a read-only property.
     * @type number|string|any
     * @default 0
     */
    __corner: 0,

    /**
     * List of properties to consider when checking if state
     * of an object is changed (fabric.Object#hasStateChanged)
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: (
      'top left width height scaleX scaleY flipX flipY originX originY transformMatrix ' +
      'stroke strokeWidth strokeDashArray strokeLineCap strokeLineJoin strokeMiterLimit ' +
      'angle opacity fill globalCompositeOperation shadow clipTo visible backgroundColor ' +
      'skewX skewY fillRule'
    ).split(' '),

    /**
     * List of properties to consider when checking if cache needs refresh
     * @type Array
     */
    cacheProperties: (
      'fill stroke strokeWidth strokeDashArray width height' +
      ' strokeLineCap strokeLineJoin strokeMiterLimit backgroundColor'
    ).split(' '),

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      if (options) {
        this.setOptions(options);
      }
    },

    /**
     * Create a the canvas used to keep the cached copy of the object
     * @private
     */
    _createCacheCanvas: function() {
      this._cacheProperties = {};
      this._cacheCanvas = fabric.document.createElement('canvas');
      this._cacheContext = this._cacheCanvas.getContext('2d');
      this._updateCacheCanvas();
    },

    /**
     * Limit the cache dimensions so that X * Y do not cross fabric.perfLimitSizeTotal
     * and each side do not cross fabric.cacheSideLimit
     * those numbers are configurable so that you can get as much detail as you want
     * making bargain with performances.
     * @param {Object} dims
     * @param {Object} dims.width width of canvas
     * @param {Object} dims.height height of canvas
     * @param {Object} dims.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @param {Object} dims.zoomY zoomY zoom value to unscale the canvas before drawing cache
     * @return {Object}.width width of canvas
     * @return {Object}.height height of canvas
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
     */
    _limitCacheSize: function(dims) {
      var perfLimitSizeTotal = fabric.perfLimitSizeTotal,
          maximumSide = fabric.cacheSideLimit,
          width = dims.width, height = dims.height,
          ar = width / height, limitedDims = fabric.util.limitDimsByArea(ar, perfLimitSizeTotal, maximumSide),
          capValue = fabric.util.capValue, max = fabric.maxCacheSideLimit, min = fabric.minCacheSideLimit,
          x = capValue(min, limitedDims.x, max),
          y = capValue(min, limitedDims.y, max);
      if (width > x) {
        dims.zoomX /= width / x;
        dims.width = x;
      }
      else if (width < min) {
        dims.width = min;
      }
      if (height > y) {
        dims.zoomY /= height / y;
        dims.height = y;
      }
      else if (height < min) {
        dims.height = min;
      }
      return dims;
    },

    /**
     * Return the dimension and the zoom level needed to create a cache canvas
     * big enough to host the object to be cached.
     * @private
     * @return {Object}.width width of canvas
     * @return {Object}.height height of canvas
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
     */
    _getCacheCanvasDimensions: function() {
      var zoom = this.canvas && this.canvas.getZoom() || 1,
          objectScale = this.getObjectScaling(),
          dim = this._getNonTransformedDimensions(),
          retina = this.canvas && this.canvas._isRetinaScaling() ? fabric.devicePixelRatio : 1,
          zoomX = objectScale.scaleX * zoom * retina,
          zoomY = objectScale.scaleY * zoom * retina,
          width = dim.x * zoomX,
          height = dim.y * zoomY;
      return {
        width: width + ALIASING_LIMIT,
        height: height + ALIASING_LIMIT,
        zoomX: zoomX,
        zoomY: zoomY
      };
    },

    /**
     * Update width and height of the canvas for cache
     * returns true or false if canvas needed resize.
     * @private
     * @return {Boolean} true if the canvas has been resized
     */
    _updateCacheCanvas: function() {
      if (this.noScaleCache && this.canvas && this.canvas._currentTransform) {
        var action = this.canvas._currentTransform.action;
        if (action.slice && action.slice(0, 5) === 'scale') {
          return false;
        }
      }
      var dims = this._limitCacheSize(this._getCacheCanvasDimensions()),
          minCacheSize = fabric.minCacheSideLimit,
          width = dims.width, height = dims.height,
          zoomX = dims.zoomX, zoomY = dims.zoomY,
          dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight,
          zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY,
          shouldRedraw = dimensionsChanged || zoomChanged,
          additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;
      if (dimensionsChanged) {
        var canvasWidth = this._cacheCanvas.width,
            canvasHeight = this._cacheCanvas.height,
            sizeGrowing = width > canvasWidth || height > canvasHeight,
            sizeShrinking = (width < canvasWidth * 0.9 || height < canvasHeight * 0.9) &&
              canvasWidth > minCacheSize && canvasHeight > minCacheSize;
        shouldResizeCanvas = sizeGrowing || sizeShrinking;
        if (sizeGrowing) {
          additionalWidth = (width * 0.1) & ~1;
          additionalHeight = (height * 0.1) & ~1;
        }
      }
      if (shouldRedraw) {
        if (shouldResizeCanvas) {
          this._cacheCanvas.width = Math.max(Math.ceil(width) + additionalWidth, minCacheSize);
          this._cacheCanvas.height = Math.max(Math.ceil(height) + additionalHeight, minCacheSize);
          this.cacheTranslationX = (width + additionalWidth) / 2;
          this.cacheTranslationY = (height + additionalHeight) / 2;
        }
        else {
          this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);
          this._cacheContext.clearRect(0, 0, this._cacheCanvas.width, this._cacheCanvas.height);
        }
        this.cacheWidth = width;
        this.cacheHeight = height;
        this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);
        this._cacheContext.scale(zoomX, zoomY);
        this.zoomX = zoomX;
        this.zoomY = zoomY;
        return true;
      }
      return false;
    },

    /**
     * Sets object's properties from options
     * @param {Object} [options] Options object
     */
    setOptions: function(options) {
      this._setOptions(options);
      this._initGradient(options.fill, 'fill');
      this._initGradient(options.stroke, 'stroke');
      this._initClipping(options);
      this._initPattern(options.fill, 'fill');
      this._initPattern(options.stroke, 'stroke');
    },

    /**
     * Transforms context when rendering an object
     * @param {CanvasRenderingContext2D} ctx Context
     * @param {Boolean} fromLeft When true, context is transformed to object's top/left corner. This is used when rendering text on Node
     */
    transform: function(ctx, fromLeft) {
      if (this.group && !this.group._transformDone) {
        this.group.transform(ctx);
      }
      var center = fromLeft ? this._getLeftTopCoords() : this.getCenterPoint();
      ctx.translate(center.x, center.y);
      this.angle && ctx.rotate(degreesToRadians(this.angle));
      ctx.scale(
        this.scaleX * (this.flipX ? -1 : 1),
        this.scaleY * (this.flipY ? -1 : 1)
      );
      this.skewX && ctx.transform(1, 0, Math.tan(degreesToRadians(this.skewX)), 1, 0, 0);
      this.skewY && ctx.transform(1, Math.tan(degreesToRadians(this.skewY)), 0, 1, 0, 0);
    },

    /**
     * Returns an object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,

          object = {
            type:                     this.type,
            originX:                  this.originX,
            originY:                  this.originY,
            left:                     toFixed(this.left, NUM_FRACTION_DIGITS),
            top:                      toFixed(this.top, NUM_FRACTION_DIGITS),
            width:                    toFixed(this.width, NUM_FRACTION_DIGITS),
            height:                   toFixed(this.height, NUM_FRACTION_DIGITS),
            fill:                     (this.fill && this.fill.toObject) ? this.fill.toObject() : this.fill,
            stroke:                   (this.stroke && this.stroke.toObject) ? this.stroke.toObject() : this.stroke,
            strokeWidth:              toFixed(this.strokeWidth, NUM_FRACTION_DIGITS),
            strokeDashArray:          this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
            strokeLineCap:            this.strokeLineCap,
            strokeLineJoin:           this.strokeLineJoin,
            strokeMiterLimit:         toFixed(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
            scaleX:                   toFixed(this.scaleX, NUM_FRACTION_DIGITS),
            scaleY:                   toFixed(this.scaleY, NUM_FRACTION_DIGITS),
            angle:                    toFixed(this.angle, NUM_FRACTION_DIGITS),
            flipX:                    this.flipX,
            flipY:                    this.flipY,
            opacity:                  toFixed(this.opacity, NUM_FRACTION_DIGITS),
            shadow:                   (this.shadow && this.shadow.toObject) ? this.shadow.toObject() : this.shadow,
            visible:                  this.visible,
            clipTo:                   this.clipTo && String(this.clipTo),
            backgroundColor:          this.backgroundColor,
            fillRule:                 this.fillRule,
            globalCompositeOperation: this.globalCompositeOperation,
            transformMatrix:          this.transformMatrix ? this.transformMatrix.concat() : null,
            skewX:                    toFixed(this.skewX, NUM_FRACTION_DIGITS),
            skewY:                    toFixed(this.skewY, NUM_FRACTION_DIGITS)
          };

      fabric.util.populateWithProperties(this, object, propertiesToInclude);
      if (!this.includeDefaultValues) {
        object = this._removeDefaultValues(object);
      }

      return object;
    },

    /**
     * Returns (dataless) object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toDatalessObject: function(propertiesToInclude) {
      // will be overwritten by subclasses
      return this.toObject(propertiesToInclude);
    },

    /**
     * @private
     * @param {Object} object
     */
    _removeDefaultValues: function(object) {
      var prototype = fabric.util.getKlass(object.type).prototype,
          stateProperties = prototype.stateProperties;
      stateProperties.forEach(function(prop) {
        if (object[prop] === prototype[prop]) {
          delete object[prop];
        }
        var isArray = Object.prototype.toString.call(object[prop]) === '[object Array]' &&
                      Object.prototype.toString.call(prototype[prop]) === '[object Array]';

        // basically a check for [] === []
        if (isArray && object[prop].length === 0 && prototype[prop].length === 0) {
          delete object[prop];
        }
      });

      return object;
    },

    /**
     * Returns a string representation of an instance
     * @return {String}
     */
    toString: function() {
      return '#<fabric.' + capitalize(this.type) + '>';
    },

    /**
     * Return the object scale factor counting also the group scaling
     * @return {Object} object with scaleX and scaleY properties
     */
    getObjectScaling: function() {
      var scaleX = this.scaleX, scaleY = this.scaleY;
      if (this.group) {
        var scaling = this.group.getObjectScaling();
        scaleX *= scaling.scaleX;
        scaleY *= scaling.scaleY;
      }
      return { scaleX: scaleX, scaleY: scaleY };
    },

    /**
     * Return the object opacity counting also the group property
     * @return {Object} object with scaleX and scaleY properties
     */
    getObjectOpacity: function() {
      var opacity = this.opacity;
      if (this.group) {
        opacity *= this.group.getObjectOpacity();
      }
      return opacity;
    },

    /**
     * @private
     * @param {String} key
     * @param {*} value
     * @return {fabric.Object} thisArg
     */
    _set: function(key, value) {
      var shouldConstrainValue = (key === 'scaleX' || key === 'scaleY');

      if (shouldConstrainValue) {
        value = this._constrainScale(value);
      }
      if (key === 'scaleX' && value < 0) {
        this.flipX = !this.flipX;
        value *= -1;
      }
      else if (key === 'scaleY' && value < 0) {
        this.flipY = !this.flipY;
        value *= -1;
      }
      else if (key === 'shadow' && value && !(value instanceof fabric.Shadow)) {
        value = new fabric.Shadow(value);
      }
      else if (key === 'dirty' && this.group) {
        this.group.set('dirty', value);
      }

      this[key] = value;

      if (this.cacheProperties.indexOf(key) > -1) {
        if (this.group) {
          this.group.set('dirty', true);
        }
        this.dirty = true;
      }

      if (this.group && this.stateProperties.indexOf(key) > -1 && this.group.isOnACache()) {
        this.group.set('dirty', true);
      }

      if (key === 'width' || key === 'height') {
        this.minScaleLimit = Math.min(0.1, 1 / Math.max(this.width, this.height));
      }

      return this;
    },

    /**
     * This callback function is called by the parent group of an object every
     * time a non-delegated property changes on the group. It is passed the key
     * and value as parameters. Not adding in this function's signature to avoid
     * Travis build error about unused variables.
     */
    setOnGroup: function() {
      // implemented by sub-classes, as needed.
    },

    /**
     * This callback function is called every time _discardActiveObject or _setActiveObject
     * try to to deselect this object. If the function returns true, the process is cancelled
     * @param {Object} [options] options sent from the upper functions
     * @param {Event} [options.e] event if the process is generated by an event
     */
    onDeselect: function() {
      // implemented by sub-classes, as needed.
    },


    /**
     * This callback function is called every time _discardActiveObject or _setActiveObject
     * try to to select this object. If the function returns true, the process is cancelled
     * @param {Object} [options] options sent from the upper functions
     * @param {Event} [options.e] event if the process is generated by an event
     */
    onSelect: function() {
      // implemented by sub-classes, as needed.
    },


    /**
     * Retrieves viewportTransform from Object's canvas if possible
     * @method getViewportTransform
     * @memberOf fabric.Object.prototype
     * @return {Boolean}
     */
    getViewportTransform: function() {
      if (this.canvas && this.canvas.viewportTransform) {
        return this.canvas.viewportTransform;
      }
      return fabric.iMatrix.concat();
    },

    /*
     * @private
     * return if the object would be visible in rendering
     * @memberOf fabric.Object.prototype
     * @return {Boolean}
     */
    isNotVisible: function() {
      return this.opacity === 0 || (this.width === 0 && this.height === 0) || !this.visible;
    },

    /**
     * Renders an object on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    render: function(ctx) {
      // do not render if width/height are zeros or object is not visible
      if (this.isNotVisible()) {
        return;
      }
      if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
        return;
      }
      ctx.save();
      this._setupCompositeOperation(ctx);
      this.drawSelectionBackground(ctx);
      this.transform(ctx);
      this._setOpacity(ctx);
      this._setShadow(ctx, this);
      if (this.transformMatrix) {
        ctx.transform.apply(ctx, this.transformMatrix);
      }
      this.clipTo && fabric.util.clipContext(this, ctx);
      if (this.shouldCache()) {
        if (!this._cacheCanvas) {
          this._createCacheCanvas();
        }
        if (this.isCacheDirty()) {
          this.statefullCache && this.saveState({ propertySet: 'cacheProperties' });
          this.drawObject(this._cacheContext);
          this.dirty = false;
        }
        this.drawCacheOnCanvas(ctx);
      }
      else {
        this.dirty = false;
        this.drawObject(ctx);
        if (this.objectCaching && this.statefullCache) {
          this.saveState({ propertySet: 'cacheProperties' });
        }
      }
      this.clipTo && ctx.restore();
      ctx.restore();
    },

    /**
     * When set to `true`, force the object to have its own cache, even if it is inside a group
     * it may be needed when your object behave in a particular way on the cache and always needs
     * its own isolated canvas to render correctly.
     * Created to be overridden
     * since 1.7.12
     * @returns false
     */
    needsItsOwnCache: function() {
      return false;
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * objectCaching is a global flag, wins over everything
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group outside is cached.
     * @return {Boolean}
     */
    shouldCache: function() {
      this.ownCaching = this.objectCaching &&
      (!this.group || this.needsItsOwnCache() || !this.group.isOnACache());
      return this.ownCaching;
    },

    /**
     * Check if this object or a child object will cast a shadow
     * used by Group.shouldCache to know if child has a shadow recursively
     * @return {Boolean}
     */
    willDrawShadow: function() {
      return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
    },

    /**
     * Execute the drawing operation for an object on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawObject: function(ctx) {
      this._renderBackground(ctx);
      this._setStrokeStyles(ctx, this);
      this._setFillStyles(ctx, this);
      this._render(ctx);
    },

    /**
     * Paint the cached copy of the object on the target context.
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawCacheOnCanvas: function(ctx) {
      ctx.scale(1 / this.zoomX, 1 / this.zoomY);
      ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
    },

    /**
     * Check if cache is dirty
     * @param {Boolean} skipCanvas skip canvas checks because this object is painted
     * on parent canvas.
     */
    isCacheDirty: function(skipCanvas) {
      if (this.isNotVisible()) {
        return false;
      }
      if (this._cacheCanvas && !skipCanvas && this._updateCacheCanvas()) {
        // in this case the context is already cleared.
        return true;
      }
      else {
        if (this.dirty || (this.statefullCache && this.hasStateChanged('cacheProperties'))) {
          if (this._cacheCanvas && !skipCanvas) {
            var width = this.cacheWidth / this.zoomX;
            var height = this.cacheHeight / this.zoomY;
            this._cacheContext.clearRect(-width / 2, -height / 2, width, height);
          }
          return true;
        }
      }
      return false;
    },

    /**
     * Draws a background for the object big as its untrasformed dimensions
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderBackground: function(ctx) {
      if (!this.backgroundColor) {
        return;
      }
      var dim = this._getNonTransformedDimensions();
      ctx.fillStyle = this.backgroundColor;

      ctx.fillRect(
        -dim.x / 2,
        -dim.y / 2,
        dim.x,
        dim.y
      );
      // if there is background color no other shadows
      // should be casted
      this._removeShadow(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _setOpacity: function(ctx) {
      if (this.group && !this.group._transformDone) {
        ctx.globalAlpha = this.getObjectOpacity();
      }
      else {
        ctx.globalAlpha *= this.opacity;
      }
    },

    _setStrokeStyles: function(ctx, decl) {
      if (decl.stroke) {
        ctx.lineWidth = decl.strokeWidth;
        ctx.lineCap = decl.strokeLineCap;
        ctx.lineJoin = decl.strokeLineJoin;
        ctx.miterLimit = decl.strokeMiterLimit;
        ctx.strokeStyle = decl.stroke.toLive
          ? decl.stroke.toLive(ctx, this)
          : decl.stroke;
      }
    },

    _setFillStyles: function(ctx, decl) {
      if (decl.fill) {
        ctx.fillStyle = decl.fill.toLive
          ? decl.fill.toLive(ctx, this)
          : decl.fill;
      }
    },

    /**
     * @private
     * Sets line dash
     * @param {CanvasRenderingContext2D} ctx Context to set the dash line on
     * @param {Array} dashArray array representing dashes
     * @param {Function} alternative function to call if browaser does not support lineDash
     */
    _setLineDash: function(ctx, dashArray, alternative) {
      if (!dashArray) {
        return;
      }
      // Spec requires the concatenation of two copies the dash list when the number of elements is odd
      if (1 & dashArray.length) {
        dashArray.push.apply(dashArray, dashArray);
      }
      if (supportsLineDash) {
        ctx.setLineDash(dashArray);
      }
      else {
        alternative && alternative(ctx);
      }
    },

    /**
     * Renders controls and borders for the object
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} [styleOverride] properties to override the object style
     */
    _renderControls: function(ctx, styleOverride) {
      var vpt = this.getViewportTransform(),
          matrix = this.calcTransformMatrix(),
          options, drawBorders, drawControls;
      styleOverride = styleOverride || { };
      drawBorders = typeof styleOverride.hasBorders !== 'undefined' ? styleOverride.hasBorders : this.hasBorders;
      drawControls = typeof styleOverride.hasControls !== 'undefined' ? styleOverride.hasControls : this.hasControls;
      matrix = fabric.util.multiplyTransformMatrices(vpt, matrix);
      options = fabric.util.qrDecompose(matrix);
      ctx.save();
      ctx.translate(options.translateX, options.translateY);
      ctx.lineWidth = 1 * this.borderScaleFactor;
      if (!this.group) {
        ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
      }
      if (styleOverride.forActiveSelection) {
        ctx.rotate(degreesToRadians(options.angle));
        drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);
      }
      else {
        ctx.rotate(degreesToRadians(this.angle));
        drawBorders && this.drawBorders(ctx, styleOverride);
      }
      drawControls && this.drawControls(ctx, styleOverride);
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _setShadow: function(ctx) {
      if (!this.shadow) {
        return;
      }

      var multX = (this.canvas && this.canvas.viewportTransform[0]) || 1,
          multY = (this.canvas && this.canvas.viewportTransform[3]) || 1,
          scaling = this.getObjectScaling();
      if (this.canvas && this.canvas._isRetinaScaling()) {
        multX *= fabric.devicePixelRatio;
        multY *= fabric.devicePixelRatio;
      }
      ctx.shadowColor = this.shadow.color;
      ctx.shadowBlur = this.shadow.blur * (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;
      ctx.shadowOffsetX = this.shadow.offsetX * multX * scaling.scaleX;
      ctx.shadowOffsetY = this.shadow.offsetY * multY * scaling.scaleY;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _removeShadow: function(ctx) {
      if (!this.shadow) {
        return;
      }

      ctx.shadowColor = '';
      ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} filler fabric.Pattern or fabric.Gradient
     */
    _applyPatternGradientTransform: function(ctx, filler) {
      if (!filler || !filler.toLive) {
        return { offsetX: 0, offsetY: 0 };
      }
      var transform = filler.gradientTransform || filler.patternTransform;
      var offsetX = -this.width / 2 + filler.offsetX || 0,
          offsetY = -this.height / 2 + filler.offsetY || 0;
      ctx.translate(offsetX, offsetY);
      if (transform) {
        ctx.transform.apply(ctx, transform);
      }
      return { offsetX: offsetX, offsetY: offsetY };
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderFill: function(ctx) {
      if (!this.fill) {
        return;
      }

      ctx.save();
      this._applyPatternGradientTransform(ctx, this.fill);
      if (this.fillRule === 'evenodd') {
        ctx.fill('evenodd');
      }
      else {
        ctx.fill();
      }
      ctx.restore();
    },

    _renderStroke: function(ctx) {
      if (!this.stroke || this.strokeWidth === 0) {
        return;
      }

      if (this.shadow && !this.shadow.affectStroke) {
        this._removeShadow(ctx);
      }

      ctx.save();
      this._setLineDash(ctx, this.strokeDashArray, this._renderDashedStroke);
      this._applyPatternGradientTransform(ctx, this.stroke);
      ctx.stroke();
      ctx.restore();
    },

    /**
     * This function is an helper for svg import. it returns the center of the object in the svg
     * untransformed coordinates
     * @private
     * @return {Object} center point from element coordinates
     */
    _findCenterFromElement: function() {
      return { x: this.left + this.width / 2, y: this.top + this.height / 2 };
    },

    /**
     * This function is an helper for svg import. it decoompose the transformMatrix
     * and assign properties to object.
     * untransformed coordinates
     * @private
     * @chainable
     */
    _assignTransformMatrixProps: function() {
      if (this.transformMatrix) {
        var options = fabric.util.qrDecompose(this.transformMatrix);
        this.flipX = false;
        this.flipY = false;
        this.set('scaleX', options.scaleX);
        this.set('scaleY', options.scaleY);
        this.angle = options.angle;
        this.skewX = options.skewX;
        this.skewY = 0;
      }
    },

    /**
     * This function is an helper for svg import. it removes the transform matrix
     * and set to object properties that fabricjs can handle
     * @private
     * @chainable
     * @return {thisArg}
     */
    _removeTransformMatrix: function() {
      var center = this._findCenterFromElement();
      if (this.transformMatrix) {
        this._assignTransformMatrixProps();
        center = fabric.util.transformPoint(center, this.transformMatrix);
      }
      this.transformMatrix = null;
      this.setPositionByOrigin(center, 'center', 'center');
    },

    /**
     * Clones an instance, using a callback method will work for every object.
     * @param {Function} callback Callback is invoked with a clone as a first argument
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     */
    clone: function(callback, propertiesToInclude) {
      var objectForm = this.toObject(propertiesToInclude);
      if (this.constructor.fromObject) {
        this.constructor.fromObject(objectForm, callback);
      }
      else {
        fabric.Object._fromObject('Object', objectForm, callback);
      }
    },

    /**
     * Creates an instance of fabric.Image out of an object
     * @param {Function} callback callback, invoked with an instance as a first argument
     * @param {Object} [options] for clone as image, passed to toDataURL
     * @param {Boolean} [options.enableRetinaScaling] enable retina scaling for the cloned image
     * @return {fabric.Object} thisArg
     */
    cloneAsImage: function(callback, options) {
      var dataUrl = this.toDataURL(options);
      fabric.util.loadImage(dataUrl, function(img) {
        if (callback) {
          callback(new fabric.Image(img));
        }
      });
      return this;
    },

    /**
     * Converts an object into a data-url-like string
     * @param {Object} options Options object
     * @param {String} [options.format=png] The format of the output image. Either "jpeg" or "png"
     * @param {Number} [options.quality=1] Quality level (0..1). Only used for jpeg.
     * @param {Number} [options.multiplier=1] Multiplier to scale by
     * @param {Number} [options.left] Cropping left offset. Introduced in v1.2.14
     * @param {Number} [options.top] Cropping top offset. Introduced in v1.2.14
     * @param {Number} [options.width] Cropping width. Introduced in v1.2.14
     * @param {Number} [options.height] Cropping height. Introduced in v1.2.14
     * @param {Boolean} [options.enableRetina] Enable retina scaling for clone image. Introduce in 1.6.4
     * @return {String} Returns a data: URL containing a representation of the object in the format specified by options.format
     */
    toDataURL: function(options) {
      options || (options = { });

      var el = fabric.util.createCanvasElement(),
          boundingRect = this.getBoundingRect();

      el.width = boundingRect.width;
      el.height = boundingRect.height;
      fabric.util.wrapElement(el, 'div');
      var canvas = new fabric.StaticCanvas(el, { enableRetinaScaling: options.enableRetinaScaling });
      // to avoid common confusion https://github.com/kangax/fabric.js/issues/806
      if (options.format === 'jpg') {
        options.format = 'jpeg';
      }

      if (options.format === 'jpeg') {
        canvas.backgroundColor = '#fff';
      }

      var origParams = {
        active: this.active,
        left: this.left,
        top: this.top
      };

      this.set('active', false);
      this.setPositionByOrigin(new fabric.Point(canvas.width / 2, canvas.height / 2), 'center', 'center');

      var originalCanvas = this.canvas;
      canvas.add(this);
      var data = canvas.toDataURL(options);

      this.set(origParams).setCoords();
      this.canvas = originalCanvas;

      canvas.dispose();
      canvas = null;

      return data;
    },

    /**
     * Returns true if specified type is identical to the type of an instance
     * @param {String} type Type to check against
     * @return {Boolean}
     */
    isType: function(type) {
      return this.type === type;
    },

    /**
     * Returns complexity of an instance
     * @return {Number} complexity of this instance (is 1 unless subclassed)
     */
    complexity: function() {
      return 1;
    },

    /**
     * Returns a JSON representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} JSON
     */
    toJSON: function(propertiesToInclude) {
      // delegate, not alias
      return this.toObject(propertiesToInclude);
    },

    /**
     * Sets gradient (fill or stroke) of an object
     * <b>Backwards incompatibility note:</b> This method was named "setGradientFill" until v1.1.0
     * @param {String} property Property name 'stroke' or 'fill'
     * @param {Object} [options] Options object
     * @param {String} [options.type] Type of gradient 'radial' or 'linear'
     * @param {Number} [options.x1=0] x-coordinate of start point
     * @param {Number} [options.y1=0] y-coordinate of start point
     * @param {Number} [options.x2=0] x-coordinate of end point
     * @param {Number} [options.y2=0] y-coordinate of end point
     * @param {Number} [options.r1=0] Radius of start point (only for radial gradients)
     * @param {Number} [options.r2=0] Radius of end point (only for radial gradients)
     * @param {Object} [options.colorStops] Color stops object eg. {0: 'ff0000', 1: '000000'}
     * @param {Object} [options.gradientTransform] transforMatrix for gradient
     * @return {fabric.Object} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/58y8b/|jsFiddle demo}
     * @example <caption>Set linear gradient</caption>
     * object.setGradient('fill', {
     *   type: 'linear',
     *   x1: -object.width / 2,
     *   y1: 0,
     *   x2: object.width / 2,
     *   y2: 0,
     *   colorStops: {
     *     0: 'red',
     *     0.5: '#005555',
     *     1: 'rgba(0,0,255,0.5)'
     *   }
     * });
     * canvas.renderAll();
     * @example <caption>Set radial gradient</caption>
     * object.setGradient('fill', {
     *   type: 'radial',
     *   x1: 0,
     *   y1: 0,
     *   x2: 0,
     *   y2: 0,
     *   r1: object.width / 2,
     *   r2: 10,
     *   colorStops: {
     *     0: 'red',
     *     0.5: '#005555',
     *     1: 'rgba(0,0,255,0.5)'
     *   }
     * });
     * canvas.renderAll();
     */
    setGradient: function(property, options) {
      options || (options = { });

      var gradient = { colorStops: [] };

      gradient.type = options.type || (options.r1 || options.r2 ? 'radial' : 'linear');
      gradient.coords = {
        x1: options.x1,
        y1: options.y1,
        x2: options.x2,
        y2: options.y2
      };

      if (options.r1 || options.r2) {
        gradient.coords.r1 = options.r1;
        gradient.coords.r2 = options.r2;
      }

      gradient.gradientTransform = options.gradientTransform;
      fabric.Gradient.prototype.addColorStop.call(gradient, options.colorStops);

      return this.set(property, fabric.Gradient.forObject(this, gradient));
    },

    /**
     * Sets pattern fill of an object
     * @param {Object} options Options object
     * @param {(String|HTMLImageElement)} options.source Pattern source
     * @param {String} [options.repeat=repeat] Repeat property of a pattern (one of repeat, repeat-x, repeat-y or no-repeat)
     * @param {Number} [options.offsetX=0] Pattern horizontal offset from object's left/top corner
     * @param {Number} [options.offsetY=0] Pattern vertical offset from object's left/top corner
     * @return {fabric.Object} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/QT3pa/|jsFiddle demo}
     * @example <caption>Set pattern</caption>
     * fabric.util.loadImage('http://fabricjs.com/assets/escheresque_ste.png', function(img) {
     *   object.setPatternFill({
     *     source: img,
     *     repeat: 'repeat'
     *   });
     *   canvas.renderAll();
     * });
     */
    setPatternFill: function(options) {
      return this.set('fill', new fabric.Pattern(options));
    },

    /**
     * Sets {@link fabric.Object#shadow|shadow} of an object
     * @param {Object|String} [options] Options object or string (e.g. "2px 2px 10px rgba(0,0,0,0.2)")
     * @param {String} [options.color=rgb(0,0,0)] Shadow color
     * @param {Number} [options.blur=0] Shadow blur
     * @param {Number} [options.offsetX=0] Shadow horizontal offset
     * @param {Number} [options.offsetY=0] Shadow vertical offset
     * @return {fabric.Object} thisArg
     * @chainable
     * @see {@link http://jsfiddle.net/fabricjs/7gvJG/|jsFiddle demo}
     * @example <caption>Set shadow with string notation</caption>
     * object.setShadow('2px 2px 10px rgba(0,0,0,0.2)');
     * canvas.renderAll();
     * @example <caption>Set shadow with object notation</caption>
     * object.setShadow({
     *   color: 'red',
     *   blur: 10,
     *   offsetX: 20,
     *   offsetY: 20
     * });
     * canvas.renderAll();
     */
    setShadow: function(options) {
      return this.set('shadow', options ? new fabric.Shadow(options) : null);
    },

    /**
     * Sets "color" of an instance (alias of `set('fill', &hellip;)`)
     * @param {String} color Color value
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setColor: function(color) {
      this.set('fill', color);
      return this;
    },

    /**
     * Sets "angle" of an instance with centered rotation
     * @param {Number} angle Angle value (in degrees)
     * @return {fabric.Object} thisArg
     * @chainable
     */
    rotate: function(angle) {
      var shouldCenterOrigin = (this.originX !== 'center' || this.originY !== 'center') && this.centeredRotation;

      if (shouldCenterOrigin) {
        this._setOriginToCenter();
      }

      this.set('angle', angle);

      if (shouldCenterOrigin) {
        this._resetOrigin();
      }

      return this;
    },

    /**
     * Centers object horizontally on canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    centerH: function () {
      this.canvas && this.canvas.centerObjectH(this);
      return this;
    },

    /**
     * Centers object horizontally on current viewport of canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    viewportCenterH: function () {
      this.canvas && this.canvas.viewportCenterObjectH(this);
      return this;
    },

    /**
     * Centers object vertically on canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    centerV: function () {
      this.canvas && this.canvas.centerObjectV(this);
      return this;
    },

    /**
     * Centers object vertically on current viewport of canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    viewportCenterV: function () {
      this.canvas && this.canvas.viewportCenterObjectV(this);
      return this;
    },

    /**
     * Centers object vertically and horizontally on canvas to which is was added last
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    center: function () {
      this.canvas && this.canvas.centerObject(this);
      return this;
    },

    /**
     * Centers object on current viewport of canvas to which it was added last.
     * You might need to call `setCoords` on an object after centering, to update controls area.
     * @return {fabric.Object} thisArg
     * @chainable
     */
    viewportCenter: function () {
      this.canvas && this.canvas.viewportCenterObject(this);
      return this;
    },

    /**
     * Returns coordinates of a pointer relative to an object
     * @param {Event} e Event to operate upon
     * @param {Object} [pointer] Pointer to operate upon (instead of event)
     * @return {Object} Coordinates of a pointer (x, y)
     */
    getLocalPointer: function(e, pointer) {
      pointer = pointer || this.canvas.getPointer(e);
      var pClicked = new fabric.Point(pointer.x, pointer.y),
          objectLeftTop = this._getLeftTopCoords();
      if (this.angle) {
        pClicked = fabric.util.rotatePoint(
          pClicked, objectLeftTop, degreesToRadians(-this.angle));
      }
      return {
        x: pClicked.x - objectLeftTop.x,
        y: pClicked.y - objectLeftTop.y
      };
    },

    /**
     * Sets canvas globalCompositeOperation for specific object
     * custom composition operation for the particular object can be specifed using globalCompositeOperation property
     * @param {CanvasRenderingContext2D} ctx Rendering canvas context
     */
    _setupCompositeOperation: function (ctx) {
      if (this.globalCompositeOperation) {
        ctx.globalCompositeOperation = this.globalCompositeOperation;
      }
    }
  });

  fabric.util.createAccessors && fabric.util.createAccessors(fabric.Object);

  extend(fabric.Object.prototype, fabric.Observable);

  /**
   * Defines the number of fraction digits to use when serializing object values.
   * You can use it to increase/decrease precision of such values like left, top, scaleX, scaleY, etc.
   * @static
   * @memberOf fabric.Object
   * @constant
   * @type Number
   */
  fabric.Object.NUM_FRACTION_DIGITS = 2;

  fabric.Object._fromObject = function(className, object, callback, extraParam) {
    var klass = fabric[className];
    object = clone(object, true);
    fabric.util.enlivenPatterns([object.fill, object.stroke], function(patterns) {
      if (typeof patterns[0] !== 'undefined') {
        object.fill = patterns[0];
      }
      if (typeof patterns[1] !== 'undefined') {
        object.stroke = patterns[1];
      }
      var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);
      callback && callback(instance);
    });
  };

  /**
   * Unique id used internally when creating SVG elements
   * @static
   * @memberOf fabric.Object
   * @type Number
   */
  fabric.Object.__uid = 0;

})( true ? exports : this);


(function() {

  var degreesToRadians = fabric.util.degreesToRadians,
      originXOffset = {
        left: -0.5,
        center: 0,
        right: 0.5
      },
      originYOffset = {
        top: -0.5,
        center: 0,
        bottom: 0.5
      };

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Translates the coordinates from a set of origin to another (based on the object's dimensions)
     * @param {fabric.Point} point The point which corresponds to the originX and originY params
     * @param {String} fromOriginX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} fromOriginY Vertical origin: 'top', 'center' or 'bottom'
     * @param {String} toOriginX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} toOriginY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {
      var x = point.x,
          y = point.y,
          offsetX, offsetY, dim;

      if (typeof fromOriginX === 'string') {
        fromOriginX = originXOffset[fromOriginX];
      }
      else {
        fromOriginX -= 0.5;
      }

      if (typeof toOriginX === 'string') {
        toOriginX = originXOffset[toOriginX];
      }
      else {
        toOriginX -= 0.5;
      }

      offsetX = toOriginX - fromOriginX;

      if (typeof fromOriginY === 'string') {
        fromOriginY = originYOffset[fromOriginY];
      }
      else {
        fromOriginY -= 0.5;
      }

      if (typeof toOriginY === 'string') {
        toOriginY = originYOffset[toOriginY];
      }
      else {
        toOriginY -= 0.5;
      }

      offsetY = toOriginY - fromOriginY;

      if (offsetX || offsetY) {
        dim = this._getTransformedDimensions();
        x = point.x + offsetX * dim.x;
        y = point.y + offsetY * dim.y;
      }

      return new fabric.Point(x, y);
    },

    /**
     * Translates the coordinates from origin to center coordinates (based on the object's dimensions)
     * @param {fabric.Point} point The point which corresponds to the originX and originY params
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    translateToCenterPoint: function(point, originX, originY) {
      var p = this.translateToGivenOrigin(point, originX, originY, 'center', 'center');
      if (this.angle) {
        return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));
      }
      return p;
    },

    /**
     * Translates the coordinates from center to origin coordinates (based on the object's dimensions)
     * @param {fabric.Point} center The point which corresponds to center of the object
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    translateToOriginPoint: function(center, originX, originY) {
      var p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
      if (this.angle) {
        return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));
      }
      return p;
    },

    /**
     * Returns the real center coordinates of the object
     * @return {fabric.Point}
     */
    getCenterPoint: function() {
      var leftTop = new fabric.Point(this.left, this.top);
      return this.translateToCenterPoint(leftTop, this.originX, this.originY);
    },

    /**
     * Returns the coordinates of the object based on center coordinates
     * @param {fabric.Point} point The point which corresponds to the originX and originY params
     * @return {fabric.Point}
     */
    // getOriginPoint: function(center) {
    //   return this.translateToOriginPoint(center, this.originX, this.originY);
    // },

    /**
     * Returns the coordinates of the object as if it has a different origin
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    getPointByOrigin: function(originX, originY) {
      var center = this.getCenterPoint();
      return this.translateToOriginPoint(center, originX, originY);
    },

    /**
     * Returns the point in local coordinates
     * @param {fabric.Point} point The point relative to the global coordinate system
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {fabric.Point}
     */
    toLocalPoint: function(point, originX, originY) {
      var center = this.getCenterPoint(),
          p, p2;

      if (typeof originX !== 'undefined' && typeof originY !== 'undefined' ) {
        p = this.translateToGivenOrigin(center, 'center', 'center', originX, originY);
      }
      else {
        p = new fabric.Point(this.left, this.top);
      }

      p2 = new fabric.Point(point.x, point.y);
      if (this.angle) {
        p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));
      }
      return p2.subtractEquals(p);
    },

    /**
     * Returns the point in global coordinates
     * @param {fabric.Point} The point relative to the local coordinate system
     * @return {fabric.Point}
     */
    // toGlobalPoint: function(point) {
    //   return fabric.util.rotatePoint(point, this.getCenterPoint(), degreesToRadians(this.angle)).addEquals(new fabric.Point(this.left, this.top));
    // },

    /**
     * Sets the position of the object taking into consideration the object's origin
     * @param {fabric.Point} pos The new position of the object
     * @param {String} originX Horizontal origin: 'left', 'center' or 'right'
     * @param {String} originY Vertical origin: 'top', 'center' or 'bottom'
     * @return {void}
     */
    setPositionByOrigin: function(pos, originX, originY) {
      var center = this.translateToCenterPoint(pos, originX, originY),
          position = this.translateToOriginPoint(center, this.originX, this.originY);
      this.set('left', position.x);
      this.set('top', position.y);
    },

    /**
     * @param {String} to One of 'left', 'center', 'right'
     */
    adjustPosition: function(to) {
      var angle = degreesToRadians(this.angle),
          hypotFull = this.getScaledWidth(),
          xFull = Math.cos(angle) * hypotFull,
          yFull = Math.sin(angle) * hypotFull,
          offsetFrom, offsetTo;

      //TODO: this function does not consider mixed situation like top, center.
      if (typeof this.originX === 'string') {
        offsetFrom = originXOffset[this.originX];
      }
      else {
        offsetFrom = this.originX - 0.5;
      }
      if (typeof to === 'string') {
        offsetTo = originXOffset[to];
      }
      else {
        offsetTo = to - 0.5;
      }
      this.left += xFull * (offsetTo - offsetFrom);
      this.top += yFull * (offsetTo - offsetFrom);
      this.setCoords();
      this.originX = to;
    },

    /**
     * Sets the origin/position of the object to it's center point
     * @private
     * @return {void}
     */
    _setOriginToCenter: function() {
      this._originalOriginX = this.originX;
      this._originalOriginY = this.originY;

      var center = this.getCenterPoint();

      this.originX = 'center';
      this.originY = 'center';

      this.left = center.x;
      this.top = center.y;
    },

    /**
     * Resets the origin/position of the object to it's original origin
     * @private
     * @return {void}
     */
    _resetOrigin: function() {
      var originPoint = this.translateToOriginPoint(
        this.getCenterPoint(),
        this._originalOriginX,
        this._originalOriginY);

      this.originX = this._originalOriginX;
      this.originY = this._originalOriginY;

      this.left = originPoint.x;
      this.top = originPoint.y;

      this._originalOriginX = null;
      this._originalOriginY = null;
    },

    /**
     * @private
     */
    _getLeftTopCoords: function() {
      return this.translateToOriginPoint(this.getCenterPoint(), 'left', 'top');
    },

    /**
    * Callback; invoked right before object is about to go from active to inactive
    */
    onDeselect: function() {
      /* NOOP */
    }
  });

})();


(function() {

  function getCoords(coords) {
    return [
      new fabric.Point(coords.tl.x, coords.tl.y),
      new fabric.Point(coords.tr.x, coords.tr.y),
      new fabric.Point(coords.br.x, coords.br.y),
      new fabric.Point(coords.bl.x, coords.bl.y)
    ];
  }

  var degreesToRadians = fabric.util.degreesToRadians,
      multiplyMatrices = fabric.util.multiplyTransformMatrices;

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Describe object's corner position in canvas element coordinates.
     * properties are tl,mt,tr,ml,mr,bl,mb,br,mtr for the main controls.
     * each property is an object with x, y and corner.
     * The `corner` property contains in a similar manner the 4 points of the
     * interactive area of the corner.
     * The coordinates depends from this properties: width, height, scaleX, scaleY
     * skewX, skewY, angle, strokeWidth, viewportTransform, top, left, padding.
     * The coordinates get updated with @method setCoords.
     * You can calculate them without updating with @method calcCoords;
     * @memberOf fabric.Object.prototype
     */
    oCoords: null,

    /**
     * Describe object's corner position in canvas object absolute coordinates
     * properties are tl,tr,bl,br and describe the four main corner.
     * each property is an object with x, y, instance of Fabric.Point.
     * The coordinates depends from this properties: width, height, scaleX, scaleY
     * skewX, skewY, angle, strokeWidth, top, left.
     * Those coordinates are usefull to understand where an object is. They get updated
     * with oCoords but they do not need to be updated when zoom or panning change.
     * The coordinates get updated with @method setCoords.
     * You can calculate them without updating with @method calcCoords(true);
     * @memberOf fabric.Object.prototype
     */
    aCoords: null,

    /**
     * return correct set of coordinates for intersection
     */
    getCoords: function(absolute, calculate) {
      if (!this.oCoords) {
        this.setCoords();
      }
      var coords = absolute ? this.aCoords : this.oCoords;
      return getCoords(calculate ? this.calcCoords(absolute) : coords);
    },

    /**
     * Checks if object intersects with an area formed by 2 points
     * @param {Object} pointTL top-left point of area
     * @param {Object} pointBR bottom-right point of area
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object intersects with an area formed by 2 points
     */
    intersectsWithRect: function(pointTL, pointBR, absolute, calculate) {
      var coords = this.getCoords(absolute, calculate),
          intersection = fabric.Intersection.intersectPolygonRectangle(
            coords,
            pointTL,
            pointBR
          );
      return intersection.status === 'Intersection';
    },

    /**
     * Checks if object intersects with another object
     * @param {Object} other Object to test
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object intersects with another object
     */
    intersectsWithObject: function(other, absolute, calculate) {
      var intersection = fabric.Intersection.intersectPolygonPolygon(
            this.getCoords(absolute, calculate),
            other.getCoords(absolute, calculate)
          );

      return intersection.status === 'Intersection'
        || other.isContainedWithinObject(this, absolute, calculate)
        || this.isContainedWithinObject(other, absolute, calculate);
    },

    /**
     * Checks if object is fully contained within area of another object
     * @param {Object} other Object to test
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object is fully contained within area of another object
     */
    isContainedWithinObject: function(other, absolute, calculate) {
      var points = this.getCoords(absolute, calculate),
          i = 0, lines = other._getImageLines(
            calculate ? other.calcCoords(absolute) : absolute ? other.aCoords : other.oCoords
          );
      for (; i < 4; i++) {
        if (!other.containsPoint(points[i], lines)) {
          return false;
        }
      }
      return true;
    },

    /**
     * Checks if object is fully contained within area formed by 2 points
     * @param {Object} pointTL top-left point of area
     * @param {Object} pointBR bottom-right point of area
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object is fully contained within area formed by 2 points
     */
    isContainedWithinRect: function(pointTL, pointBR, absolute, calculate) {
      var boundingRect = this.getBoundingRect(absolute, calculate);

      return (
        boundingRect.left >= pointTL.x &&
        boundingRect.left + boundingRect.width <= pointBR.x &&
        boundingRect.top >= pointTL.y &&
        boundingRect.top + boundingRect.height <= pointBR.y
      );
    },

    /**
     * Checks if point is inside the object
     * @param {fabric.Point} point Point to check against
     * @param {Object} [lines] object returned from @method _getImageLines
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if point is inside the object
     */
    containsPoint: function(point, lines, absolute, calculate) {
      var lines = lines || this._getImageLines(
        calculate ? this.calcCoords(absolute) : absolute ? this.aCoords : this.oCoords
      ),
          xPoints = this._findCrossPoints(point, lines);

      // if xPoints is odd then point is inside the object
      return (xPoints !== 0 && xPoints % 2 === 1);
    },

    /**
     * Checks if object is contained within the canvas with current viewportTransform
     * the check is done stopping at first point that appear on screen
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Boolean} true if object is fully contained within canvas
     */
    isOnScreen: function(calculate) {
      if (!this.canvas) {
        return false;
      }
      var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
      var points = this.getCoords(true, calculate), point;
      for (var i = 0; i < 4; i++) {
        point = points[i];
        if (point.x <= pointBR.x && point.x >= pointTL.x && point.y <= pointBR.y && point.y >= pointTL.y) {
          return true;
        }
      }
      // no points on screen, check intersection with absolute coordinates
      if (this.intersectsWithRect(pointTL, pointBR, true)) {
        return true;
      }
      // worst case scenario the object is so big that contains the screen
      var centerPoint = { x: (pointTL.x + pointBR.x) / 2, y: (pointTL.y + pointBR.y) / 2 };
      if (this.containsPoint(centerPoint, null, true)) {
        return true;
      }
      return false;
    },

    /**
     * Method that returns an object with the object edges in it, given the coordinates of the corners
     * @private
     * @param {Object} oCoords Coordinates of the object corners
     */
    _getImageLines: function(oCoords) {
      return {
        topline: {
          o: oCoords.tl,
          d: oCoords.tr
        },
        rightline: {
          o: oCoords.tr,
          d: oCoords.br
        },
        bottomline: {
          o: oCoords.br,
          d: oCoords.bl
        },
        leftline: {
          o: oCoords.bl,
          d: oCoords.tl
        }
      };
    },

    /**
     * Helper method to determine how many cross points are between the 4 object edges
     * and the horizontal line determined by a point on canvas
     * @private
     * @param {fabric.Point} point Point to check
     * @param {Object} lines Coordinates of the object being evaluated
     */
     // remove yi, not used but left code here just in case.
    _findCrossPoints: function(point, lines) {
      var b1, b2, a1, a2, xi, // yi,
          xcount = 0,
          iLine;

      for (var lineKey in lines) {
        iLine = lines[lineKey];
        // optimisation 1: line below point. no cross
        if ((iLine.o.y < point.y) && (iLine.d.y < point.y)) {
          continue;
        }
        // optimisation 2: line above point. no cross
        if ((iLine.o.y >= point.y) && (iLine.d.y >= point.y)) {
          continue;
        }
        // optimisation 3: vertical line case
        if ((iLine.o.x === iLine.d.x) && (iLine.o.x >= point.x)) {
          xi = iLine.o.x;
          // yi = point.y;
        }
        // calculate the intersection point
        else {
          b1 = 0;
          b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);
          a1 = point.y - b1 * point.x;
          a2 = iLine.o.y - b2 * iLine.o.x;

          xi = -(a1 - a2) / (b1 - b2);
          // yi = a1 + b1 * xi;
        }
        // dont count xi < point.x cases
        if (xi >= point.x) {
          xcount += 1;
        }
        // optimisation 4: specific for square images
        if (xcount === 2) {
          break;
        }
      }
      return xcount;
    },

    /**
     * Returns width of an object's bounding rectangle
     * @deprecated since 1.0.4
     * @return {Number} width value
     */
    getBoundingRectWidth: function() {
      return this.getBoundingRect().width;
    },

    /**
     * Returns height of an object's bounding rectangle
     * @deprecated since 1.0.4
     * @return {Number} height value
     */
    getBoundingRectHeight: function() {
      return this.getBoundingRect().height;
    },

    /**
     * Returns coordinates of object's bounding rectangle (left, top, width, height)
     * the box is intented as aligned to axis of canvas.
     * @param {Boolean} [absolute] use coordinates without viewportTransform
     * @param {Boolean} [calculate] use coordinates of current position instead of .oCoords
     * @return {Object} Object with left, top, width, height properties
     */
    getBoundingRect: function(absolute, calculate) {
      var coords = this.getCoords(absolute, calculate);
      return fabric.util.makeBoundingBoxFromPoints(coords);
    },

    /**
     * Returns width of an object bounding box counting transformations
     * @return {Number} width value
     */
    getScaledWidth: function() {
      return this._getTransformedDimensions().x;
    },

    /**
     * Returns height of an object bounding box counting transformations
     * @return {Number} height value
     */
    getScaledHeight: function() {
      return this._getTransformedDimensions().y;
    },

    /**
     * Makes sure the scale is valid and modifies it if necessary
     * @private
     * @param {Number} value
     * @return {Number}
     */
    _constrainScale: function(value) {
      if (Math.abs(value) < this.minScaleLimit) {
        if (value < 0) {
          return -this.minScaleLimit;
        }
        else {
          return this.minScaleLimit;
        }
      }
      return value;
    },

    /**
     * Scales an object (equally by x and y)
     * @param {Number} value Scale factor
     * @return {fabric.Object} thisArg
     * @chainable
     */
    scale: function(value) {
      value = this._constrainScale(value);

      if (value < 0) {
        this.flipX = !this.flipX;
        this.flipY = !this.flipY;
        value *= -1;
      }

      this.scaleX = value;
      this.scaleY = value;
      return this.setCoords();
    },

    /**
     * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)
     * @param {Number} value New width value
     * @return {fabric.Object} thisArg
     * @chainable
     */
    scaleToWidth: function(value) {
      // adjust to bounding rect factor so that rotated shapes would fit as well
      var boundingRectFactor = this.getBoundingRect().width / this.getScaledWidth();
      return this.scale(value / this.width / boundingRectFactor);
    },

    /**
     * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)
     * @param {Number} value New height value
     * @return {fabric.Object} thisArg
     * @chainable
     */
    scaleToHeight: function(value) {
      // adjust to bounding rect factor so that rotated shapes would fit as well
      var boundingRectFactor = this.getBoundingRect().height / this.getScaledHeight();
      return this.scale(value / this.height / boundingRectFactor);
    },

    /**
     * Calculate and returns the .coords of an object.
     * @return {Object} Object with tl, tr, br, bl ....
     * @chainable
     */
    calcCoords: function(absolute) {
      var theta = degreesToRadians(this.angle),
          vpt = this.getViewportTransform(),
          dim = absolute ? this._getTransformedDimensions() : this._calculateCurrentDimensions(),
          currentWidth = dim.x, currentHeight = dim.y,
          sinTh = Math.sin(theta),
          cosTh = Math.cos(theta),
          _angle = currentWidth > 0 ? Math.atan(currentHeight / currentWidth) : 0,
          _hypotenuse = (currentWidth / Math.cos(_angle)) / 2,
          offsetX = Math.cos(_angle + theta) * _hypotenuse,
          offsetY = Math.sin(_angle + theta) * _hypotenuse,
          center = this.getCenterPoint(),
          // offset added for rotate and scale actions
          coords = absolute ? center : fabric.util.transformPoint(center, vpt),
          tl  = new fabric.Point(coords.x - offsetX, coords.y - offsetY),
          tr  = new fabric.Point(tl.x + (currentWidth * cosTh), tl.y + (currentWidth * sinTh)),
          bl  = new fabric.Point(tl.x - (currentHeight * sinTh), tl.y + (currentHeight * cosTh)),
          br  = new fabric.Point(coords.x + offsetX, coords.y + offsetY);
      if (!absolute) {
        var ml  = new fabric.Point((tl.x + bl.x) / 2, (tl.y + bl.y) / 2),
            mt  = new fabric.Point((tr.x + tl.x) / 2, (tr.y + tl.y) / 2),
            mr  = new fabric.Point((br.x + tr.x) / 2, (br.y + tr.y) / 2),
            mb  = new fabric.Point((br.x + bl.x) / 2, (br.y + bl.y) / 2),
            mtr = new fabric.Point(mt.x + sinTh * this.rotatingPointOffset, mt.y - cosTh * this.rotatingPointOffset);
      }

      // debugging

      /* setTimeout(function() {
         canvas.contextTop.fillStyle = 'green';
         canvas.contextTop.fillRect(mb.x, mb.y, 3, 3);
         canvas.contextTop.fillRect(bl.x, bl.y, 3, 3);
         canvas.contextTop.fillRect(br.x, br.y, 3, 3);
         canvas.contextTop.fillRect(tl.x, tl.y, 3, 3);
         canvas.contextTop.fillRect(tr.x, tr.y, 3, 3);
         canvas.contextTop.fillRect(ml.x, ml.y, 3, 3);
         canvas.contextTop.fillRect(mr.x, mr.y, 3, 3);
         canvas.contextTop.fillRect(mt.x, mt.y, 3, 3);
         canvas.contextTop.fillRect(mtr.x, mtr.y, 3, 3);
       }, 50); */

      var coords = {
        // corners
        tl: tl, tr: tr, br: br, bl: bl,
      };
      if (!absolute) {
        // middle
        coords.ml = ml;
        coords.mt = mt;
        coords.mr = mr;
        coords.mb = mb;
        // rotating point
        coords.mtr = mtr;
      }
      return coords;
    },

    /**
     * Sets corner position coordinates based on current angle, width and height
     * See https://github.com/kangax/fabric.js/wiki/When-to-call-setCoords
     * @param {Boolean} [ignoreZoom] set oCoords with or without the viewport transform.
     * @param {Boolean} [skipAbsolute] skip calculation of aCoords, usefull in setViewportTransform
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setCoords: function(ignoreZoom, skipAbsolute) {
      this.oCoords = this.calcCoords(ignoreZoom);
      if (!skipAbsolute) {
        this.aCoords = this.calcCoords(true);
      }

      // set coordinates of the draggable boxes in the corners used to scale/rotate the image
      ignoreZoom || (this._setCornerCoords && this._setCornerCoords());

      return this;
    },

    /**
     * calculate rotation matrix of an object
     * @return {Array} rotation matrix for the object
     */
    _calcRotateMatrix: function() {
      if (this.angle) {
        var theta = degreesToRadians(this.angle), cos = Math.cos(theta), sin = Math.sin(theta);
        // trying to keep rounding error small, ugly but it works.
        if (cos === 6.123233995736766e-17 || cos === -1.8369701987210297e-16) {
          cos = 0;
        }
        return [cos, sin, -sin, cos, 0, 0];
      }
      return fabric.iMatrix.concat();
    },

    /**
     * calculate trasform Matrix that represent current transformation from
     * object properties.
     * @param {Boolean} [skipGroup] return transformMatrix for object and not go upward with parents
     * @return {Array} matrix Transform Matrix for the object
     */
    calcTransformMatrix: function(skipGroup) {
      var center = this.getCenterPoint(),
          translateMatrix = [1, 0, 0, 1, center.x, center.y],
          rotateMatrix,
          dimensionMatrix = this._calcDimensionsTransformMatrix(this.skewX, this.skewY, true),
          matrix;
      if (this.group && !skipGroup) {
        matrix = multiplyMatrices(this.group.calcTransformMatrix(), translateMatrix);
      }
      else {
        matrix = translateMatrix;
      }
      if (this.angle) {
        rotateMatrix = this._calcRotateMatrix();
        matrix = multiplyMatrices(matrix, rotateMatrix);
      }
      matrix = multiplyMatrices(matrix, dimensionMatrix);
      return matrix;
    },

    _calcDimensionsTransformMatrix: function(skewX, skewY, flipping) {
      var skewMatrix,
          scaleX = this.scaleX * (flipping && this.flipX ? -1 : 1),
          scaleY = this.scaleY * (flipping && this.flipY ? -1 : 1),
          scaleMatrix = [scaleX, 0, 0, scaleY, 0, 0];
      if (skewX) {
        skewMatrix = [1, 0, Math.tan(degreesToRadians(skewX)), 1];
        scaleMatrix = multiplyMatrices(scaleMatrix, skewMatrix, true);
      }
      if (skewY) {
        skewMatrix = [1, Math.tan(degreesToRadians(skewY)), 0, 1];
        scaleMatrix = multiplyMatrices(scaleMatrix, skewMatrix, true);
      }
      return scaleMatrix;
    },


    /*
     * Calculate object dimensions from its properties
     * @private
     * @return {Object} .x width dimension
     * @return {Object} .y height dimension
     */
    _getNonTransformedDimensions: function() {
      var strokeWidth = this.strokeWidth,
          w = this.width + strokeWidth,
          h = this.height + strokeWidth;
      return { x: w, y: h };
    },

    /*
     * Calculate object bounding boxdimensions from its properties scale, skew.
     * @private
     * @return {Object} .x width dimension
     * @return {Object} .y height dimension
     */
    _getTransformedDimensions: function(skewX, skewY) {
      if (typeof skewX === 'undefined') {
        skewX = this.skewX;
      }
      if (typeof skewY === 'undefined') {
        skewY = this.skewY;
      }
      var dimensions = this._getNonTransformedDimensions(),
          dimX = dimensions.x / 2, dimY = dimensions.y / 2,
          points = [
            {
              x: -dimX,
              y: -dimY
            },
            {
              x: dimX,
              y: -dimY
            },
            {
              x: -dimX,
              y: dimY
            },
            {
              x: dimX,
              y: dimY
            }],
          i, transformMatrix = this._calcDimensionsTransformMatrix(skewX, skewY, false),
          bbox;
      for (i = 0; i < points.length; i++) {
        points[i] = fabric.util.transformPoint(points[i], transformMatrix);
      }
      bbox = fabric.util.makeBoundingBoxFromPoints(points);
      return { x: bbox.width, y: bbox.height };
    },

    /*
     * Calculate object dimensions for controls. include padding and canvas zoom
     * private
     */
    _calculateCurrentDimensions: function()  {
      var vpt = this.getViewportTransform(),
          dim = this._getTransformedDimensions(),
          p = fabric.util.transformPoint(dim, vpt, true);

      return p.scalarAdd(2 * this.padding);
    },
  });
})();


fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

  /**
   * Moves an object to the bottom of the stack of drawn objects
   * @return {fabric.Object} thisArg
   * @chainable
   */
  sendToBack: function() {
    if (this.group) {
      fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);
    }
    else {
      this.canvas.sendToBack(this);
    }
    return this;
  },

  /**
   * Moves an object to the top of the stack of drawn objects
   * @return {fabric.Object} thisArg
   * @chainable
   */
  bringToFront: function() {
    if (this.group) {
      fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);
    }
    else {
      this.canvas.bringToFront(this);
    }
    return this;
  },

  /**
   * Moves an object down in stack of drawn objects
   * @param {Boolean} [intersecting] If `true`, send object behind next lower intersecting object
   * @return {fabric.Object} thisArg
   * @chainable
   */
  sendBackwards: function(intersecting) {
    if (this.group) {
      fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);
    }
    else {
      this.canvas.sendBackwards(this, intersecting);
    }
    return this;
  },

  /**
   * Moves an object up in stack of drawn objects
   * @param {Boolean} [intersecting] If `true`, send object in front of next upper intersecting object
   * @return {fabric.Object} thisArg
   * @chainable
   */
  bringForward: function(intersecting) {
    if (this.group) {
      fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);
    }
    else {
      this.canvas.bringForward(this, intersecting);
    }
    return this;
  },

  /**
   * Moves an object to specified level in stack of drawn objects
   * @param {Number} index New position of object
   * @return {fabric.Object} thisArg
   * @chainable
   */
  moveTo: function(index) {
    if (this.group) {
      fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index);
    }
    else {
      this.canvas.moveTo(this, index);
    }
    return this;
  }
});


/* _TO_SVG_START_ */
(function() {
  var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

  function getSvgColorString(prop, value) {
    if (!value) {
      return prop + ': none; ';
    }
    else if (value.toLive) {
      return prop + ': url(#SVGID_' + value.id + '); ';
    }
    else {
      var color = new fabric.Color(value),
          str = prop + ': ' + color.toRgb() + '; ',
          opacity = color.getAlpha();
      if (opacity !== 1) {
        //change the color in rgb + opacity
        str += prop + '-opacity: ' + opacity.toString() + '; ';
      }
      return str;
    }
  }

  var toFixed = fabric.util.toFixed;

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
    /**
     * Returns styles-string for svg-export
     * @param {Boolean} skipShadow a boolean to skip shadow filter output
     * @return {String}
     */
    getSvgStyles: function(skipShadow) {

      var fillRule = this.fillRule,
          strokeWidth = this.strokeWidth ? this.strokeWidth : '0',
          strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(' ') : 'none',
          strokeLineCap = this.strokeLineCap ? this.strokeLineCap : 'butt',
          strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : 'miter',
          strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : '4',
          opacity = typeof this.opacity !== 'undefined' ? this.opacity : '1',
          visibility = this.visible ? '' : ' visibility: hidden;',
          filter = skipShadow ? '' : this.getSvgFilter(),
          fill = getSvgColorString('fill', this.fill),
          stroke = getSvgColorString('stroke', this.stroke);

      return [
        stroke,
        'stroke-width: ', strokeWidth, '; ',
        'stroke-dasharray: ', strokeDashArray, '; ',
        'stroke-linecap: ', strokeLineCap, '; ',
        'stroke-linejoin: ', strokeLineJoin, '; ',
        'stroke-miterlimit: ', strokeMiterLimit, '; ',
        fill,
        'fill-rule: ', fillRule, '; ',
        'opacity: ', opacity, ';',
        filter,
        visibility
      ].join('');
    },

    /**
     * Returns styles-string for svg-export
     * @param {Boolean} skipShadow a boolean to skip shadow filter output
     * @return {String}
     */
    getSvgSpanStyles: function(style) {
      var strokeWidth = style.strokeWidth ? 'stroke-width: ' + style.strokeWidth + '; ' : '',
          fontFamily = style.fontFamily ? 'font-family: ' + style.fontFamily.replace(/"/g, '\'') + '; ' : '',
          fontSize = style.fontSize ? 'font-size: ' + style.fontSize + '; ' : '',
          fontStyle = style.fontStyle ? 'font-style: ' + style.fontStyle + '; ' : '',
          fontWeight = style.fontWeight ? 'font-weight: ' + style.fontWeight + '; ' : '',
          fill = style.fill ? getSvgColorString('fill', style.fill) : '',
          stroke = style.stroke ? getSvgColorString('stroke', style.stroke) : '',
          textDecoration = this.getSvgTextDecoration(style);

      return [
        stroke,
        strokeWidth,
        fontFamily,
        fontSize,
        fontStyle,
        fontWeight,
        textDecoration,
        fill,
      ].join('');
    },

    getSvgTextDecoration: function(style) {
      if ('overline' in style || 'underline' in style || 'linethrough' in style) {
        return 'text-decoration: ' + (style.overline ? 'overline ' : '') +
          (style.underline ? 'underline ' : '') + (style.linethrough ? 'line-through ' : '') + ';';
      }
      return '';
    },

    /**
     * Returns filter for svg shadow
     * @return {String}
     */
    getSvgFilter: function() {
      return this.shadow ? 'filter: url(#SVGID_' + this.shadow.id + ');' : '';
    },

    /**
     * Returns id attribute for svg output
     * @return {String}
     */
    getSvgId: function() {
      return this.id ? 'id="' + this.id + '" ' : '';
    },

    /**
     * Returns transform-string for svg-export
     * @return {String}
     */
    getSvgTransform: function() {
      var angle = this.angle,
          skewX = (this.skewX % 360),
          skewY = (this.skewY % 360),
          center = this.getCenterPoint(),

          NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS,

          translatePart = 'translate(' +
                            toFixed(center.x, NUM_FRACTION_DIGITS) +
                            ' ' +
                            toFixed(center.y, NUM_FRACTION_DIGITS) +
                          ')',

          anglePart = angle !== 0
            ? (' rotate(' + toFixed(angle, NUM_FRACTION_DIGITS) + ')')
            : '',

          scalePart = (this.scaleX === 1 && this.scaleY === 1)
            ? '' :
            (' scale(' +
              toFixed(this.scaleX, NUM_FRACTION_DIGITS) +
              ' ' +
              toFixed(this.scaleY, NUM_FRACTION_DIGITS) +
            ')'),

          skewXPart = skewX !== 0 ? ' skewX(' + toFixed(skewX, NUM_FRACTION_DIGITS) + ')' : '',

          skewYPart = skewY !== 0 ? ' skewY(' + toFixed(skewY, NUM_FRACTION_DIGITS) + ')' : '',

          flipXPart = this.flipX ? ' matrix(-1 0 0 1 0 0) ' : '',

          flipYPart = this.flipY ? ' matrix(1 0 0 -1 0 0)' : '';

      return [
        translatePart, anglePart, scalePart, flipXPart, flipYPart, skewXPart, skewYPart
      ].join('');
    },

    /**
     * Returns transform-string for svg-export from the transform matrix of single elements
     * @return {String}
     */
    getSvgTransformMatrix: function() {
      return this.transformMatrix ? ' matrix(' + this.transformMatrix.join(' ') + ') ' : '';
    },

    _setSVGBg: function(textBgRects) {
      if (this.backgroundColor) {
        textBgRects.push(
          '\t\t<rect ',
            this._getFillAttributes(this.backgroundColor),
            ' x="',
            toFixed(-this.width / 2, NUM_FRACTION_DIGITS),
            '" y="',
            toFixed(-this.height / 2, NUM_FRACTION_DIGITS),
            '" width="',
            toFixed(this.width, NUM_FRACTION_DIGITS),
            '" height="',
            toFixed(this.height, NUM_FRACTION_DIGITS),
          '"></rect>\n');
      }
    },

    /**
     * @private
     */
    _createBaseSVGMarkup: function() {
      var markup = [];

      if (this.fill && this.fill.toLive) {
        markup.push(this.fill.toSVG(this, false));
      }
      if (this.stroke && this.stroke.toLive) {
        markup.push(this.stroke.toSVG(this, false));
      }
      if (this.shadow) {
        markup.push(this.shadow.toSVG(this));
      }
      return markup;
    }
  });
})();
/* _TO_SVG_END_ */


(function() {

  var extend = fabric.util.object.extend,
      originalSet = 'stateProperties';

  /*
    Depends on `stateProperties`
  */
  function saveProps(origin, destination, props) {
    var tmpObj = { }, deep = true;
    props.forEach(function(prop) {
      tmpObj[prop] = origin[prop];
    });
    extend(origin[destination], tmpObj, deep);
  }

  function _isEqual(origValue, currentValue, firstPass) {
    if (origValue === currentValue) {
      // if the objects are identical, return
      return true;
    }
    else if (Array.isArray(origValue)) {
      if (origValue.length !== currentValue.length) {
        return false;
      }
      for (var i = 0, len = origValue.length; i < len; i++) {
        if (!_isEqual(origValue[i], currentValue[i])) {
          return false;
        }
      }
      return true;
    }
    else if (origValue && typeof origValue === 'object') {
      var keys = Object.keys(origValue), key;
      if (!firstPass && keys.length !== Object.keys(currentValue).length) {
        return false;
      }
      for (var i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        if (!_isEqual(origValue[key], currentValue[key])) {
          return false;
        }
      }
      return true;
    }
  }


  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * Returns true if object state (one of its state properties) was changed
     * @param {String} [propertySet] optional name for the set of property we want to save
     * @return {Boolean} true if instance' state has changed since `{@link fabric.Object#saveState}` was called
     */
    hasStateChanged: function(propertySet) {
      propertySet = propertySet || originalSet;
      var dashedPropertySet = '_' + propertySet;
      if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {
        return true;
      }
      return !_isEqual(this[dashedPropertySet], this, true);
    },

    /**
     * Saves state of an object
     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
     * @return {fabric.Object} thisArg
     */
    saveState: function(options) {
      var propertySet = options && options.propertySet || originalSet,
          destination = '_' + propertySet;
      if (!this[destination]) {
        return this.setupState(options);
      }
      saveProps(this, destination, this[propertySet]);
      if (options && options.stateProperties) {
        saveProps(this, destination, options.stateProperties);
      }
      return this;
    },

    /**
     * Setups state of an object
     * @param {Object} [options] Object with additional `stateProperties` array to include when saving state
     * @return {fabric.Object} thisArg
     */
    setupState: function(options) {
      options = options || { };
      var propertySet = options.propertySet || originalSet;
      options.propertySet = propertySet;
      this['_' + propertySet] = { };
      this.saveState(options);
      return this;
    }
  });
})();


(function() {

  var degreesToRadians = fabric.util.degreesToRadians;

  fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

    /**
     * The object interactivity controls.
     * @private
     */
    _controlsVisibility: null,

    /**
     * Determines which corner has been clicked
     * @private
     * @param {Object} pointer The pointer indicating the mouse position
     * @return {String|Boolean} corner code (tl, tr, bl, br, etc.), or false if nothing is found
     */
    _findTargetCorner: function(pointer) {
      // objects in group, anykind, are not self modificable,
      // must not return an hovered corner.
      if (!this.hasControls || !this.active || this.group) {
        return false;
      }

      var ex = pointer.x,
          ey = pointer.y,
          xPoints,
          lines;
      this.__corner = 0;
      for (var i in this.oCoords) {

        if (!this.isControlVisible(i)) {
          continue;
        }

        if (i === 'mtr' && !this.hasRotatingPoint) {
          continue;
        }

        if (this.get('lockUniScaling') &&
           (i === 'mt' || i === 'mr' || i === 'mb' || i === 'ml')) {
          continue;
        }

        lines = this._getImageLines(this.oCoords[i].corner);

        // debugging

        // canvas.contextTop.fillRect(lines.bottomline.d.x, lines.bottomline.d.y, 2, 2);
        // canvas.contextTop.fillRect(lines.bottomline.o.x, lines.bottomline.o.y, 2, 2);

        // canvas.contextTop.fillRect(lines.leftline.d.x, lines.leftline.d.y, 2, 2);
        // canvas.contextTop.fillRect(lines.leftline.o.x, lines.leftline.o.y, 2, 2);

        // canvas.contextTop.fillRect(lines.topline.d.x, lines.topline.d.y, 2, 2);
        // canvas.contextTop.fillRect(lines.topline.o.x, lines.topline.o.y, 2, 2);

        // canvas.contextTop.fillRect(lines.rightline.d.x, lines.rightline.d.y, 2, 2);
        // canvas.contextTop.fillRect(lines.rightline.o.x, lines.rightline.o.y, 2, 2);

        xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);
        if (xPoints !== 0 && xPoints % 2 === 1) {
          this.__corner = i;
          return i;
        }
      }
      return false;
    },

    /**
     * Sets the coordinates of the draggable boxes in the corners of
     * the image used to scale/rotate it.
     * @private
     */
    _setCornerCoords: function() {
      var coords = this.oCoords,
          newTheta = degreesToRadians(45 - this.angle),
          /* Math.sqrt(2 * Math.pow(this.cornerSize, 2)) / 2, */
          /* 0.707106 stands for sqrt(2)/2 */
          cornerHypotenuse = this.cornerSize * 0.707106,
          cosHalfOffset = cornerHypotenuse * Math.cos(newTheta),
          sinHalfOffset = cornerHypotenuse * Math.sin(newTheta),
          x, y;

      for (var point in coords) {
        x = coords[point].x;
        y = coords[point].y;
        coords[point].corner = {
          tl: {
            x: x - sinHalfOffset,
            y: y - cosHalfOffset
          },
          tr: {
            x: x + cosHalfOffset,
            y: y - sinHalfOffset
          },
          bl: {
            x: x - cosHalfOffset,
            y: y + sinHalfOffset
          },
          br: {
            x: x + sinHalfOffset,
            y: y + cosHalfOffset
          }
        };
      }
    },

    /**
     * Draws a colored layer behind the object, inside its selection borders.
     * Requires public options: padding, selectionBackgroundColor
     * this function is called when the context is transformed
     * has checks to be skipped when the object is on a staticCanvas
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawSelectionBackground: function(ctx) {
      if (!this.selectionBackgroundColor || !this.active ||
        (this.canvas && !this.canvas.interactive)) {
        return this;
      }
      ctx.save();
      var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(),
          vpt = this.canvas.viewportTransform;
      ctx.translate(center.x, center.y);
      ctx.scale(1 / vpt[0], 1 / vpt[3]);
      ctx.rotate(degreesToRadians(this.angle));
      ctx.fillStyle = this.selectionBackgroundColor;
      ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);
      ctx.restore();
      return this;
    },

    /**
     * Draws borders of an object's bounding box.
     * Requires public properties: width, height
     * Requires public options: padding, borderColor
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @param {Object} styleOverride object to override the object style
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawBorders: function(ctx, styleOverride) {
      styleOverride = styleOverride || {};
      var wh = this._calculateCurrentDimensions(),
          strokeWidth = 1 / this.borderScaleFactor,
          width = wh.x + strokeWidth,
          height = wh.y + strokeWidth,
          drawRotatingPoint = typeof styleOverride.hasRotatingPoint !== 'undefined' ?
            styleOverride.hasRotatingPoint : this.hasRotatingPoint,
          hasControls = typeof styleOverride.hasControls !== 'undefined' ?
              styleOverride.hasControls : this.hasControls,
          rotatingPointOffset = typeof styleOverride.rotatingPointOffset !== 'undefined' ?
            styleOverride.rotatingPointOffset : this.rotatingPointOffset;

      ctx.save();
      ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
      this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray, null);

      ctx.strokeRect(
        -width / 2,
        -height / 2,
        width,
        height
      );

      if (drawRotatingPoint && this.isControlVisible('mtr') && hasControls) {

        var rotateHeight = -height / 2;

        ctx.beginPath();
        ctx.moveTo(0, rotateHeight);
        ctx.lineTo(0, rotateHeight - rotatingPointOffset);
        ctx.closePath();
        ctx.stroke();
      }

      ctx.restore();
      return this;
    },

    /**
     * Draws borders of an object's bounding box when it is inside a group.
     * Requires public properties: width, height
     * Requires public options: padding, borderColor
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @param {object} options object representing current object parameters
     * @param {Object} styleOverride object to override the object style
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawBordersInGroup: function(ctx, options, styleOverride) {
      styleOverride = styleOverride || {};
      var p = this._getNonTransformedDimensions(),
          matrix = fabric.util.customTransformMatrix(options.scaleX, options.scaleY, options.skewX),
          wh = fabric.util.transformPoint(p, matrix),
          strokeWidth = 1 / this.borderScaleFactor,
          width = wh.x + strokeWidth,
          height = wh.y + strokeWidth;

      ctx.save();
      this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray, null);
      ctx.strokeStyle = styleOverride.borderColor || this.borderColor;

      ctx.strokeRect(
        -width / 2,
        -height / 2,
        width,
        height
      );

      ctx.restore();
      return this;
    },

    /**
     * Draws corners of an object's bounding box.
     * Requires public properties: width, height
     * Requires public options: cornerSize, padding
     * @param {CanvasRenderingContext2D} ctx Context to draw on
     * @param {Object} styleOverride object to override the object style
     * @return {fabric.Object} thisArg
     * @chainable
     */
    drawControls: function(ctx, styleOverride) {
      styleOverride = styleOverride || {};
      var wh = this._calculateCurrentDimensions(),
          width = wh.x,
          height = wh.y,
          scaleOffset = styleOverride.cornerSize || this.cornerSize,
          left = -(width + scaleOffset) / 2,
          top = -(height + scaleOffset) / 2,
          transparentCorners = typeof styleOverride.transparentCorners !== 'undefined' ?
            styleOverride.transparentCorners : this.transparentCorners,
          hasRotatingPoint = typeof styleOverride.hasRotatingPoint !== 'undefined' ?
            styleOverride.hasRotatingPoint : this.hasRotatingPoint,
          methodName = transparentCorners ? 'stroke' : 'fill';

      ctx.save();
      ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;
      if (!this.transparentCorners) {
        ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;
      }
      this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray, null);

      // top-left
      this._drawControl('tl', ctx, methodName,
        left,
        top, styleOverride);

      // top-right
      this._drawControl('tr', ctx, methodName,
        left + width,
        top, styleOverride);

      // bottom-left
      this._drawControl('bl', ctx, methodName,
        left,
        top + height, styleOverride);

      // bottom-right
      this._drawControl('br', ctx, methodName,
        left + width,
        top + height, styleOverride);

      if (!this.get('lockUniScaling')) {

        // middle-top
        this._drawControl('mt', ctx, methodName,
          left + width / 2,
          top, styleOverride);

        // middle-bottom
        this._drawControl('mb', ctx, methodName,
          left + width / 2,
          top + height, styleOverride);

        // middle-right
        this._drawControl('mr', ctx, methodName,
          left + width,
          top + height / 2, styleOverride);

        // middle-left
        this._drawControl('ml', ctx, methodName,
          left,
          top + height / 2, styleOverride);
      }

      // middle-top-rotate
      if (hasRotatingPoint) {
        this._drawControl('mtr', ctx, methodName,
          left + width / 2,
          top - this.rotatingPointOffset, styleOverride);
      }

      ctx.restore();

      return this;
    },

    /**
     * @private
     */
    _drawControl: function(control, ctx, methodName, left, top, styleOverride) {
      styleOverride = styleOverride || {};
      if (!this.isControlVisible(control)) {
        return;
      }
      var size = this.cornerSize, stroke = !this.transparentCorners && this.cornerStrokeColor;
      switch (styleOverride.cornerStyle || this.cornerStyle) {
        case 'circle':
          ctx.beginPath();
          ctx.arc(left + size / 2, top + size / 2, size / 2, 0, 2 * Math.PI, false);
          ctx[methodName]();
          if (stroke) {
            ctx.stroke();
          }
          break;
        default:
          this.transparentCorners || ctx.clearRect(left, top, size, size);
          ctx[methodName + 'Rect'](left, top, size, size);
          if (stroke) {
            ctx.strokeRect(left, top, size, size);
          }
      }
    },

    /**
     * Returns true if the specified control is visible, false otherwise.
     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
     * @returns {Boolean} true if the specified control is visible, false otherwise
     */
    isControlVisible: function(controlName) {
      return this._getControlsVisibility()[controlName];
    },

    /**
     * Sets the visibility of the specified control.
     * @param {String} controlName The name of the control. Possible values are 'tl', 'tr', 'br', 'bl', 'ml', 'mt', 'mr', 'mb', 'mtr'.
     * @param {Boolean} visible true to set the specified control visible, false otherwise
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setControlVisible: function(controlName, visible) {
      this._getControlsVisibility()[controlName] = visible;
      return this;
    },

    /**
     * Sets the visibility state of object controls.
     * @param {Object} [options] Options object
     * @param {Boolean} [options.bl] true to enable the bottom-left control, false to disable it
     * @param {Boolean} [options.br] true to enable the bottom-right control, false to disable it
     * @param {Boolean} [options.mb] true to enable the middle-bottom control, false to disable it
     * @param {Boolean} [options.ml] true to enable the middle-left control, false to disable it
     * @param {Boolean} [options.mr] true to enable the middle-right control, false to disable it
     * @param {Boolean} [options.mt] true to enable the middle-top control, false to disable it
     * @param {Boolean} [options.tl] true to enable the top-left control, false to disable it
     * @param {Boolean} [options.tr] true to enable the top-right control, false to disable it
     * @param {Boolean} [options.mtr] true to enable the middle-top-rotate control, false to disable it
     * @return {fabric.Object} thisArg
     * @chainable
     */
    setControlsVisibility: function(options) {
      options || (options = { });

      for (var p in options) {
        this.setControlVisible(p, options[p]);
      }
      return this;
    },

    /**
     * Returns the instance of the control visibility set for this object.
     * @private
     * @returns {Object}
     */
    _getControlsVisibility: function() {
      if (!this._controlsVisibility) {
        this._controlsVisibility = {
          tl: true,
          tr: true,
          br: true,
          bl: true,
          ml: true,
          mt: true,
          mr: true,
          mb: true,
          mtr: true
        };
      }
      return this._controlsVisibility;
    }
  });
})();


fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

  /**
   * Animation duration (in ms) for fx* methods
   * @type Number
   * @default
   */
  FX_DURATION: 500,

  /**
   * Centers object horizontally with animation.
   * @param {fabric.Object} object Object to center
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  fxCenterObjectH: function (object, callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    fabric.util.animate({
      startValue: object.left,
      endValue: this.getCenter().left,
      duration: this.FX_DURATION,
      onChange: function(value) {
        object.set('left', value);
        _this.requestRenderAll();
        onChange();
      },
      onComplete: function() {
        object.setCoords();
        onComplete();
      }
    });

    return this;
  },

  /**
   * Centers object vertically with animation.
   * @param {fabric.Object} object Object to center
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  fxCenterObjectV: function (object, callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    fabric.util.animate({
      startValue: object.top,
      endValue: this.getCenter().top,
      duration: this.FX_DURATION,
      onChange: function(value) {
        object.set('top', value);
        _this.requestRenderAll();
        onChange();
      },
      onComplete: function() {
        object.setCoords();
        onComplete();
      }
    });

    return this;
  },

  /**
   * Same as `fabric.Canvas#remove` but animated
   * @param {fabric.Object} object Object to remove
   * @param {Object} [callbacks] Callbacks object with optional "onComplete" and/or "onChange" properties
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  fxRemove: function (object, callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    fabric.util.animate({
      startValue: object.opacity,
      endValue: 0,
      duration: this.FX_DURATION,
      onStart: function() {
        object.set('active', false);
      },
      onChange: function(value) {
        object.set('opacity', value);
        _this.requestRenderAll();
        onChange();
      },
      onComplete: function () {
        _this.remove(object);
        onComplete();
      }
    });

    return this;
  }
});

fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {
  /**
   * Animates object's properties
   * @param {String|Object} property Property to animate (if string) or properties to animate (if object)
   * @param {Number|Object} value Value to animate property to (if string was given first) or options object
   * @return {fabric.Object} thisArg
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#animation}
   * @chainable
   *
   * As object — multiple properties
   *
   * object.animate({ left: ..., top: ... });
   * object.animate({ left: ..., top: ... }, { duration: ... });
   *
   * As string — one property
   *
   * object.animate('left', ...);
   * object.animate('left', { duration: ... });
   *
   */
  animate: function() {
    if (arguments[0] && typeof arguments[0] === 'object') {
      var propsToAnimate = [], prop, skipCallbacks;
      for (prop in arguments[0]) {
        propsToAnimate.push(prop);
      }
      for (var i = 0, len = propsToAnimate.length; i < len; i++) {
        prop = propsToAnimate[i];
        skipCallbacks = i !== len - 1;
        this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);
      }
    }
    else {
      this._animate.apply(this, arguments);
    }
    return this;
  },

  /**
   * @private
   * @param {String} property Property to animate
   * @param {String} to Value to animate to
   * @param {Object} [options] Options object
   * @param {Boolean} [skipCallbacks] When true, callbacks like onchange and oncomplete are not invoked
   */
  _animate: function(property, to, options, skipCallbacks) {
    var _this = this, propPair;

    to = to.toString();

    if (!options) {
      options = { };
    }
    else {
      options = fabric.util.object.clone(options);
    }

    if (~property.indexOf('.')) {
      propPair = property.split('.');
    }

    var currentValue = propPair
      ? this.get(propPair[0])[propPair[1]]
      : this.get(property);

    if (!('from' in options)) {
      options.from = currentValue;
    }

    if (~to.indexOf('=')) {
      to = currentValue + parseFloat(to.replace('=', ''));
    }
    else {
      to = parseFloat(to);
    }

    fabric.util.animate({
      startValue: options.from,
      endValue: to,
      byValue: options.by,
      easing: options.easing,
      duration: options.duration,
      abort: options.abort && function() {
        return options.abort.call(_this);
      },
      onChange: function(value, valueProgress, timeProgress) {
        if (propPair) {
          _this[propPair[0]][propPair[1]] = value;
        }
        else {
          _this.set(property, value);
        }
        if (skipCallbacks) {
          return;
        }
        options.onChange && options.onChange(value, valueProgress, timeProgress);
      },
      onComplete: function(value, valueProgress, timeProgress) {
        if (skipCallbacks) {
          return;
        }

        _this.setCoords();
        options.onComplete && options.onComplete(value, valueProgress, timeProgress);
      }
    });
  }
});


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      clone = fabric.util.object.clone,
      coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 },
      supportsLineDash = fabric.StaticCanvas.supports('setLineDash');

  if (fabric.Line) {
    fabric.warn('fabric.Line is already defined');
    return;
  }

  var cacheProperties = fabric.Object.prototype.cacheProperties.concat();
  cacheProperties.push(
    'x1',
    'x2',
    'y1',
    'y2'
  );

  /**
   * Line class
   * @class fabric.Line
   * @extends fabric.Object
   * @see {@link fabric.Line#initialize} for constructor definition
   */
  fabric.Line = fabric.util.createClass(fabric.Object, /** @lends fabric.Line.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'line',

    /**
     * x value or first line edge
     * @type Number
     * @default
     */
    x1: 0,

    /**
     * y value or first line edge
     * @type Number
     * @default
     */
    y1: 0,

    /**
     * x value or second line edge
     * @type Number
     * @default
     */
    x2: 0,

    /**
     * y value or second line edge
     * @type Number
     * @default
     */
    y2: 0,

    cacheProperties: cacheProperties,

    /**
     * Constructor
     * @param {Array} [points] Array of points
     * @param {Object} [options] Options object
     * @return {fabric.Line} thisArg
     */
    initialize: function(points, options) {
      if (!points) {
        points = [0, 0, 0, 0];
      }

      this.callSuper('initialize', options);

      this.set('x1', points[0]);
      this.set('y1', points[1]);
      this.set('x2', points[2]);
      this.set('y2', points[3]);

      this._setWidthHeight(options);
    },

    /**
     * @private
     * @param {Object} [options] Options
     */
    _setWidthHeight: function(options) {
      options || (options = { });

      this.width = Math.abs(this.x2 - this.x1);
      this.height = Math.abs(this.y2 - this.y1);

      this.left = 'left' in options
        ? options.left
        : this._getLeftToOriginX();

      this.top = 'top' in options
        ? options.top
        : this._getTopToOriginY();
    },

    /**
     * @private
     * @param {String} key
     * @param {*} value
     */
    _set: function(key, value) {
      this.callSuper('_set', key, value);
      if (typeof coordProps[key] !== 'undefined') {
        this._setWidthHeight();
      }
      return this;
    },

    /**
     * @private
     * @return {Number} leftToOriginX Distance from left edge of canvas to originX of Line.
     */
    _getLeftToOriginX: makeEdgeToOriginGetter(
      { // property names
        origin: 'originX',
        axis1: 'x1',
        axis2: 'x2',
        dimension: 'width'
      },
      { // possible values of origin
        nearest: 'left',
        center: 'center',
        farthest: 'right'
      }
    ),

    /**
     * @private
     * @return {Number} topToOriginY Distance from top edge of canvas to originY of Line.
     */
    _getTopToOriginY: makeEdgeToOriginGetter(
      { // property names
        origin: 'originY',
        axis1: 'y1',
        axis2: 'y2',
        dimension: 'height'
      },
      { // possible values of origin
        nearest: 'top',
        center: 'center',
        farthest: 'bottom'
      }
    ),

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      ctx.beginPath();

      if (!this.strokeDashArray || this.strokeDashArray && supportsLineDash) {
        // move from center (of virtual box) to its left/top corner
        // we can't assume x1, y1 is top left and x2, y2 is bottom right
        var p = this.calcLinePoints();
        ctx.moveTo(p.x1, p.y1);
        ctx.lineTo(p.x2, p.y2);
      }

      ctx.lineWidth = this.strokeWidth;

      // TODO: test this
      // make sure setting "fill" changes color of a line
      // (by copying fillStyle to strokeStyle, since line is stroked, not filled)
      var origStrokeStyle = ctx.strokeStyle;
      ctx.strokeStyle = this.stroke || ctx.fillStyle;
      this.stroke && this._renderStroke(ctx);
      ctx.strokeStyle = origStrokeStyle;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var p = this.calcLinePoints();

      ctx.beginPath();
      fabric.util.drawDashedLine(ctx, p.x1, p.y1, p.x2, p.y2, this.strokeDashArray);
      ctx.closePath();
    },

    /**
     * This function is an helper for svg import. it returns the center of the object in the svg
     * untransformed coordinates
     * @private
     * @return {Object} center point from element coordinates
     */
    _findCenterFromElement: function() {
      return {
        x: (this.x1 + this.x2) / 2,
        y: (this.y1 + this.y2) / 2,
      };
    },

    /**
     * Returns object representation of an instance
     * @methd toObject
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return extend(this.callSuper('toObject', propertiesToInclude), this.calcLinePoints());
    },

    /*
     * Calculate object dimensions from its properties
     * @private
     */
    _getNonTransformedDimensions: function() {
      var dim = this.callSuper('_getNonTransformedDimensions');
      if (this.strokeLineCap === 'butt') {
        if (this.width === 0) {
          dim.y -= this.strokeWidth;
        }
        if (this.height === 0) {
          dim.x -= this.strokeWidth;
        }
      }
      return dim;
    },

    /**
     * Recalculates line points given width and height
     * @private
     */
    calcLinePoints: function() {
      var xMult = this.x1 <= this.x2 ? -1 : 1,
          yMult = this.y1 <= this.y2 ? -1 : 1,
          x1 = (xMult * this.width * 0.5),
          y1 = (yMult * this.height * 0.5),
          x2 = (xMult * this.width * -0.5),
          y2 = (yMult * this.height * -0.5);

      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2
      };
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      var markup = this._createBaseSVGMarkup(),
          p = this.calcLinePoints();
      markup.push(
        '<line ', this.getSvgId(),
          'x1="', p.x1,
          '" y1="', p.y1,
          '" x2="', p.x2,
          '" y2="', p.y2,
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(),
          this.getSvgTransformMatrix(),
        '"/>\n'
      );

      return reviver ? reviver(markup.join('')) : markup.join('');
    },
    /* _TO_SVG_END_ */
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Line.fromElement})
   * @static
   * @memberOf fabric.Line
   * @see http://www.w3.org/TR/SVG/shapes.html#LineElement
   */
  fabric.Line.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x1 y1 x2 y2'.split(' '));

  /**
   * Returns fabric.Line instance from an SVG element
   * @static
   * @memberOf fabric.Line
   * @param {SVGElement} element Element to parse
   * @param {Object} [options] Options object
   * @param {Function} [callback] callback function invoked after parsing
   */
  fabric.Line.fromElement = function(element, callback, options) {
    options = options || { };
    var parsedAttributes = fabric.parseAttributes(element, fabric.Line.ATTRIBUTE_NAMES),
        points = [
          parsedAttributes.x1 || 0,
          parsedAttributes.y1 || 0,
          parsedAttributes.x2 || 0,
          parsedAttributes.y2 || 0
        ];
    callback(new fabric.Line(points, extend(parsedAttributes, options)));
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Line instance from an object representation
   * @static
   * @memberOf fabric.Line
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   */
  fabric.Line.fromObject = function(object, callback) {
    function _callback(instance) {
      delete instance.points;
      callback && callback(instance);
    };
    var options = clone(object, true);
    options.points = [object.x1, object.y1, object.x2, object.y2];
    fabric.Object._fromObject('Line', options, _callback, 'points');
  };

  /**
   * Produces a function that calculates distance from canvas edge to Line origin.
   */
  function makeEdgeToOriginGetter(propertyNames, originValues) {
    var origin = propertyNames.origin,
        axis1 = propertyNames.axis1,
        axis2 = propertyNames.axis2,
        dimension = propertyNames.dimension,
        nearest = originValues.nearest,
        center = originValues.center,
        farthest = originValues.farthest;

    return function() {
      switch (this.get(origin)) {
        case nearest:
          return Math.min(this.get(axis1), this.get(axis2));
        case center:
          return Math.min(this.get(axis1), this.get(axis2)) + (0.5 * this.get(dimension));
        case farthest:
          return Math.max(this.get(axis1), this.get(axis2));
      }
    };

  }

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      pi = Math.PI,
      extend = fabric.util.object.extend;

  if (fabric.Circle) {
    fabric.warn('fabric.Circle is already defined.');
    return;
  }

  var cacheProperties = fabric.Object.prototype.cacheProperties.concat();
  cacheProperties.push(
    'radius'
  );

  /**
   * Circle class
   * @class fabric.Circle
   * @extends fabric.Object
   * @see {@link fabric.Circle#initialize} for constructor definition
   */
  fabric.Circle = fabric.util.createClass(fabric.Object, /** @lends fabric.Circle.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'circle',

    /**
     * Radius of this circle
     * @type Number
     * @default
     */
    radius: 0,

    /**
     * Start angle of the circle, moving clockwise
     * @type Number
     * @default 0
     */
    startAngle: 0,

    /**
     * End angle of the circle
     * @type Number
     * @default 2Pi
     */
    endAngle: pi * 2,

    cacheProperties: cacheProperties,

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @return {fabric.Circle} thisArg
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      this.set('radius', options && options.radius || 0);
    },

    /**
     * @private
     * @param {String} key
     * @param {*} value
     * @return {fabric.Circle} thisArg
     */
    _set: function(key, value) {
      this.callSuper('_set', key, value);

      if (key === 'radius') {
        this.setRadius(value);
      }

      return this;
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['radius', 'startAngle', 'endAngle'].concat(propertiesToInclude));
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      var markup = this._createBaseSVGMarkup(), x = 0, y = 0,
          angle = (this.endAngle - this.startAngle) % ( 2 * pi);

      if (angle === 0) {
        markup.push(
          '<circle ', this.getSvgId(),
            'cx="' + x + '" cy="' + y + '" ',
            'r="', this.radius,
            '" style="', this.getSvgStyles(),
            '" transform="', this.getSvgTransform(),
            ' ', this.getSvgTransformMatrix(),
          '"/>\n'
        );
      }
      else {
        var startX = Math.cos(this.startAngle) * this.radius,
            startY = Math.sin(this.startAngle) * this.radius,
            endX = Math.cos(this.endAngle) * this.radius,
            endY = Math.sin(this.endAngle) * this.radius,
            largeFlag = angle > pi ? '1' : '0';

        markup.push(
          '<path d="M ' + startX + ' ' + startY,
          ' A ' + this.radius + ' ' + this.radius,
          ' 0 ', +largeFlag + ' 1', ' ' + endX + ' ' + endY,
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(),
          ' ', this.getSvgTransformMatrix(),
          '"/>\n'
        );
      }

      return reviver ? reviver(markup.join('')) : markup.join('');
    },
    /* _TO_SVG_END_ */

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render on
     */
    _render: function(ctx) {
      ctx.beginPath();
      ctx.arc(0,
              0,
              this.radius,
              this.startAngle,
              this.endAngle, false);
      this._renderFill(ctx);
      this._renderStroke(ctx);
    },

    /**
     * Returns horizontal radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRadiusX: function() {
      return this.get('radius') * this.get('scaleX');
    },

    /**
     * Returns vertical radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRadiusY: function() {
      return this.get('radius') * this.get('scaleY');
    },

    /**
     * Sets radius of an object (and updates width accordingly)
     * @return {fabric.Circle} thisArg
     */
    setRadius: function(value) {
      this.radius = value;
      return this.set('width', value * 2).set('height', value * 2);
    },
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Circle.fromElement})
   * @static
   * @memberOf fabric.Circle
   * @see: http://www.w3.org/TR/SVG/shapes.html#CircleElement
   */
  fabric.Circle.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy r'.split(' '));

  /**
   * Returns {@link fabric.Circle} instance from an SVG element
   * @static
   * @memberOf fabric.Circle
   * @param {SVGElement} element Element to parse
   * @param {Object} [options] Options object
   * @param {Function} [callback] Options callback invoked after parsing is finished
   * @throws {Error} If value of `r` attribute is missing or invalid
   */
  fabric.Circle.fromElement = function(element, callback, options) {
    options || (options = { });

    var parsedAttributes = fabric.parseAttributes(element, fabric.Circle.ATTRIBUTE_NAMES);

    if (!isValidRadius(parsedAttributes)) {
      throw new Error('value of `r` attribute is required and can not be negative');
    }

    parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;
    parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;
    callback(new fabric.Circle(extend(parsedAttributes, options)));
  };

  /**
   * @private
   */
  function isValidRadius(attributes) {
    return (('radius' in attributes) && (attributes.radius >= 0));
  }
  /* _FROM_SVG_END_ */

  /**
   * Returns {@link fabric.Circle} instance from an object representation
   * @static
   * @memberOf fabric.Circle
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   * @return {Object} Instance of fabric.Circle
   */
  fabric.Circle.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Circle', object, callback);
  };

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.Triangle) {
    fabric.warn('fabric.Triangle is already defined');
    return;
  }

  /**
   * Triangle class
   * @class fabric.Triangle
   * @extends fabric.Object
   * @return {fabric.Triangle} thisArg
   * @see {@link fabric.Triangle#initialize} for constructor definition
   */
  fabric.Triangle = fabric.util.createClass(fabric.Object, /** @lends fabric.Triangle.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'triangle',

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      this.set('width', options && options.width || 100)
          .set('height', options && options.height || 100);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      var widthBy2 = this.width / 2,
          heightBy2 = this.height / 2;

      ctx.beginPath();
      ctx.moveTo(-widthBy2, heightBy2);
      ctx.lineTo(0, -heightBy2);
      ctx.lineTo(widthBy2, heightBy2);
      ctx.closePath();

      this._renderFill(ctx);
      this._renderStroke(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var widthBy2 = this.width / 2,
          heightBy2 = this.height / 2;

      ctx.beginPath();
      fabric.util.drawDashedLine(ctx, -widthBy2, heightBy2, 0, -heightBy2, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, 0, -heightBy2, widthBy2, heightBy2, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, widthBy2, heightBy2, -widthBy2, heightBy2, this.strokeDashArray);
      ctx.closePath();
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      var markup = this._createBaseSVGMarkup(),
          widthBy2 = this.width / 2,
          heightBy2 = this.height / 2,
          points = [
            -widthBy2 + ' ' + heightBy2,
            '0 ' + -heightBy2,
            widthBy2 + ' ' + heightBy2
          ]
          .join(',');

      markup.push(
        '<polygon ', this.getSvgId(),
          'points="', points,
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(),
        '"/>'
      );

      return reviver ? reviver(markup.join('')) : markup.join('');
    },
    /* _TO_SVG_END_ */
  });

  /**
   * Returns {@link fabric.Triangle} instance from an object representation
   * @static
   * @memberOf fabric.Triangle
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   */
  fabric.Triangle.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Triangle', object, callback);
  };

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      piBy2   = Math.PI * 2,
      extend = fabric.util.object.extend;

  if (fabric.Ellipse) {
    fabric.warn('fabric.Ellipse is already defined.');
    return;
  }

  var cacheProperties = fabric.Object.prototype.cacheProperties.concat();
  cacheProperties.push(
    'rx',
    'ry'
  );

  /**
   * Ellipse class
   * @class fabric.Ellipse
   * @extends fabric.Object
   * @return {fabric.Ellipse} thisArg
   * @see {@link fabric.Ellipse#initialize} for constructor definition
   */
  fabric.Ellipse = fabric.util.createClass(fabric.Object, /** @lends fabric.Ellipse.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'ellipse',

    /**
     * Horizontal radius
     * @type Number
     * @default
     */
    rx:   0,

    /**
     * Vertical radius
     * @type Number
     * @default
     */
    ry:   0,

    cacheProperties: cacheProperties,

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @return {fabric.Ellipse} thisArg
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      this.set('rx', options && options.rx || 0);
      this.set('ry', options && options.ry || 0);
    },

    /**
     * @private
     * @param {String} key
     * @param {*} value
     * @return {fabric.Ellipse} thisArg
     */
    _set: function(key, value) {
      this.callSuper('_set', key, value);
      switch (key) {

        case 'rx':
          this.rx = value;
          this.set('width', value * 2);
          break;

        case 'ry':
          this.ry = value;
          this.set('height', value * 2);
          break;

      }
      return this;
    },

    /**
     * Returns horizontal radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRx: function() {
      return this.get('rx') * this.get('scaleX');
    },

    /**
     * Returns Vertical radius of an object (according to how an object is scaled)
     * @return {Number}
     */
    getRy: function() {
      return this.get('ry') * this.get('scaleY');
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      var markup = this._createBaseSVGMarkup(), x = 0, y = 0;
      markup.push(
        '<ellipse ', this.getSvgId(),
          'cx="', x, '" cy="', y, '" ',
          'rx="', this.rx,
          '" ry="', this.ry,
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(),
          this.getSvgTransformMatrix(),
        '"/>\n'
      );

      return reviver ? reviver(markup.join('')) : markup.join('');
    },
    /* _TO_SVG_END_ */

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render on
     */
    _render: function(ctx) {
      ctx.beginPath();
      ctx.save();
      ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);
      ctx.arc(
        0,
        0,
        this.rx,
        0,
        piBy2,
        false);
      ctx.restore();
      this._renderFill(ctx);
      this._renderStroke(ctx);
    },
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Ellipse.fromElement})
   * @static
   * @memberOf fabric.Ellipse
   * @see http://www.w3.org/TR/SVG/shapes.html#EllipseElement
   */
  fabric.Ellipse.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('cx cy rx ry'.split(' '));

  /**
   * Returns {@link fabric.Ellipse} instance from an SVG element
   * @static
   * @memberOf fabric.Ellipse
   * @param {SVGElement} element Element to parse
   * @param {Object} [options] Options object
   * @param {Function} [callback] Options callback invoked after parsing is finished
   * @return {fabric.Ellipse}
   */
  fabric.Ellipse.fromElement = function(element, callback, options) {
    options || (options = { });

    var parsedAttributes = fabric.parseAttributes(element, fabric.Ellipse.ATTRIBUTE_NAMES);

    parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;
    parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;
    callback(new fabric.Ellipse(extend(parsedAttributes, options)));
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns {@link fabric.Ellipse} instance from an object representation
   * @static
   * @memberOf fabric.Ellipse
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as first argument
   * @return {fabric.Ellipse}
   */
  fabric.Ellipse.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Ellipse', object, callback);
  };

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend;

  if (fabric.Rect) {
    fabric.warn('fabric.Rect is already defined');
    return;
  }

  var stateProperties = fabric.Object.prototype.stateProperties.concat();
  stateProperties.push('rx', 'ry');

  var cacheProperties = fabric.Object.prototype.cacheProperties.concat();
  cacheProperties.push('rx', 'ry');

  /**
   * Rectangle class
   * @class fabric.Rect
   * @extends fabric.Object
   * @return {fabric.Rect} thisArg
   * @see {@link fabric.Rect#initialize} for constructor definition
   */
  fabric.Rect = fabric.util.createClass(fabric.Object, /** @lends fabric.Rect.prototype */ {

    /**
     * List of properties to consider when checking if state of an object is changed ({@link fabric.Object#hasStateChanged})
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: stateProperties,

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'rect',

    /**
     * Horizontal border radius
     * @type Number
     * @default
     */
    rx:   0,

    /**
     * Vertical border radius
     * @type Number
     * @default
     */
    ry:   0,

    cacheProperties: cacheProperties,

    /**
     * Constructor
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      this._initRxRy();
    },

    /**
     * Initializes rx/ry attributes
     * @private
     */
    _initRxRy: function() {
      if (this.rx && !this.ry) {
        this.ry = this.rx;
      }
      else if (this.ry && !this.rx) {
        this.rx = this.ry;
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {

      // optimize 1x1 case (used in spray brush)
      if (this.width === 1 && this.height === 1) {
        ctx.fillRect(-0.5, -0.5, 1, 1);
        return;
      }

      var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0,
          ry = this.ry ? Math.min(this.ry, this.height / 2) : 0,
          w = this.width,
          h = this.height,
          x = -this.width / 2,
          y = -this.height / 2,
          isRounded = rx !== 0 || ry !== 0,
          /* "magic number" for bezier approximations of arcs (http://itc.ktu.lt/itc354/Riskus354.pdf) */
          k = 1 - 0.5522847498;
      ctx.beginPath();

      ctx.moveTo(x + rx, y);

      ctx.lineTo(x + w - rx, y);
      isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);

      ctx.lineTo(x + w, y + h - ry);
      isRounded && ctx.bezierCurveTo(x + w, y + h - k * ry, x + w - k * rx, y + h, x + w - rx, y + h);

      ctx.lineTo(x + rx, y + h);
      isRounded && ctx.bezierCurveTo(x + k * rx, y + h, x, y + h - k * ry, x, y + h - ry);

      ctx.lineTo(x, y + ry);
      isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);

      ctx.closePath();

      this._renderFill(ctx);
      this._renderStroke(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var x = -this.width / 2,
          y = -this.height / 2,
          w = this.width,
          h = this.height;

      ctx.beginPath();
      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
      ctx.closePath();
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['rx', 'ry'].concat(propertiesToInclude));
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      var markup = this._createBaseSVGMarkup(), x = -this.width / 2, y = -this.height / 2;
      markup.push(
        '<rect ', this.getSvgId(),
          'x="', x, '" y="', y,
          '" rx="', this.get('rx'), '" ry="', this.get('ry'),
          '" width="', this.width, '" height="', this.height,
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(),
          this.getSvgTransformMatrix(),
        '"/>\n');

      return reviver ? reviver(markup.join('')) : markup.join('');
    },
    /* _TO_SVG_END_ */
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by `fabric.Rect.fromElement`)
   * @static
   * @memberOf fabric.Rect
   * @see: http://www.w3.org/TR/SVG/shapes.html#RectElement
   */
  fabric.Rect.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat('x y rx ry width height'.split(' '));

  /**
   * Returns {@link fabric.Rect} instance from an SVG element
   * @static
   * @memberOf fabric.Rect
   * @param {SVGElement} element Element to parse
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Rect.fromElement = function(element, callback, options) {
    if (!element) {
      return callback(null);
    }
    options = options || { };

    var parsedAttributes = fabric.parseAttributes(element, fabric.Rect.ATTRIBUTE_NAMES);

    parsedAttributes.left = parsedAttributes.left || 0;
    parsedAttributes.top  = parsedAttributes.top  || 0;
    var rect = new fabric.Rect(extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
    rect.visible = rect.visible && rect.width > 0 && rect.height > 0;
    callback(rect);
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns {@link fabric.Rect} instance from an object representation
   * @static
   * @memberOf fabric.Rect
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Rect instance is created
   */
  fabric.Rect.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Rect', object, callback);
  };

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      min = fabric.util.array.min,
      max = fabric.util.array.max,
      toFixed = fabric.util.toFixed,
      NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

  if (fabric.Polyline) {
    fabric.warn('fabric.Polyline is already defined');
    return;
  }

  var cacheProperties = fabric.Object.prototype.cacheProperties.concat();
  cacheProperties.push('points');

  /**
   * Polyline class
   * @class fabric.Polyline
   * @extends fabric.Object
   * @see {@link fabric.Polyline#initialize} for constructor definition
   */
  fabric.Polyline = fabric.util.createClass(fabric.Object, /** @lends fabric.Polyline.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'polyline',

    /**
     * Points array
     * @type Array
     * @default
     */
    points: null,

    cacheProperties: cacheProperties,

    /**
     * Constructor
     * @param {Array} points Array of points (where each point is an object with x and y)
     * @param {Object} [options] Options object
     * @return {fabric.Polyline} thisArg
     * @example
     * var poly = new fabric.Polyline([
     *     { x: 10, y: 10 },
     *     { x: 50, y: 30 },
     *     { x: 40, y: 70 },
     *     { x: 60, y: 50 },
     *     { x: 100, y: 150 },
     *     { x: 40, y: 100 }
     *   ], {
     *   stroke: 'red',
     *   left: 100,
     *   top: 100
     * });
     */
    initialize: function(points, options) {
      options = options || {};
      this.points = points || [];
      this.callSuper('initialize', options);
      var calcDim = this._calcDimensions();
      if (typeof options.left === 'undefined') {
        this.left = calcDim.left;
      }
      if (typeof options.top === 'undefined') {
        this.top = calcDim.top;
      }
      this.width = calcDim.width;
      this.height = calcDim.height;
      this.pathOffset = {
        x: calcDim.left + this.width / 2,
        y: calcDim.top + this.height / 2
      };
    },

    /**
     * Calculate the polygon min and max point from points array,
     * returning an object with left, top, widht, height to measure the
     * polygon size
     * @return {Object} object.left X coordinate of the polygon leftmost point
     * @return {Object} object.top Y coordinate of the polygon topmost point
     * @return {Object} object.width distance between X coordinates of the polygon leftmost and rightmost point
     * @return {Object} object.height distance between Y coordinates of the polygon topmost and bottommost point
     * @private
     */
    _calcDimensions: function() {

      var points = this.points,
          minX = min(points, 'x') || 0,
          minY = min(points, 'y') || 0,
          maxX = max(points, 'x') || 0,
          maxY = max(points, 'y') || 0,
          width = (maxX - minX),
          height = (maxY - minY);

      return {
        left: minX,
        top: minY,
        width: width,
        height: height
      };
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return extend(this.callSuper('toObject', propertiesToInclude), {
        points: this.points.concat()
      });
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y,
          markup = this._createBaseSVGMarkup();

      for (var i = 0, len = this.points.length; i < len; i++) {
        points.push(
          toFixed(this.points[i].x - diffX, NUM_FRACTION_DIGITS), ',',
          toFixed(this.points[i].y - diffY, NUM_FRACTION_DIGITS), ' '
        );
      }
      markup.push(
        '<', this.type, ' ', this.getSvgId(),
          'points="', points.join(''),
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(),
          ' ', this.getSvgTransformMatrix(),
        '"/>\n'
      );

      return reviver ? reviver(markup.join('')) : markup.join('');
    },
    /* _TO_SVG_END_ */


    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    commonRender: function(ctx) {
      var point, len = this.points.length,
          x = this.pathOffset.x,
          y = this.pathOffset.y;

      if (!len || isNaN(this.points[len - 1].y)) {
        // do not draw if no points or odd points
        // NaN comes from parseFloat of a empty string in parser
        return false;
      }
      ctx.beginPath();
      ctx.moveTo(this.points[0].x - x, this.points[0].y - y);
      for (var i = 0; i < len; i++) {
        point = this.points[i];
        ctx.lineTo(point.x - x, point.y - y);
      }
      return true;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      if (!this.commonRender(ctx)) {
        return;
      }
      this._renderFill(ctx);
      this._renderStroke(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var p1, p2;

      ctx.beginPath();
      for (var i = 0, len = this.points.length; i < len; i++) {
        p1 = this.points[i];
        p2 = this.points[i + 1] || p1;
        fabric.util.drawDashedLine(ctx, p1.x, p1.y, p2.x, p2.y, this.strokeDashArray);
      }
    },

    /**
     * Returns complexity of an instance
     * @return {Number} complexity of this instance
     */
    complexity: function() {
      return this.get('points').length;
    }
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Polyline.fromElement})
   * @static
   * @memberOf fabric.Polyline
   * @see: http://www.w3.org/TR/SVG/shapes.html#PolylineElement
   */
  fabric.Polyline.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();

  /**
   * Returns fabric.Polyline instance from an SVG element
   * @static
   * @memberOf fabric.Polyline
   * @param {SVGElement} element Element to parser
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Polyline.fromElement = function(element, callback, options) {
    if (!element) {
      return callback(null);
    }
    options || (options = { });

    var points = fabric.parsePointsAttribute(element.getAttribute('points')),
        parsedAttributes = fabric.parseAttributes(element, fabric.Polyline.ATTRIBUTE_NAMES);

    callback(new fabric.Polyline(points, fabric.util.object.extend(parsedAttributes, options)));
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Polyline instance from an object representation
   * @static
   * @memberOf fabric.Polyline
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
   */
  fabric.Polyline.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Polyline', object, callback, 'points');
  };

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend;

  if (fabric.Polygon) {
    fabric.warn('fabric.Polygon is already defined');
    return;
  }

  /**
   * Polygon class
   * @class fabric.Polygon
   * @extends fabric.Polyline
   * @see {@link fabric.Polygon#initialize} for constructor definition
   */
  fabric.Polygon = fabric.util.createClass(fabric.Polyline, /** @lends fabric.Polygon.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'polygon',

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      if (!this.commonRender(ctx)) {
        return;
      }
      ctx.closePath();
      this._renderFill(ctx);
      this._renderStroke(ctx);
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      this.callSuper('_renderDashedStroke', ctx);
      ctx.closePath();
    },
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by `fabric.Polygon.fromElement`)
   * @static
   * @memberOf fabric.Polygon
   * @see: http://www.w3.org/TR/SVG/shapes.html#PolygonElement
   */
  fabric.Polygon.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat();

  /**
   * Returns {@link fabric.Polygon} instance from an SVG element
   * @static
   * @memberOf fabric.Polygon
   * @param {SVGElement} element Element to parse
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Polygon.fromElement = function(element, callback, options) {
    if (!element) {
      return callback(null);
    }

    options || (options = { });

    var points = fabric.parsePointsAttribute(element.getAttribute('points')),
        parsedAttributes = fabric.parseAttributes(element, fabric.Polygon.ATTRIBUTE_NAMES);

    callback(new fabric.Polygon(points, extend(parsedAttributes, options)));
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Polygon instance from an object representation
   * @static
   * @memberOf fabric.Polygon
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
   */
  fabric.Polygon.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Polygon', object, callback, 'points');
  };

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      min = fabric.util.array.min,
      max = fabric.util.array.max,
      extend = fabric.util.object.extend,
      _toString = Object.prototype.toString,
      drawArc = fabric.util.drawArc,
      commandLengths = {
        m: 2,
        l: 2,
        h: 1,
        v: 1,
        c: 6,
        s: 4,
        q: 4,
        t: 2,
        a: 7
      },
      repeatedCommands = {
        m: 'l',
        M: 'L'
      };

  if (fabric.Path) {
    fabric.warn('fabric.Path is already defined');
    return;
  }

  var stateProperties = fabric.Object.prototype.stateProperties.concat();
  stateProperties.push('path');

  var cacheProperties = fabric.Object.prototype.cacheProperties.concat();
  cacheProperties.push('path', 'fillRule');

  /**
   * Path class
   * @class fabric.Path
   * @extends fabric.Object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#path_and_pathgroup}
   * @see {@link fabric.Path#initialize} for constructor definition
   */
  fabric.Path = fabric.util.createClass(fabric.Object, /** @lends fabric.Path.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'path',

    /**
     * Array of path points
     * @type Array
     * @default
     */
    path: null,

    cacheProperties: cacheProperties,

    stateProperties: stateProperties,

    /**
     * Constructor
     * @param {Array|String} path Path data (sequence of coordinates and corresponding "command" tokens)
     * @param {Object} [options] Options object
     * @return {fabric.Path} thisArg
     */
    initialize: function(path, options) {
      options = options || { };
      this.callSuper('initialize', options);

      if (!path) {
        path = [];
      }

      var fromArray = _toString.call(path) === '[object Array]';

      this.path = fromArray
        ? path
        // one of commands (m,M,l,L,q,Q,c,C,etc.) followed by non-command characters (i.e. command values)
        : path.match && path.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);

      if (!this.path) {
        return;
      }

      if (!fromArray) {
        this.path = this._parsePath();
      }

      this._setPositionDimensions(options);
    },

    /**
     * @private
     * @param {Object} options Options object
     */
    _setPositionDimensions: function(options) {
      var calcDim = this._parseDimensions();

      this.width = calcDim.width;
      this.height = calcDim.height;

      if (typeof options.left === 'undefined') {
        this.left = calcDim.left;
      }

      if (typeof options.top === 'undefined') {
        this.top = calcDim.top;
      }

      this.pathOffset = this.pathOffset || {
        x: calcDim.left + this.width / 2,
        y: calcDim.top + this.height / 2
      };
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render path on
     */
    _renderPathCommands: function(ctx) {
      var current, // current instruction
          previous = null,
          subpathStartX = 0,
          subpathStartY = 0,
          x = 0, // current x
          y = 0, // current y
          controlX = 0, // current control point x
          controlY = 0, // current control point y
          tempX,
          tempY,
          l = -this.pathOffset.x,
          t = -this.pathOffset.y;

      ctx.beginPath();

      for (var i = 0, len = this.path.length; i < len; ++i) {

        current = this.path[i];

        switch (current[0]) { // first letter

          case 'l': // lineto, relative
            x += current[1];
            y += current[2];
            ctx.lineTo(x + l, y + t);
            break;

          case 'L': // lineto, absolute
            x = current[1];
            y = current[2];
            ctx.lineTo(x + l, y + t);
            break;

          case 'h': // horizontal lineto, relative
            x += current[1];
            ctx.lineTo(x + l, y + t);
            break;

          case 'H': // horizontal lineto, absolute
            x = current[1];
            ctx.lineTo(x + l, y + t);
            break;

          case 'v': // vertical lineto, relative
            y += current[1];
            ctx.lineTo(x + l, y + t);
            break;

          case 'V': // verical lineto, absolute
            y = current[1];
            ctx.lineTo(x + l, y + t);
            break;

          case 'm': // moveTo, relative
            x += current[1];
            y += current[2];
            subpathStartX = x;
            subpathStartY = y;
            ctx.moveTo(x + l, y + t);
            break;

          case 'M': // moveTo, absolute
            x = current[1];
            y = current[2];
            subpathStartX = x;
            subpathStartY = y;
            ctx.moveTo(x + l, y + t);
            break;

          case 'c': // bezierCurveTo, relative
            tempX = x + current[5];
            tempY = y + current[6];
            controlX = x + current[3];
            controlY = y + current[4];
            ctx.bezierCurveTo(
              x + current[1] + l, // x1
              y + current[2] + t, // y1
              controlX + l, // x2
              controlY + t, // y2
              tempX + l,
              tempY + t
            );
            x = tempX;
            y = tempY;
            break;

          case 'C': // bezierCurveTo, absolute
            x = current[5];
            y = current[6];
            controlX = current[3];
            controlY = current[4];
            ctx.bezierCurveTo(
              current[1] + l,
              current[2] + t,
              controlX + l,
              controlY + t,
              x + l,
              y + t
            );
            break;

          case 's': // shorthand cubic bezierCurveTo, relative

            // transform to absolute x,y
            tempX = x + current[3];
            tempY = y + current[4];

            if (previous[0].match(/[CcSs]/) === null) {
              // If there is no previous command or if the previous command was not a C, c, S, or s,
              // the control point is coincident with the current point
              controlX = x;
              controlY = y;
            }
            else {
              // calculate reflection of previous control points
              controlX = 2 * x - controlX;
              controlY = 2 * y - controlY;
            }

            ctx.bezierCurveTo(
              controlX + l,
              controlY + t,
              x + current[1] + l,
              y + current[2] + t,
              tempX + l,
              tempY + t
            );
            // set control point to 2nd one of this command
            // "... the first control point is assumed to be
            // the reflection of the second control point on
            // the previous command relative to the current point."
            controlX = x + current[1];
            controlY = y + current[2];

            x = tempX;
            y = tempY;
            break;

          case 'S': // shorthand cubic bezierCurveTo, absolute
            tempX = current[3];
            tempY = current[4];
            if (previous[0].match(/[CcSs]/) === null) {
              // If there is no previous command or if the previous command was not a C, c, S, or s,
              // the control point is coincident with the current point
              controlX = x;
              controlY = y;
            }
            else {
              // calculate reflection of previous control points
              controlX = 2 * x - controlX;
              controlY = 2 * y - controlY;
            }
            ctx.bezierCurveTo(
              controlX + l,
              controlY + t,
              current[1] + l,
              current[2] + t,
              tempX + l,
              tempY + t
            );
            x = tempX;
            y = tempY;

            // set control point to 2nd one of this command
            // "... the first control point is assumed to be
            // the reflection of the second control point on
            // the previous command relative to the current point."
            controlX = current[1];
            controlY = current[2];

            break;

          case 'q': // quadraticCurveTo, relative
            // transform to absolute x,y
            tempX = x + current[3];
            tempY = y + current[4];

            controlX = x + current[1];
            controlY = y + current[2];

            ctx.quadraticCurveTo(
              controlX + l,
              controlY + t,
              tempX + l,
              tempY + t
            );
            x = tempX;
            y = tempY;
            break;

          case 'Q': // quadraticCurveTo, absolute
            tempX = current[3];
            tempY = current[4];

            ctx.quadraticCurveTo(
              current[1] + l,
              current[2] + t,
              tempX + l,
              tempY + t
            );
            x = tempX;
            y = tempY;
            controlX = current[1];
            controlY = current[2];
            break;

          case 't': // shorthand quadraticCurveTo, relative

            // transform to absolute x,y
            tempX = x + current[1];
            tempY = y + current[2];

            if (previous[0].match(/[QqTt]/) === null) {
              // If there is no previous command or if the previous command was not a Q, q, T or t,
              // assume the control point is coincident with the current point
              controlX = x;
              controlY = y;
            }
            else {
              // calculate reflection of previous control point
              controlX = 2 * x - controlX;
              controlY = 2 * y - controlY;
            }

            ctx.quadraticCurveTo(
              controlX + l,
              controlY + t,
              tempX + l,
              tempY + t
            );
            x = tempX;
            y = tempY;

            break;

          case 'T':
            tempX = current[1];
            tempY = current[2];

            if (previous[0].match(/[QqTt]/) === null) {
              // If there is no previous command or if the previous command was not a Q, q, T or t,
              // assume the control point is coincident with the current point
              controlX = x;
              controlY = y;
            }
            else {
              // calculate reflection of previous control point
              controlX = 2 * x - controlX;
              controlY = 2 * y - controlY;
            }
            ctx.quadraticCurveTo(
              controlX + l,
              controlY + t,
              tempX + l,
              tempY + t
            );
            x = tempX;
            y = tempY;
            break;

          case 'a':
            // TODO: optimize this
            drawArc(ctx, x + l, y + t, [
              current[1],
              current[2],
              current[3],
              current[4],
              current[5],
              current[6] + x + l,
              current[7] + y + t
            ]);
            x += current[6];
            y += current[7];
            break;

          case 'A':
            // TODO: optimize this
            drawArc(ctx, x + l, y + t, [
              current[1],
              current[2],
              current[3],
              current[4],
              current[5],
              current[6] + l,
              current[7] + t
            ]);
            x = current[6];
            y = current[7];
            break;

          case 'z':
          case 'Z':
            x = subpathStartX;
            y = subpathStartY;
            ctx.closePath();
            break;
        }
        previous = current;
      }
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx context to render path on
     */
    _render: function(ctx) {
      this._renderPathCommands(ctx);
      this._renderFill(ctx);
      this._renderStroke(ctx);
    },

    /**
     * Returns string representation of an instance
     * @return {String} string representation of an instance
     */
    toString: function() {
      return '#<fabric.Path (' + this.complexity() +
        '): { "top": ' + this.top + ', "left": ' + this.left + ' }>';
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var o = extend(this.callSuper('toObject', propertiesToInclude), {
        path: this.path.map(function(item) { return item.slice(); }),
        top: this.top,
        left: this.left,
      });
      return o;
    },

    /**
     * Returns dataless object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toDatalessObject: function(propertiesToInclude) {
      var o = this.toObject(['sourcePath'].concat(propertiesToInclude));
      if (o.sourcePath) {
        delete o.path;
      }
      return o;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      var chunks = [],
          markup = this._createBaseSVGMarkup(), addTransform = '';

      for (var i = 0, len = this.path.length; i < len; i++) {
        chunks.push(this.path[i].join(' '));
      }
      var path = chunks.join(' ');
      addTransform = ' translate(' + (-this.pathOffset.x) + ', ' + (-this.pathOffset.y) + ') ';
      markup.push(
        '<path ', this.getSvgId(),
          'd="', path,
          '" style="', this.getSvgStyles(),
          '" transform="', this.getSvgTransform(), addTransform,
          this.getSvgTransformMatrix(), '" stroke-linecap="round" ',
        '/>\n'
      );

      return reviver ? reviver(markup.join('')) : markup.join('');
    },
    /* _TO_SVG_END_ */

    /**
     * Returns number representation of an instance complexity
     * @return {Number} complexity of this instance
     */
    complexity: function() {
      return this.path.length;
    },

    /**
     * @private
     */
    _parsePath: function() {
      var result = [],
          coords = [],
          currentPath,
          parsed,
          re = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:e[-+]?\d+)?)/ig,
          match,
          coordsStr;

      for (var i = 0, coordsParsed, len = this.path.length; i < len; i++) {
        currentPath = this.path[i];

        coordsStr = currentPath.slice(1).trim();
        coords.length = 0;

        while ((match = re.exec(coordsStr))) {
          coords.push(match[0]);
        }

        coordsParsed = [currentPath.charAt(0)];

        for (var j = 0, jlen = coords.length; j < jlen; j++) {
          parsed = parseFloat(coords[j]);
          if (!isNaN(parsed)) {
            coordsParsed.push(parsed);
          }
        }

        var command = coordsParsed[0],
            commandLength = commandLengths[command.toLowerCase()],
            repeatedCommand = repeatedCommands[command] || command;

        if (coordsParsed.length - 1 > commandLength) {
          for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {
            result.push([command].concat(coordsParsed.slice(k, k + commandLength)));
            command = repeatedCommand;
          }
        }
        else {
          result.push(coordsParsed);
        }
      }

      return result;
    },

    /**
     * @private
     */
    _parseDimensions: function() {

      var aX = [],
          aY = [],
          current, // current instruction
          previous = null,
          subpathStartX = 0,
          subpathStartY = 0,
          x = 0, // current x
          y = 0, // current y
          controlX = 0, // current control point x
          controlY = 0, // current control point y
          tempX,
          tempY,
          bounds;

      for (var i = 0, len = this.path.length; i < len; ++i) {

        current = this.path[i];

        switch (current[0]) { // first letter

          case 'l': // lineto, relative
            x += current[1];
            y += current[2];
            bounds = [];
            break;

          case 'L': // lineto, absolute
            x = current[1];
            y = current[2];
            bounds = [];
            break;

          case 'h': // horizontal lineto, relative
            x += current[1];
            bounds = [];
            break;

          case 'H': // horizontal lineto, absolute
            x = current[1];
            bounds = [];
            break;

          case 'v': // vertical lineto, relative
            y += current[1];
            bounds = [];
            break;

          case 'V': // verical lineto, absolute
            y = current[1];
            bounds = [];
            break;

          case 'm': // moveTo, relative
            x += current[1];
            y += current[2];
            subpathStartX = x;
            subpathStartY = y;
            bounds = [];
            break;

          case 'M': // moveTo, absolute
            x = current[1];
            y = current[2];
            subpathStartX = x;
            subpathStartY = y;
            bounds = [];
            break;

          case 'c': // bezierCurveTo, relative
            tempX = x + current[5];
            tempY = y + current[6];
            controlX = x + current[3];
            controlY = y + current[4];
            bounds = fabric.util.getBoundsOfCurve(x, y,
              x + current[1], // x1
              y + current[2], // y1
              controlX, // x2
              controlY, // y2
              tempX,
              tempY
            );
            x = tempX;
            y = tempY;
            break;

          case 'C': // bezierCurveTo, absolute
            controlX = current[3];
            controlY = current[4];
            bounds = fabric.util.getBoundsOfCurve(x, y,
              current[1],
              current[2],
              controlX,
              controlY,
              current[5],
              current[6]
            );
            x = current[5];
            y = current[6];
            break;

          case 's': // shorthand cubic bezierCurveTo, relative

            // transform to absolute x,y
            tempX = x + current[3];
            tempY = y + current[4];

            if (previous[0].match(/[CcSs]/) === null) {
              // If there is no previous command or if the previous command was not a C, c, S, or s,
              // the control point is coincident with the current point
              controlX = x;
              controlY = y;
            }
            else {
              // calculate reflection of previous control points
              controlX = 2 * x - controlX;
              controlY = 2 * y - controlY;
            }

            bounds = fabric.util.getBoundsOfCurve(x, y,
              controlX,
              controlY,
              x + current[1],
              y + current[2],
              tempX,
              tempY
            );
            // set control point to 2nd one of this command
            // "... the first control point is assumed to be
            // the reflection of the second control point on
            // the previous command relative to the current point."
            controlX = x + current[1];
            controlY = y + current[2];
            x = tempX;
            y = tempY;
            break;

          case 'S': // shorthand cubic bezierCurveTo, absolute
            tempX = current[3];
            tempY = current[4];
            if (previous[0].match(/[CcSs]/) === null) {
              // If there is no previous command or if the previous command was not a C, c, S, or s,
              // the control point is coincident with the current point
              controlX = x;
              controlY = y;
            }
            else {
              // calculate reflection of previous control points
              controlX = 2 * x - controlX;
              controlY = 2 * y - controlY;
            }
            bounds = fabric.util.getBoundsOfCurve(x, y,
              controlX,
              controlY,
              current[1],
              current[2],
              tempX,
              tempY
            );
            x = tempX;
            y = tempY;
            // set control point to 2nd one of this command
            // "... the first control point is assumed to be
            // the reflection of the second control point on
            // the previous command relative to the current point."
            controlX = current[1];
            controlY = current[2];
            break;

          case 'q': // quadraticCurveTo, relative
            // transform to absolute x,y
            tempX = x + current[3];
            tempY = y + current[4];
            controlX = x + current[1];
            controlY = y + current[2];
            bounds = fabric.util.getBoundsOfCurve(x, y,
              controlX,
              controlY,
              controlX,
              controlY,
              tempX,
              tempY
            );
            x = tempX;
            y = tempY;
            break;

          case 'Q': // quadraticCurveTo, absolute
            controlX = current[1];
            controlY = current[2];
            bounds = fabric.util.getBoundsOfCurve(x, y,
              controlX,
              controlY,
              controlX,
              controlY,
              current[3],
              current[4]
            );
            x = current[3];
            y = current[4];
            break;

          case 't': // shorthand quadraticCurveTo, relative
            // transform to absolute x,y
            tempX = x + current[1];
            tempY = y + current[2];
            if (previous[0].match(/[QqTt]/) === null) {
              // If there is no previous command or if the previous command was not a Q, q, T or t,
              // assume the control point is coincident with the current point
              controlX = x;
              controlY = y;
            }
            else {
              // calculate reflection of previous control point
              controlX = 2 * x - controlX;
              controlY = 2 * y - controlY;
            }

            bounds = fabric.util.getBoundsOfCurve(x, y,
              controlX,
              controlY,
              controlX,
              controlY,
              tempX,
              tempY
            );
            x = tempX;
            y = tempY;

            break;

          case 'T':
            tempX = current[1];
            tempY = current[2];

            if (previous[0].match(/[QqTt]/) === null) {
              // If there is no previous command or if the previous command was not a Q, q, T or t,
              // assume the control point is coincident with the current point
              controlX = x;
              controlY = y;
            }
            else {
              // calculate reflection of previous control point
              controlX = 2 * x - controlX;
              controlY = 2 * y - controlY;
            }
            bounds = fabric.util.getBoundsOfCurve(x, y,
              controlX,
              controlY,
              controlX,
              controlY,
              tempX,
              tempY
            );
            x = tempX;
            y = tempY;
            break;

          case 'a':
            // TODO: optimize this
            bounds = fabric.util.getBoundsOfArc(x, y,
              current[1],
              current[2],
              current[3],
              current[4],
              current[5],
              current[6] + x,
              current[7] + y
            );
            x += current[6];
            y += current[7];
            break;

          case 'A':
            // TODO: optimize this
            bounds = fabric.util.getBoundsOfArc(x, y,
              current[1],
              current[2],
              current[3],
              current[4],
              current[5],
              current[6],
              current[7]
            );
            x = current[6];
            y = current[7];
            break;

          case 'z':
          case 'Z':
            x = subpathStartX;
            y = subpathStartY;
            break;
        }
        previous = current;
        bounds.forEach(function (point) {
          aX.push(point.x);
          aY.push(point.y);
        });
        aX.push(x);
        aY.push(y);
      }

      var minX = min(aX) || 0,
          minY = min(aY) || 0,
          maxX = max(aX) || 0,
          maxY = max(aY) || 0,
          deltaX = maxX - minX,
          deltaY = maxY - minY,

          o = {
            left: minX,
            top: minY,
            width: deltaX,
            height: deltaY
          };

      return o;
    }
  });

  /**
   * Creates an instance of fabric.Path from an object
   * @static
   * @memberOf fabric.Path
   * @param {Object} object
   * @param {Function} [callback] Callback to invoke when an fabric.Path instance is created
   */
  fabric.Path.fromObject = function(object, callback) {
    if (typeof object.sourcePath === 'string') {
      var pathUrl = object.sourcePath;
      fabric.loadSVGFromURL(pathUrl, function (elements) {
        var path = elements[0];
        path.setOptions(object);
        callback && callback(path);
      });
    }
    else {
      fabric.Object._fromObject('Path', object, callback, 'path');
    }
  };

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by `fabric.Path.fromElement`)
   * @static
   * @memberOf fabric.Path
   * @see http://www.w3.org/TR/SVG/paths.html#PathElement
   */
  fabric.Path.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(['d']);

  /**
   * Creates an instance of fabric.Path from an SVG <path> element
   * @static
   * @memberOf fabric.Path
   * @param {SVGElement} element to parse
   * @param {Function} callback Callback to invoke when an fabric.Path instance is created
   * @param {Object} [options] Options object
   * @param {Function} [callback] Options callback invoked after parsing is finished
   */
  fabric.Path.fromElement = function(element, callback, options) {
    var parsedAttributes = fabric.parseAttributes(element, fabric.Path.ATTRIBUTE_NAMES);
    callback(new fabric.Path(parsedAttributes.d, extend(parsedAttributes, options)));
  };
  /* _FROM_SVG_END_ */

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      min = fabric.util.array.min,
      max = fabric.util.array.max;

  if (fabric.Group) {
    return;
  }

  /**
   * Group class
   * @class fabric.Group
   * @extends fabric.Object
   * @mixes fabric.Collection
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
   * @see {@link fabric.Group#initialize} for constructor definition
   */
  fabric.Group = fabric.util.createClass(fabric.Object, fabric.Collection, /** @lends fabric.Group.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'group',

    /**
     * Width of stroke
     * @type Number
     * @default
     */
    strokeWidth: 0,

    /**
     * Indicates if click events should also check for subtargets
     * @type Boolean
     * @default
     */
    subTargetCheck: false,

    /**
     * Groups are container, do not render anything on theyr own, ence no cache properties
     * @type Array
     * @default
     */
    cacheProperties: [],

    /**
     * setOnGroup is a method used for TextBox that is no more used since 2.0.0 The behavior is still
     * available setting this boolean to true.
     * @type Boolean
     * @since 2.0.0
     * @default
     */
    useSetOnGroup: false,

    /**
     * Constructor
     * @param {Object} objects Group objects
     * @param {Object} [options] Options object
     * @param {Boolean} [isAlreadyGrouped] if true, objects have been grouped already.
     * @return {Object} thisArg
     */
    initialize: function(objects, options, isAlreadyGrouped) {
      options = options || {};
      this._objects = [];
      // if objects enclosed in a group have been grouped already,
      // we cannot change properties of objects.
      // Thus we need to set options to group without objects,
      isAlreadyGrouped && this.callSuper('initialize', options);

      this._objects = objects || [];
      for (var i = this._objects.length; i--; ) {
        this._objects[i].group = this;
      }

      if (options.originX) {
        this.originX = options.originX;
      }
      if (options.originY) {
        this.originY = options.originY;
      }

      if (!isAlreadyGrouped) {
        var center = options && options.centerPoint;
        // if coming from svg i do not want to calc bounds.
        // i assume width and height are passed along options
        center || this._calcBounds();
        this._updateObjectsCoords(center);
        delete options.centerPoint;
        this.callSuper('initialize', options);
      }

      this.setCoords();
    },

    /**
     * @private
     * @param {Boolean} [skipCoordsChange] if true, coordinates of objects enclosed in a group do not change
     */
    _updateObjectsCoords: function(center) {
      var center = center || this.getCenterPoint();
      for (var i = this._objects.length; i--; ){
        this._updateObjectCoords(this._objects[i], center);
      }
    },

    /**
     * @private
     * @param {Object} object
     * @param {fabric.Point} center, current center of group.
     */
    _updateObjectCoords: function(object, center) {
      var objectLeft = object.left,
          objectTop = object.top,
          ignoreZoom = true, skipAbsolute = true;

      object.set({
        left: objectLeft - center.x,
        top: objectTop - center.y
      });
      object.group = this;
      object.setCoords(ignoreZoom, skipAbsolute);
    },

    /**
     * Returns string represenation of a group
     * @return {String}
     */
    toString: function() {
      return '#<fabric.Group: (' + this.complexity() + ')>';
    },

    /**
     * Adds an object to a group; Then recalculates group's dimension, position.
     * @param {Object} object
     * @return {fabric.Group} thisArg
     * @chainable
     */
    addWithUpdate: function(object) {
      this._restoreObjectsState();
      fabric.util.resetObjectTransform(this);
      if (object) {
        this._objects.push(object);
        object.group = this;
        object._set('canvas', this.canvas);
      }
      this._calcBounds();
      this._updateObjectsCoords();
      this.setCoords();
      this.dirty = true;
      return this;
    },

    /**
     * Removes an object from a group; Then recalculates group's dimension, position.
     * @param {Object} object
     * @return {fabric.Group} thisArg
     * @chainable
     */
    removeWithUpdate: function(object) {
      this._restoreObjectsState();
      fabric.util.resetObjectTransform(this);

      this.remove(object);
      this._calcBounds();
      this._updateObjectsCoords();
      this.setCoords();
      this.dirty = true;
      return this;
    },

    /**
     * @private
     */
    _onObjectAdded: function(object) {
      this.dirty = true;
      object.group = this;
    },

    /**
     * @private
     */
    _onObjectRemoved: function(object) {
      this.dirty = true;
      delete object.group;
    },

    /**
     * @private
     */
    _set: function(key, value) {
      var i = this._objects.length;
      if (this.useSetOnGroup) {
        while (i--) {
          this._objects[i].setOnGroup(key, value);
        }
      }
      this.callSuper('_set', key, value);
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var objsToObject = this.getObjects().map(function(obj) {
        var originalDefaults = obj.includeDefaultValues;
        obj.includeDefaultValues = obj.group.includeDefaultValues;
        var _obj = obj.toObject(propertiesToInclude);
        obj.includeDefaultValues = originalDefaults;
        return _obj;
      });
      return extend(this.callSuper('toObject', propertiesToInclude), {
        objects: objsToObject
      });
    },

    /**
     * Returns object representation of an instance, in dataless mode.
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toDatalessObject: function(propertiesToInclude) {
      var objsToObject, sourcePath = this.sourcePath;
      if (sourcePath) {
        objsToObject = sourcePath;
      }
      else {
        objsToObject = this.getObjects().map(function(obj) {
          var originalDefaults = obj.includeDefaultValues;
          obj.includeDefaultValues = obj.group.includeDefaultValues;
          var _obj = obj.toDatalessObject(propertiesToInclude);
          obj.includeDefaultValues = originalDefaults;
          return _obj;
        });
      }
      return extend(this.callSuper('toDatalessObject', propertiesToInclude), {
        objects: objsToObject
      });
    },

    /**
     * Renders instance on a given context
     * @param {CanvasRenderingContext2D} ctx context to render instance on
     */
    render: function(ctx) {
      this._transformDone = true;
      this.callSuper('render', ctx);
      this._transformDone = false;
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * objectCaching is a global flag, wins over everything
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group outside is cached.
     * @return {Boolean}
     */
    shouldCache: function() {
      var ownCache = this.objectCaching && (!this.group || this.needsItsOwnCache() || !this.group.isOnACache());
      this.ownCaching = ownCache;
      if (ownCache) {
        for (var i = 0, len = this._objects.length; i < len; i++) {
          if (this._objects[i].willDrawShadow()) {
            this.ownCaching = false;
            return false;
          }
        }
      }
      return ownCache;
    },

    /**
     * Check if this object or a child object will cast a shadow
     * @return {Boolean}
     */
    willDrawShadow: function() {
      if (this.shadow) {
        return this.callSuper('willDrawShadow');
      }
      for (var i = 0, len = this._objects.length; i < len; i++) {
        if (this._objects[i].willDrawShadow()) {
          return true;
        }
      }
      return false;
    },

    /**
     * Check if this group or its parent group are caching, recursively up
     * @return {Boolean}
     */
    isOnACache: function() {
      return this.ownCaching || (this.group && this.group.isOnACache());
    },

    /**
     * Execute the drawing operation for an object on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    drawObject: function(ctx) {
      for (var i = 0, len = this._objects.length; i < len; i++) {
        this._objects[i].render(ctx);
      }
    },

    /**
     * Check if cache is dirty
     */
    isCacheDirty: function() {
      if (this.callSuper('isCacheDirty')) {
        return true;
      }
      if (!this.statefullCache) {
        return false;
      }
      for (var i = 0, len = this._objects.length; i < len; i++) {
        if (this._objects[i].isCacheDirty(true)) {
          if (this._cacheCanvas) {
            // if this group has not a cache canvas there is nothing to clean
            var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;
            this._cacheContext.clearRect(-x / 2, -y / 2, x, y);
          }
          return true;
        }
      }
      return false;
    },

    /**
     * Retores original state of each of group objects (original state is that which was before group was created).
     * @private
     * @return {fabric.Group} thisArg
     * @chainable
     */
    _restoreObjectsState: function() {
      this._objects.forEach(this._restoreObjectState, this);
      return this;
    },

    /**
     * Realises the transform from this group onto the supplied object
     * i.e. it tells you what would happen if the supplied object was in
     * the group, and then the group was destroyed. It mutates the supplied
     * object.
     * @param {fabric.Object} object
     * @return {fabric.Object} transformedObject
     */
    realizeTransform: function(object) {
      var matrix = object.calcTransformMatrix(),
          options = fabric.util.qrDecompose(matrix),
          center = new fabric.Point(options.translateX, options.translateY);
      object.flipX = false;
      object.flipY = false;
      object.set('scaleX', options.scaleX);
      object.set('scaleY', options.scaleY);
      object.skewX = options.skewX;
      object.skewY = options.skewY;
      object.angle = options.angle;
      object.setPositionByOrigin(center, 'center', 'center');
      return object;
    },

    /**
     * Restores original state of a specified object in group
     * @private
     * @param {fabric.Object} object
     * @return {fabric.Group} thisArg
     */
    _restoreObjectState: function(object) {
      this.realizeTransform(object);
      object.setCoords();
      delete object.group;
      return this;
    },

    /**
     * Destroys a group (restoring state of its objects)
     * @return {fabric.Group} thisArg
     * @chainable
     */
    destroy: function() {
      return this._restoreObjectsState();
    },

    /**
     * make a group an active selection, remove the group from canvas
     * the group has to be on canvas for this to work.
     * @return {fabric.ActiveSelection} thisArg
     * @chainable
     */
    toActiveSelection: function() {
      if (!this.canvas) {
        return;
      }
      var objects = this._objects, canvas = this.canvas;
      this._objects = [];
      var options = this.toObject();
      delete options.objects;
      var activeSelection = new fabric.ActiveSelection([]);
      activeSelection.set(options);
      activeSelection.type = 'activeSelection';
      canvas.remove(this);
      objects.forEach(function(object) {
        object.group = activeSelection;
        object.dirty = true;
        canvas.add(object);
      });
      activeSelection.canvas = canvas;
      activeSelection._objects = objects;
      canvas._activeObject = activeSelection;
      activeSelection.setCoords();
      return activeSelection;
    },

    /**
     * Destroys a group (restoring state of its objects)
     * @return {fabric.Group} thisArg
     * @chainable
     */
    ungroupOnCanvas: function() {
      return this._restoreObjectsState();
    },

    /**
     * Sets coordinates of all objects inside group
     * @return {fabric.Group} thisArg
     * @chainable
     */
    setObjectsCoords: function() {
      var ignoreZoom = true, skipAbsolute = true;
      this.forEachObject(function(object) {
        object.setCoords(ignoreZoom, skipAbsolute);
      });
      return this;
    },

    /**
     * @private
     */
    _calcBounds: function(onlyWidthHeight) {
      var aX = [],
          aY = [],
          o, prop,
          props = ['tr', 'br', 'bl', 'tl'],
          i = 0, iLen = this._objects.length,
          j, jLen = props.length,
          ignoreZoom = true;

      for ( ; i < iLen; ++i) {
        o = this._objects[i];
        o.setCoords(ignoreZoom);
        for (j = 0; j < jLen; j++) {
          prop = props[j];
          aX.push(o.oCoords[prop].x);
          aY.push(o.oCoords[prop].y);
        }
      }

      this.set(this._getBounds(aX, aY, onlyWidthHeight));
    },

    /**
     * @private
     */
    _getBounds: function(aX, aY, onlyWidthHeight) {
      var minXY = new fabric.Point(min(aX), min(aY)),
          maxXY = new fabric.Point(max(aX), max(aY)),
          obj = {
            width: (maxXY.x - minXY.x) || 0,
            height: (maxXY.y - minXY.y) || 0
          };

      if (!onlyWidthHeight) {
        obj.left = minXY.x || 0;
        obj.top = minXY.y || 0;
        if (this.originX === 'center') {
          obj.left += obj.width / 2;
        }
        if (this.originX === 'right') {
          obj.left += obj.width;
        }
        if (this.originY === 'center') {
          obj.top += obj.height / 2;
        }
        if (this.originY === 'bottom') {
          obj.top += obj.height;
        }
      }
      return obj;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns svg representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      var markup = this._createBaseSVGMarkup();
      markup.push(
        '<g ', this.getSvgId(), 'transform="',
        /* avoiding styles intentionally */
        this.getSvgTransform(),
        this.getSvgTransformMatrix(),
        '" style="',
        this.getSvgFilter(),
        '">\n'
      );

      for (var i = 0, len = this._objects.length; i < len; i++) {
        markup.push('\t', this._objects[i].toSVG(reviver));
      }

      markup.push('</g>\n');

      return reviver ? reviver(markup.join('')) : markup.join('');
    },
    /* _TO_SVG_END_ */
  });

  /**
   * Returns {@link fabric.Group} instance from an object representation
   * @static
   * @memberOf fabric.Group
   * @param {Object} object Object to create a group from
   * @param {Function} [callback] Callback to invoke when an group instance is created
   */
  fabric.Group.fromObject = function(object, callback) {
    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
      var options = fabric.util.object.clone(object, true);
      delete options.objects;
      callback && callback(new fabric.Group(enlivenedObjects, options, true));
    });
  };

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { });

  if (fabric.ActiveSelection) {
    return;
  }

  /**
   * Group class
   * @class fabric.ActiveSelection
   * @extends fabric.Group
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-3#groups}
   * @see {@link fabric.ActiveSelection#initialize} for constructor definition
   */
  fabric.ActiveSelection = fabric.util.createClass(fabric.Group, /** @lends fabric.ActiveSelection.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'activeSelection',

    /**
     * Constructor
     * @param {Object} objects ActiveSelection objects
     * @param {Object} [options] Options object
     * @return {Object} thisArg
     */
    initialize: function(objects, options) {
      options = options || {};
      this._objects = objects || [];
      for (var i = this._objects.length; i--; ) {
        this._objects[i].group = this;
      }

      if (options.originX) {
        this.originX = options.originX;
      }
      if (options.originY) {
        this.originY = options.originY;
      }
      this._calcBounds();
      this._updateObjectsCoords();
      fabric.Object.prototype.initialize.call(this, options);
      this.setCoords();
    },

    /**
     * Change te activeSelection to a normal group,
     * High level function that automatically adds it to canvas as
     * active object. no events fired.
     * @since 2.0.0
     * @return {fabric.Group}
     */
    toGroup: function() {
      var objects = this._objects;
      this._objects = [];
      var options = this.toObject();
      var newGroup = new fabric.Group([]);
      delete options.objects;
      newGroup.set(options);
      newGroup.type = 'group';
      objects.forEach(function(object) {
        object.group = newGroup;
        object.canvas.remove(object);
      });
      newGroup._objects = objects;
      if (!this.canvas) {
        return newGroup;
      }
      var canvas = this.canvas;
      canvas.add(newGroup);
      canvas._activeObject = newGroup;
      newGroup.setCoords();
      return newGroup;
    },

    /**
     * If returns true, deselection is cancelled.
     * @since 2.0.0
     * @return {Boolean} [cancel]
     */
    onDeselect: function() {
      this.destroy();
      return false;
    },

    /**
     * Returns string representation of a group
     * @return {String}
     */
    toString: function() {
      return '#<fabric.ActiveSelection: (' + this.complexity() + ')>';
    },

    /**
     * @private
     */
    _set: function(key, value) {
      var i = this._objects.length;
      if (key === 'canvas') {
        while (i--) {
          this._objects[i].set(key, value);
        }
      }
      if (this.useSetOnGroup) {
        while (i--) {
          this._objects[i].setOnGroup(key, value);
        }
      }
      fabric.Object.prototype._set.call(this, key, value);
    },

    /**
     * Decide if the object should cache or not. Create its own cache level
     * objectCaching is a global flag, wins over everything
     * needsItsOwnCache should be used when the object drawing method requires
     * a cache step. None of the fabric classes requires it.
     * Generally you do not cache objects in groups because the group outside is cached.
     * @return {Boolean}
     */
    shouldCache: function() {
      return false;
    },

    /**
     * Check if this object or a child object will cast a shadow
     * @return {Boolean}
     */
    willDrawShadow: function() {
      if (this.shadow) {
        return this.callSuper('willDrawShadow');
      }
      for (var i = 0, len = this._objects.length; i < len; i++) {
        if (this._objects[i].willDrawShadow()) {
          return true;
        }
      }
      return false;
    },

    /**
     * Check if this group or its parent group are caching, recursively up
     * @return {Boolean}
     */
    isOnACache: function() {
      return false;
    },

    /**
     * Renders controls and borders for the object
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} [styleOverride] properties to override the object style
     * @param {Object} [childrenOverride] properties to override the children overrides
     */
    _renderControls: function(ctx, styleOverride, childrenOverride) {
      ctx.save();
      ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
      this.callSuper('_renderControls', ctx, styleOverride);
      childrenOverride = childrenOverride || { };
      if (typeof childrenOverride.hasControls === 'undefined') {
        childrenOverride.hasControls = false;
      }
      if (typeof childrenOverride.hasRotatingPoint === 'undefined') {
        childrenOverride.hasRotatingPoint = false;
      }
      childrenOverride.forActiveSelection = true;
      for (var i = 0, len = this._objects.length; i < len; i++) {
        this._objects[i]._renderControls(ctx, childrenOverride);
      }
      ctx.restore();
    },
  });

  /**
   * Returns {@link fabric.ActiveSelection} instance from an object representation
   * @static
   * @memberOf fabric.ActiveSelection
   * @param {Object} object Object to create a group from
   * @param {Function} [callback] Callback to invoke when an ActiveSelection instance is created
   */
  fabric.ActiveSelection.fromObject = function(object, callback) {
    fabric.util.enlivenObjects(object.objects, function(enlivenedObjects) {
      delete object.objects;
      callback && callback(new fabric.ActiveSelection(enlivenedObjects, object, true));
    });
  };

})( true ? exports : this);


(function(global) {

  'use strict';

  var extend = fabric.util.object.extend;

  if (!global.fabric) {
    global.fabric = { };
  }

  if (global.fabric.Image) {
    fabric.warn('fabric.Image is already defined.');
    return;
  }

  var stateProperties = fabric.Object.prototype.stateProperties.concat();
  stateProperties.push(
    'cropX',
    'cropY'
  );

  /**
   * Image class
   * @class fabric.Image
   * @extends fabric.Object
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-1#images}
   * @see {@link fabric.Image#initialize} for constructor definition
   */
  fabric.Image = fabric.util.createClass(fabric.Object, /** @lends fabric.Image.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'image',

    /**
     * crossOrigin value (one of "", "anonymous", "use-credentials")
     * @see https://developer.mozilla.org/en-US/docs/HTML/CORS_settings_attributes
     * @type String
     * @default
     */
    crossOrigin: '',

    /**
     * Width of a stroke.
     * For image quality a stroke multiple of 2 gives better results.
     * @type Number
     * @default
     */
    strokeWidth: 0,

    /**
     * private
     * contains last value of scaleX to detect
     * if the Image got resized after the last Render
     * @type Number
     */
    _lastScaleX: 1,

    /**
     * private
     * contains last value of scaleY to detect
     * if the Image got resized after the last Render
     * @type Number
     */
    _lastScaleY: 1,

    /**
     * private
     * contains last value of scaling applied by the apply filter chain
     * @type Number
     */
    _filterScalingX: 1,

    /**
     * private
     * contains last value of scaling applied by the apply filter chain
     * @type Number
     */
    _filterScalingY: 1,

    /**
     * minimum scale factor under which any resizeFilter is triggered to resize the image
     * 0 will disable the automatic resize. 1 will trigger automatically always.
     * number bigger than 1 are not implemented yet.
     * @type Number
     */
    minimumScaleTrigger: 0.5,

    /**
     * List of properties to consider when checking if
     * state of an object is changed ({@link fabric.Object#hasStateChanged})
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties: stateProperties,

    /**
     * When `true`, object is cached on an additional canvas.
     * default to false for images
     * since 1.7.0
     * @type Boolean
     * @default
     */
    objectCaching: false,

    /**
     * key used to retrieve the texture representing this image
     * since 2.0.0
     * @type String
     * @default
     */
    cacheKey: '',

    /**
     * Image crop in pixels from original image size.
     * since 2.0.0
     * @type Number
     * @default
     */
    cropX: 0,

    /**
     * Image crop in pixels from original image size.
     * since 2.0.0
     * @type Number
     * @default
     */
    cropY: 0,

    /**
     * Constructor
     * @param {HTMLImageElement | String} element Image element
     * @param {Object} [options] Options object
     * @param {function} [callback] callback function to call after eventual filters applied.
     * @return {fabric.Image} thisArg
     */
    initialize: function(element, options) {
      options || (options = { });
      this.filters = [];
      this.callSuper('initialize', options);
      this._initElement(element, options);
      this.cacheKey = 'texture' + fabric.Object.__uid++;
    },

    /**
     * Returns image element which this instance if based on
     * @return {HTMLImageElement} Image element
     */
    getElement: function() {
      return this._element;
    },

    /**
     * Sets image element for this instance to a specified one.
     * If filters defined they are applied to new image.
     * You might need to call `canvas.renderAll` and `object.setCoords` after replacing, to render new image and update controls area.
     * @param {HTMLImageElement} element
     * @param {Object} [options] Options object
     * @return {fabric.Image} thisArg
     * @chainable
     */
    setElement: function(element, options) {
      this._element = element;
      this._originalElement = element;
      this._initConfig(options);
      if (this.resizeFilter) {
        this.applyResizeFilters();
      }
      if (this.filters.length !== 0) {
        this.applyFilters();
      }
      return this;
    },

    /**
     * Sets crossOrigin value (on an instance and corresponding image element)
     * @return {fabric.Image} thisArg
     * @chainable
     */
    setCrossOrigin: function(value) {
      this.crossOrigin = value;
      this._element.crossOrigin = value;

      return this;
    },

    /**
     * Returns original size of an image
     * @return {Object} Object with "width" and "height" properties
     */
    getOriginalSize: function() {
      var element = this.getElement();
      return {
        width: element.width,
        height: element.height
      };
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _stroke: function(ctx) {
      if (!this.stroke || this.strokeWidth === 0) {
        return;
      }
      var w = this.width / 2, h = this.height / 2;
      ctx.beginPath();
      ctx.moveTo(-w, -h);
      ctx.lineTo(w, -h);
      ctx.lineTo(w, h);
      ctx.lineTo(-w, h);
      ctx.lineTo(-w, -h);
      ctx.closePath();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderDashedStroke: function(ctx) {
      var x = -this.width / 2,
          y = -this.height / 2,
          w = this.width,
          h = this.height;

      ctx.save();
      this._setStrokeStyles(ctx, this);

      ctx.beginPath();
      fabric.util.drawDashedLine(ctx, x, y, x + w, y, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x + w, y, x + w, y + h, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x + w, y + h, x, y + h, this.strokeDashArray);
      fabric.util.drawDashedLine(ctx, x, y + h, x, y, this.strokeDashArray);
      ctx.closePath();
      ctx.restore();
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var filters = [];

      this.filters.forEach(function(filterObj) {
        if (filterObj) {
          filters.push(filterObj.toObject());
        }
      });
      var object = extend(
        this.callSuper(
          'toObject',
          ['crossOrigin', 'cropX', 'cropY'].concat(propertiesToInclude)
        ), {
          src: this.getSrc(),
          filters: filters,
        });
      if (this.resizeFilter) {
        object.resizeFilter = this.resizeFilter.toObject();
      }
      object.width /= this._filterScalingX;
      object.height /= this._filterScalingY;

      return object;
    },

    /* _TO_SVG_START_ */
    /**
     * Returns SVG representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      var markup = this._createBaseSVGMarkup(), x = -this.width / 2, y = -this.height / 2;
      markup.push(
        '<g transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '">\n',
          '\t<image ', this.getSvgId(), 'xlink:href="', this.getSvgSrc(true),
            '" x="', x, '" y="', y,
            '" style="', this.getSvgStyles(),
            // we're essentially moving origin of transformation from top/left corner to the center of the shape
            // by wrapping it in container <g> element with actual transformation, then offsetting object to the top/left
            // so that object's center aligns with container's left/top
            '" width="', this.width,
            '" height="', this.height,
          '"></image>\n'
      );

      if (this.stroke || this.strokeDashArray) {
        var origFill = this.fill;
        this.fill = null;
        markup.push(
          '<rect ',
            'x="', x, '" y="', y,
            '" width="', this.width, '" height="', this.height,
            '" style="', this.getSvgStyles(),
          '"/>\n'
        );
        this.fill = origFill;
      }

      markup.push('</g>\n');

      return reviver ? reviver(markup.join('')) : markup.join('');
    },
    /* _TO_SVG_END_ */

    /**
     * Returns source of an image
     * @param {Boolean} filtered indicates if the src is needed for svg
     * @return {String} Source of an image
     */
    getSrc: function(filtered) {
      var element = filtered ? this._element : this._originalElement;
      if (element) {
        if (element.toDataURL) {
          return element.toDataURL();
        }
        return fabric.isLikelyNode ? element._src : element.src;
      }
      else {
        return this.src || '';
      }
    },

    /**
     * Sets source of an image
     * @param {String} src Source string (URL)
     * @param {Function} [callback] Callback is invoked when image has been loaded (and all filters have been applied)
     * @param {Object} [options] Options object
     * @return {fabric.Image} thisArg
     * @chainable
     */
    setSrc: function(src, callback, options) {
      fabric.util.loadImage(src, function(img) {
        this.setElement(img, options);
        callback(this);
      }, this, options && options.crossOrigin);
      return this;
    },

    /**
     * Returns string representation of an instance
     * @return {String} String representation of an instance
     */
    toString: function() {
      return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
    },

    applyResizeFilters: function() {
      var filter = this.resizeFilter,
          retinaScaling = this.canvas ? this.canvas.getRetinaScaling() : 1,
          minimumScale = this.minimumScaleTrigger,
          scaleX = this.scaleX < minimumScale ? this.scaleX : 1,
          scaleY = this.scaleY < minimumScale ? this.scaleY : 1;
      if (scaleX * retinaScaling < 1) {
        scaleX *= retinaScaling;
      }
      if (scaleY * retinaScaling < 1) {
        scaleY *= retinaScaling;
      }
      if (!filter || (scaleX >= 1 && scaleY >= 1)) {
        this._element = this._filteredEl;
        return;
      }
      if (!fabric.filterBackend) {
        fabric.filterBackend = fabric.initFilterBackend();
      }
      var elementToFilter = this._filteredEl || this._originalElement, imageData;
      if (this._element === this._originalElement) {
        // if the element is the same we need to create a new element
        var canvasEl = fabric.util.createCanvasElement();
        canvasEl.width = elementToFilter.width;
        canvasEl.height = elementToFilter.height;
        this._element = canvasEl;
      }
      var ctx = this._element.getContext('2d');
      if (elementToFilter.getContext) {
        imageData =
          elementToFilter.getContext('2d').getImageData(0, 0, elementToFilter.width, elementToFilter.height);
      }
      else {
        ctx.drawImage(elementToFilter, 0, 0);
        imageData = ctx.getImageData(0, 0, elementToFilter.width, elementToFilter.height);
      }
      var options = {
        imageData: imageData,
        scaleX: scaleX,
        scaleY: scaleY,
      };
      filter.applyTo2d(options);
      this.width = this._element.width = options.imageData.width;
      this.height = this._element.height = options.imageData.height;
      ctx.putImageData(options.imageData, 0, 0);
    },

    /**
     * Applies filters assigned to this image (from "filters" array) or from filter param
     * @method applyFilters
     * @param {Array} filters to be applied
     * @param {Boolean} forResizing specify if the filter operation is a resize operation
     * @return {thisArg} return the fabric.Image object
     * @chainable
     */
    applyFilters: function(filters) {

      filters = filters || this.filters || [];
      filters = filters.filter(function(filter) { return filter; });
      if (filters.length === 0) {
        this._element = this._originalElement;
        this._filterScalingX = 1;
        this._filterScalingY = 1;
        return this;
      }

      var imgElement = this._originalElement,
          sourceWidth = imgElement.naturalWidth || imgElement.width,
          sourceHeight = imgElement.naturalHeight || imgElement.height;

      if (this._element === this._originalElement) {
        // if the element is the same we need to create a new element
        var canvasEl = fabric.util.createCanvasElement();
        canvasEl.width = imgElement.width;
        canvasEl.height = imgElement.height;
        this._element = canvasEl;
      }
      else {
        // clear the existing element to get new filter data
        this._element.getContext('2d').clearRect(0, 0, sourceWidth, sourceHeight);
      }
      if (!fabric.filterBackend) {
        fabric.filterBackend = fabric.initFilterBackend();
      }
      fabric.filterBackend.applyFilters(
        filters, this._originalElement, sourceWidth, sourceHeight, this._element, this.cacheKey);
      if (this.width !== this._element.width || this.height !== this._element.height) {
        this._filterScalingX = this._element.width / this.width;
        this._filterScalingY = this._element.height / this.height;
        this.width = this._element.width;
        this.height = this._element.height;
      }
      return this;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      var x = -this.width / 2, y = -this.height / 2, elementToDraw;

      if (this.isMoving === false && this.resizeFilter && this._needsResize()) {
        this._lastScaleX = this.scaleX;
        this._lastScaleY = this.scaleY;
        this.applyResizeFilters();
      }
      elementToDraw = this._element;
      elementToDraw && ctx.drawImage(elementToDraw,
                                     this.cropX, this.cropY, this.width, this.height,
                                     x, y, this.width, this.height);
      this._stroke(ctx);
      this._renderStroke(ctx);
    },

    /**
     * @private, needed to check if image needs resize
     */
    _needsResize: function() {
      return (this.scaleX !== this._lastScaleX || this.scaleY !== this._lastScaleY);
    },

    /**
     * @private
     */
    _resetWidthHeight: function() {
      var element = this.getElement();

      this.set('width', element.width);
      this.set('height', element.height);
    },

    /**
     * The Image class's initialization method. This method is automatically
     * called by the constructor.
     * @private
     * @param {HTMLImageElement|String} element The element representing the image
     * @param {Object} [options] Options object
     */
    _initElement: function(element, options) {
      this.setElement(fabric.util.getById(element), options);
      fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);
    },

    /**
     * @private
     * @param {Object} [options] Options object
     */
    _initConfig: function(options) {
      options || (options = { });
      this.setOptions(options);
      this._setWidthHeight(options);
      if (this._element && this.crossOrigin) {
        this._element.crossOrigin = this.crossOrigin;
      }
    },

    /**
     * @private
     * @param {Array} filters to be initialized
     * @param {Function} callback Callback to invoke when all fabric.Image.filters instances are created
     */
    _initFilters: function(filters, callback) {
      if (filters && filters.length) {
        fabric.util.enlivenObjects(filters, function(enlivenedObjects) {
          callback && callback(enlivenedObjects);
        }, 'fabric.Image.filters');
      }
      else {
        callback && callback();
      }
    },

    /**
     * @private
     * @param {Object} [options] Object with width/height properties
     */
    _setWidthHeight: function(options) {
      this.width = 'width' in options
        ? options.width
        : (this.getElement()
            ? this.getElement().width || 0
            : 0);

      this.height = 'height' in options
        ? options.height
        : (this.getElement()
            ? this.getElement().height || 0
            : 0);
    },

    parsePreserveAspectRatioAttribute: function() {
      if (!this.preserveAspectRatio) {
        return;
      }
      var pAR = fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio),
          width = this._element.width, height = this._element.height, scale,
          pWidth = this.width, pHeight = this.height, parsedAttributes = { width: pWidth, height: pHeight };
      if (pAR && (pAR.alignX !== 'none' || pAR.alignY !== 'none')) {
        if (pAR.meetOrSlice === 'meet') {
          this.width = width;
          this.height = height;
          this.scaleX = this.scaleY = scale = fabric.util.findScaleToFit(this._element, parsedAttributes);
          if (pAR.alignX === 'Mid') {
            this.left += (pWidth - width * scale) / 2;
          }
          if (pAR.alignX === 'Max') {
            this.left += pWidth - width * scale;
          }
          if (pAR.alignY === 'Mid') {
            this.top += (pHeight - height * scale) / 2;
          }
          if (pAR.alignY === 'Max') {
            this.top += pHeight - height * scale;
          }
        }
        if (pAR.meetOrSlice === 'slice') {
          this.scaleX = this.scaleY = scale = fabric.util.findScaleToCover(this._element, parsedAttributes);
          this.width = pWidth / scale;
          this.height = pHeight / scale;
          if (pAR.alignX === 'Mid') {
            this.cropX = (width - this.width) / 2;
          }
          if (pAR.alignX === 'Max') {
            this.cropX = width - this.width;
          }
          if (pAR.alignY === 'Mid') {
            this.cropY = (height - this.height) / 2;
          }
          if (pAR.alignY === 'Max') {
            this.cropY = height - this.height;
          }
        }
      }
      else {
        this.scaleX = pWidth / width;
        this.scaleY = pHeight / height;
      }
    }
  });

  /**
   * Default CSS class name for canvas
   * @static
   * @type String
   * @default
   */
  fabric.Image.CSS_CANVAS = 'canvas-img';

  /**
   * Alias for getSrc
   * @static
   */
  fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;

  /**
   * Creates an instance of fabric.Image from its object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} callback Callback to invoke when an image instance is created
   */
  fabric.Image.fromObject = function(object, callback) {
    fabric.util.loadImage(object.src, function(img, error) {
      if (error) {
        callback && callback(null, error);
        return;
      }
      fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {
        object.filters = filters || [];
        fabric.Image.prototype._initFilters.call(object, [object.resizeFilter], function(resizeFilters) {
          object.resizeFilter = resizeFilters[0];
          var image = new fabric.Image(img, object);
          callback(image);
        });
      });
    }, null, object.crossOrigin);
  };

  /**
   * Creates an instance of fabric.Image from an URL string
   * @static
   * @param {String} url URL to create an image from
   * @param {Function} [callback] Callback to invoke when image is created (newly created image is passed as a first argument)
   * @param {Object} [imgOptions] Options object
   */
  fabric.Image.fromURL = function(url, callback, imgOptions) {
    fabric.util.loadImage(url, function(img) {
      callback && callback(new fabric.Image(img, imgOptions));
    }, null, imgOptions && imgOptions.crossOrigin);
  };

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Image.fromElement})
   * @static
   * @see {@link http://www.w3.org/TR/SVG/struct.html#ImageElement}
   */
  fabric.Image.ATTRIBUTE_NAMES =
    fabric.SHARED_ATTRIBUTES.concat('x y width height preserveAspectRatio xlink:href crossOrigin'.split(' '));

  /**
   * Returns {@link fabric.Image} instance from an SVG element
   * @static
   * @param {SVGElement} element Element to parse
   * @param {Object} [options] Options object
   * @param {Function} callback Callback to execute when fabric.Image object is created
   * @return {fabric.Image} Instance of fabric.Image
   */
  fabric.Image.fromElement = function(element, callback, options) {
    var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES);

    fabric.Image.fromURL(parsedAttributes['xlink:href'], callback,
      extend((options ? fabric.util.object.clone(options) : { }), parsedAttributes));
  };
  /* _FROM_SVG_END_ */

})( true ? exports : this);


fabric.util.object.extend(fabric.Object.prototype, /** @lends fabric.Object.prototype */ {

  /**
   * @private
   * @return {Number} angle value
   */
  _getAngleValueForStraighten: function() {
    var angle = this.angle % 360;
    if (angle > 0) {
      return Math.round((angle - 1) / 90) * 90;
    }
    return Math.round(angle / 90) * 90;
  },

  /**
   * Straightens an object (rotating it from current angle to one of 0, 90, 180, 270, etc. depending on which is closer)
   * @return {fabric.Object} thisArg
   * @chainable
   */
  straighten: function() {
    this.rotate(this._getAngleValueForStraighten());
    return this;
  },

  /**
   * Same as {@link fabric.Object.prototype.straighten} but with animation
   * @param {Object} callbacks Object with callback functions
   * @param {Function} [callbacks.onComplete] Invoked on completion
   * @param {Function} [callbacks.onChange] Invoked on every step of animation
   * @return {fabric.Object} thisArg
   * @chainable
   */
  fxStraighten: function(callbacks) {
    callbacks = callbacks || { };

    var empty = function() { },
        onComplete = callbacks.onComplete || empty,
        onChange = callbacks.onChange || empty,
        _this = this;

    fabric.util.animate({
      startValue: this.get('angle'),
      endValue: this._getAngleValueForStraighten(),
      duration: this.FX_DURATION,
      onChange: function(value) {
        _this.rotate(value);
        onChange();
      },
      onComplete: function() {
        _this.setCoords();
        onComplete();
      },
      onStart: function() {
        _this.set('active', false);
      }
    });

    return this;
  }
});

fabric.util.object.extend(fabric.StaticCanvas.prototype, /** @lends fabric.StaticCanvas.prototype */ {

  /**
   * Straightens object, then rerenders canvas
   * @param {fabric.Object} object Object to straighten
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  straightenObject: function (object) {
    object.straighten();
    this.requestRenderAll();
    return this;
  },

  /**
   * Same as {@link fabric.Canvas.prototype.straightenObject}, but animated
   * @param {fabric.Object} object Object to straighten
   * @return {fabric.Canvas} thisArg
   * @chainable
   */
  fxStraightenObject: function (object) {
    object.fxStraighten({
      onChange: this.requestRenderAllBound
    });
    return this;
  }
});


(function() {

  'use strict';

  /**
   * Indicate whether this filtering backend is supported by the user's browser.
   * @param {Number} tileSize check if the tileSize is supported
   * @returns {Boolean} Whether the user's browser supports WebGL.
   */
  fabric.isWebglSupported = function(tileSize) {
    if (fabric.isLikelyNode) {
      return false;
    }
    tileSize = tileSize || fabric.WebglFilterBackend.prototype.tileSize;
    var canvas = document.createElement('canvas');
    var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    var isSupported = false;
    // eslint-disable-next-line
    if (gl) {
      fabric.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
      isSupported = fabric.maxTextureSize >= tileSize;
    }
    this.isSupported = isSupported;
    return isSupported;
  };

  fabric.WebglFilterBackend = WebglFilterBackend;

  /**
   * WebGL filter backend.
   */
  function WebglFilterBackend(options) {
    if (options && options.tileSize) {
      this.tileSize = options.tileSize;
    }
    this.setupGLContext(this.tileSize, this.tileSize);
    this.captureGPUInfo();
  };

  WebglFilterBackend.prototype = /** @lends fabric.WebglFilterBackend.prototype */ {

    tileSize: 2048,

    /**
     * Experimental. This object is a sort of repository of help layers used to avoid
     * of recreating them during frequent filtering. If you are previewing a filter with
     * a slider you problably do not want to create help layers every filter step.
     * in this object there will be appended some canvases, created once, resized sometimes
     * cleared never. Clearing is left to the developer.
     **/
    resources: {

    },

    /**
     * Setup a WebGL context suitable for filtering, and bind any needed event handlers.
     */
    setupGLContext: function(width, height) {
      this.dispose();
      this.createWebGLCanvas(width, height);
      // eslint-disable-next-line
      this.squareVertices = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]);
      this.chooseFastestCopyGLTo2DMethod(width, height);
    },

    /**
     * Pick a method to copy data from GL context to 2d canvas.  In some browsers using
     * putImageData is faster than drawImage for that specific operation.
     */
    chooseFastestCopyGLTo2DMethod: function(width, height) {
      var canMeasurePerf = typeof window.performance !== 'undefined';
      var canUseImageData;
      try {
        new ImageData(1, 1);
        canUseImageData = true;
      }
      catch (e) {
        canUseImageData = false;
      }
      // eslint-disable-next-line no-undef
      var canUseArrayBuffer = typeof ArrayBuffer !== 'undefined';
      // eslint-disable-next-line no-undef
      var canUseUint8Clamped = typeof Uint8ClampedArray !== 'undefined';

      if (!(canMeasurePerf && canUseImageData && canUseArrayBuffer && canUseUint8Clamped)) {
        return;
      }

      var targetCanvas = fabric.util.createCanvasElement();
      // eslint-disable-next-line no-undef
      var imageBuffer = new ArrayBuffer(width * height * 4);
      var testContext = { imageBuffer: imageBuffer };
      var startTime, drawImageTime, putImageDataTime;
      targetCanvas.width = width;
      targetCanvas.height = height;

      startTime = window.performance.now();
      copyGLTo2DDrawImage.call(testContext, this.gl, targetCanvas);
      drawImageTime = window.performance.now() - startTime;

      startTime = window.performance.now();
      copyGLTo2DPutImageData.call(testContext, this.gl, targetCanvas);
      putImageDataTime = window.performance.now() - startTime;

      if (drawImageTime > putImageDataTime) {
        this.imageBuffer = imageBuffer;
        this.copyGLTo2D = copyGLTo2DPutImageData;
      }
      else {
        this.copyGLTo2D = copyGLTo2DDrawImage;
      }
    },

    /**
     * Create a canvas element and associated WebGL context and attaches them as
     * class properties to the GLFilterBackend class.
     */
    createWebGLCanvas: function(width, height) {
      var canvas = fabric.util.createCanvasElement();
      canvas.width = width;
      canvas.height = height;
      var glOptions = { premultipliedAlpha: false },
          gl = canvas.getContext('webgl', glOptions);
      if (!gl) {
        gl = canvas.getContext('experimental-webgl', glOptions);
      }
      if (!gl) {
        return;
      }
      gl.clearColor(0, 0, 0, 0);
      // this canvas can fire webglcontextlost and webglcontextrestored
      this.canvas = canvas;
      this.gl = gl;
    },

    /**
     * Attempts to apply the requested filters to the source provided, drawing the filtered output
     * to the provided target canvas.
     *
     * @param {Array} filters The filters to apply.
     * @param {HTMLImageElement|HTMLCanvasElement} source The source to be filtered.
     * @param {Number} width The width of the source input.
     * @param {Number} height The height of the source input.
     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
     * @param {String|undefined} cacheKey A key used to cache resources related to the source. If
     * omitted, caching will be skipped.
     */
    applyFilters: function(filters, source, width, height, targetCanvas, cacheKey) {
      var gl = this.gl;
      var cachedTexture;
      if (cacheKey) {
        cachedTexture = this.getCachedTexture(cacheKey, source);
      }
      var pipelineState = {
        originalWidth: source.width || source.originalWidth,
        originalHeight: source.height || source.originalHeight,
        sourceWidth: width,
        sourceHeight: height,
        context: gl,
        sourceTexture: this.createTexture(gl, width, height, !cachedTexture && source),
        targetTexture: this.createTexture(gl, width, height),
        originalTexture: cachedTexture ||
          this.createTexture(gl, width, height, !cachedTexture && source),
        passes: filters.length,
        webgl: true,
        squareVertices: this.squareVertices,
        programCache: this.programCache,
        pass: 0,
        filterBackend: this
      };
      var tempFbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);
      filters.forEach(function(filter) { filter && filter.applyTo(pipelineState); });
      this.copyGLTo2D(gl, targetCanvas);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.deleteTexture(pipelineState.sourceTexture);
      gl.deleteTexture(pipelineState.targetTexture);
      gl.deleteFramebuffer(tempFbo);
      targetCanvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);
      return pipelineState;
    },

    /**
     * The same as the applyFilter method but with additional logging of WebGL
     * errors.
     */
    applyFiltersDebug: function(filters, source, width, height, targetCanvas, cacheKey) {
      // The following code is useful when debugging a specific issue but adds ~10x slowdown.
      var gl = this.gl;
      var ret = this.applyFilters(filters, source, width, height, targetCanvas, cacheKey);
      var glError = gl.getError();
      if (glError !== gl.NO_ERROR) {
        var errorString = this.glErrorToString(gl, glError);
        var error = new Error('WebGL Error ' + errorString);
        error.glErrorCode = glError;
        throw error;
      }
      return ret;
    },

    glErrorToString: function(context, errorCode) {
      if (!context) {
        return 'Context undefined for error code: ' + errorCode;
      }
      else if (typeof errorCode !== 'number') {
        return 'Error code is not a number';
      }
      switch (errorCode) {
        case context.NO_ERROR:
          return 'NO_ERROR';
        case context.INVALID_ENUM:
          return 'INVALID_ENUM';
        case context.INVALID_VALUE:
          return 'INVALID_VALUE';
        case context.INVALID_OPERATION:
          return 'INVALID_OPERATION';
        case context.INVALID_FRAMEBUFFER_OPERATION:
          return 'INVALID_FRAMEBUFFER_OPERATION';
        case context.OUT_OF_MEMORY:
          return 'OUT_OF_MEMORY';
        case context.CONTEXT_LOST_WEBGL:
          return 'CONTEXT_LOST_WEBGL';
        default:
          return 'UNKNOWN_ERROR';
      }
    },

    /**
     * Detach event listeners, remove references, and clean up caches.
     */
    dispose: function() {
      if (this.canvas) {
        this.canvas = null;
        this.gl = null;
      }
      this.clearWebGLCaches();
    },

    /**
     * Wipe out WebGL-related caches.
     */
    clearWebGLCaches: function() {
      this.programCache = {};
      this.textureCache = {};
    },

    /**
     * Create a WebGL texture object.
     *
     * Accepts specific dimensions to initialize the textuer to or a source image.
     *
     * @param {WebGLRenderingContext} gl The GL context to use for creating the texture.
     * @param {Number} width The width to initialize the texture at.
     * @param {Number} height The height to initialize the texture.
     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source for the texture data.
     * @returns {WebGLTexture}
     */
    createTexture: function(gl, width, height, textureImageSource) {
      var texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      if (textureImageSource) {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageSource);
      }
      else {
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      }
      return texture;
    },

    /**
     * Can be optionally used to get a texture from the cache array
     *
     * If an existing texture is not found, a new texture is created and cached.
     *
     * @param {String} uniqueId A cache key to use to find an existing texture.
     * @param {HTMLImageElement|HTMLCanvasElement} textureImageSource A source to use to create the
     * texture cache entry if one does not already exist.
     */
    getCachedTexture: function(uniqueId, textureImageSource) {
      if (this.textureCache[uniqueId]) {
        return this.textureCache[uniqueId];
      }
      else {
        var texture = this.createTexture(
          this.gl, textureImageSource.width, textureImageSource.height, textureImageSource);
        this.textureCache[uniqueId] = texture;
        return texture;
      }
    },

    /**
     * Clear out cached resources related to a source image that has been
     * filtered previously.
     *
     * @param {String} cacheKey The cache key provided when the source image was filtered.
     */
    evictCachesForKey: function(cacheKey) {
      if (this.textureCache[cacheKey]) {
        this.gl.deleteTexture(this.textureCache[cacheKey]);
        delete this.textureCache[cacheKey];
      }
    },

    copyGLTo2D: copyGLTo2DDrawImage,

    /**
     * Attempt to extract GPU information strings from a WebGL context.
     *
     * Useful information when debugging or blacklisting specific GPUs.
     *
     * @returns {Object} A GPU info object with renderer and vendor strings.
     */
    captureGPUInfo: function() {
      if (this.gpuInfo) {
        return this.gpuInfo;
      }
      var gl = this.gl;
      var ext = gl.getExtension('WEBGL_debug_renderer_info');
      var gpuInfo = { renderer: '', vendor: '' };
      if (ext) {
        var renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
        var vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);
        if (renderer) {
          gpuInfo.renderer = renderer.toLowerCase();
        }
        if (vendor) {
          gpuInfo.vendor = vendor.toLowerCase();
        }
      }
      this.gpuInfo = gpuInfo;
      return gpuInfo;
    },
  };
})();

/**
 * Copy an input WebGL canvas on to an output 2D canvas.
 *
 * The WebGL canvas is assumed to be upside down, with the top-left pixel of the
 * desired output image appearing in the bottom-left corner of the WebGL canvas.
 *
 * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.
 * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.
 */
function copyGLTo2DDrawImage(gl, targetCanvas) {
  var sourceCanvas = gl.canvas;
  var ctx = targetCanvas.getContext('2d');
  ctx.translate(0, targetCanvas.height); // move it down again
  ctx.scale(1, -1); // vertical flip
  // where is my image on the big glcanvas?
  var sourceY = sourceCanvas.height - targetCanvas.height;
  ctx.drawImage(sourceCanvas, 0, sourceY, targetCanvas.width, targetCanvas.height, 0, 0,
    targetCanvas.width, targetCanvas.height);
}

/**
 * Copy an input WebGL canvas on to an output 2D canvas using 2d canvas' putImageData
 * API. Measurably faster than using ctx.drawImage in Firefox (version 54 on OSX Sierra).
 *
 * @param {WebGLRenderingContext} sourceContext The WebGL context to copy from.
 * @param {HTMLCanvasElement} targetCanvas The 2D target canvas to copy on to.
 */
function copyGLTo2DPutImageData(gl, targetCanvas) {
  var ctx = targetCanvas.getContext('2d');
  var width = targetCanvas.width;
  var height = targetCanvas.height;
  var numBytes = width * height * 4;
  // eslint-disable-next-line no-undef
  var u8 = new Uint8Array(this.imageBuffer, 0, numBytes);
  // eslint-disable-next-line no-undef
  var u8Clamped = new Uint8ClampedArray(this.imageBuffer, 0, numBytes);
  gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, u8);
  var imgData = new ImageData(u8Clamped, width);
  ctx.putImageData(imgData, 0, 0);
}


(function() {

  'use strict';

  var noop = function() {};

  fabric.Canvas2dFilterBackend = Canvas2dFilterBackend;

  /**
   * Canvas 2D filter backend.
   */
  function Canvas2dFilterBackend() {};

  Canvas2dFilterBackend.prototype = /** @lends fabric.Canvas2dFilterBackend.prototype */ {
    evictCachesForKey: noop,
    dispose: noop,
    clearWebGLCaches: noop,

    /**
     * Experimental. This object is a sort of repository of help layers used to avoid
     * of recreating them during frequent filtering. If you are previewing a filter with
     * a slider you probably do not want to create help layers every filter step.
     * in this object there will be appended some canvases, created once, resized sometimes
     * cleared never. Clearing is left to the developer.
     **/
    resources: {

    },

    /**
     * Apply a set of filters against a source image and draw the filtered output
     * to the provided destination canvas.
     *
     * @param {EnhancedFilter} filters The filter to apply.
     * @param {HTMLImageElement|HTMLCanvasElement} sourceElement The source to be filtered.
     * @param {Number} sourceWidth The width of the source input.
     * @param {Number} sourceHeight The height of the source input.
     * @param {HTMLCanvasElement} targetCanvas The destination for filtered output to be drawn.
     */
    applyFilters: function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas) {
      var ctx = targetCanvas.getContext('2d');
      ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);
      var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
      var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
      var pipelineState = {
        sourceWidth: sourceWidth,
        sourceHeight: sourceHeight,
        imageData: imageData,
        originalEl: sourceElement,
        originalImageData: originalImageData,
        canvasEl: targetCanvas,
        ctx: ctx,
        filterBackend: this,
      };
      filters.forEach(function(filter) { filter.applyTo(pipelineState); });
      if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {
        targetCanvas.width = pipelineState.imageData.width;
        targetCanvas.height = pipelineState.imageData.height;
      }
      ctx.putImageData(pipelineState.imageData, 0, 0);
      return pipelineState;
    },

  };
})();


/**
 * @namespace fabric.Image.filters
 * @memberOf fabric.Image
 * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#image_filters}
 * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
 */
fabric.Image.filters = fabric.Image.filters || { };

/**
 * Root filter class from which all filter classes inherit from
 * @class fabric.Image.filters.BaseFilter
 * @memberOf fabric.Image.filters
 */
fabric.Image.filters.BaseFilter = fabric.util.createClass(/** @lends fabric.Image.filters.BaseFilter.prototype */ {

  /**
   * Filter type
   * @param {String} type
   * @default
   */
  type: 'BaseFilter',

  vertexSource: 'attribute vec2 aPosition;\n' +
    'attribute vec2 aTexCoord;\n' +
    'varying vec2 vTexCoord;\n' +
    'void main() {\n' +
      'vTexCoord = aTexCoord;\n' +
      'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
    '}',

  fragmentSource: 'precision highp float;\n' +
    'varying vec2 vTexCoord;\n' +
    'uniform sampler2D uTexture;\n' +
    'void main() {\n' +
      'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
    '}',

  /**
   * Constructor
   * @param {Object} [options] Options object
   */
  initialize: function(options) {
    if (options) {
      this.setOptions(options);
    }
  },

  /**
   * Sets filter's properties from options
   * @param {Object} [options] Options object
   */
  setOptions: function(options) {
    for (var prop in options) {
      this[prop] = options[prop];
    }
  },

  /**
   * Compile this filter's shader program.
   *
   * @param {WebGLRenderingContext} gl The GL canvas context to use for shader compilation.
   * @param {String} fragmentSource fragmentShader source for compilation
   * @param {String} vertexSource vertexShader source for compilation
   */
  createProgram: function(gl, fragmentSource, vertexSource) {
    if (!this.vertexSource || !this.fragmentSource) {
      return;
    }
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vertexSource || this.vertexSource);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      throw new Error(
        // eslint-disable-next-line prefer-template
        'Vertex shader compile error for "${this.type}": ' +
        gl.getShaderInfoLog(vertexShader)
      );
    }

    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fragmentSource || this.fragmentSource);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      throw new Error(
        // eslint-disable-next-line prefer-template
        'Fragment shader compile error for "${this.type}": ' +
        gl.getShaderInfoLog(fragmentShader)
      );
    }

    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      throw new Error(
        // eslint-disable-next-line prefer-template
        'Shader link error for "${this.type}" ' +
        gl.getProgramInfoLog(program)
      );
    }

    var attributeLocations = this.getAttributeLocations(gl, program);
    var uniformLocations = this.getUniformLocations(gl, program) || { };
    uniformLocations.uStepW = gl.getUniformLocation(program, 'uStepW');
    uniformLocations.uStepH = gl.getUniformLocation(program, 'uStepH');
    return {
      program: program,
      attributeLocations: attributeLocations,
      uniformLocations: uniformLocations
    };
  },

  /**
   * Return a map of attribute names to WebGLAttributeLocation objects.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {WebGLShaderProgram} program The shader program from which to take attribute locations.
   * @returns {Object} A map of attribute names to attribute locations.
   */
  getAttributeLocations: function(gl, program) {
    return {
      aPosition: gl.getAttribLocation(program, 'aPosition'),
      aTexCoord: gl.getAttribLocation(program, 'aTexCoord'),
    };
  },

  /**
   * Return a map of uniform names to WebGLUniformLocation objects.
   *
   * Intended to be overridden by subclasses.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {WebGLShaderProgram} program The shader program from which to take uniform locations.
   * @returns {Object} A map of uniform names to uniform locations.
   */
  getUniformLocations: function (/* gl, program */) {
    // Intentionally left blank, override me in subclasses.
  },

  /**
   * Send attribute data from this filter to its shader program on the GPU.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {Object} attributeLocations A map of shader attribute names to their locations.
   */
  sendAttributeData: function(gl, attributeLocations, squareVertices) {
    ['aPosition', 'aTexCoord'].forEach(function(attribute) {
      var attributeLocation = attributeLocations[attribute];
      var buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      gl.enableVertexAttribArray(attributeLocation);
      gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);
      gl.bufferData(gl.ARRAY_BUFFER, squareVertices, gl.STATIC_DRAW);
    });
  },

  _setupFrameBuffer: function(options) {
    var gl = options.context;
    if (options.passes > 1) {
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D,
        options.targetTexture, 0);
    }
    else {
      // draw last filter on canvas and not to framebuffer.
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.finish();
    }
  },

  _swapTextures: function(options) {
    options.passes--;
    options.pass++;
    var temp = options.targetTexture;
    options.targetTexture = options.sourceTexture;
    options.sourceTexture = temp;
  },

  /**
   * Intentionally left blank, to be overridden in custom filters
   * @param {Object} options
   **/
  isNeutralState: function(/* options */) {
    return false;
  },

  /**
   * Apply this filter to the input image data provided.
   *
   * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
   *
   * @param {Object} options
   * @param {Number} options.passes The number of filters remaining to be executed
   * @param {Boolean} options.webgl Whether to use webgl to render the filter.
   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
   */
  applyTo: function(options) {
    if (options.webgl) {
      if (options.passes > 1 && this.isNeutralState(options)) {
        // avoid doing something that we do not need
        return;
      }
      this._setupFrameBuffer(options);
      this.applyToWebGL(options);
      this._swapTextures(options);
    }
    else {
      this.applyTo2d(options);
    }
  },

  /**
   * Retrieves the cached shader.
   * @param {Object} options
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
   */
  retrieveShader: function(options) {
    if (!options.programCache.hasOwnProperty(this.type)) {
      options.programCache[this.type] = this.createProgram(options.context);
    }
    return options.programCache[this.type];
  },

  /**
   * Apply this filter using webgl.
   *
   * @param {Object} options
   * @param {Number} options.passes The number of filters remaining to be executed
   * @param {Boolean} options.webgl Whether to use webgl to render the filter.
   * @param {WebGLTexture} options.originalTexture The texture of the original input image.
   * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
   * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
   * @param {WebGLRenderingContext} options.context The GL context used for rendering.
   * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
   */
  applyToWebGL: function(options) {
    var gl = options.context;
    var shader = this.retrieveShader(options);
    if (options.pass === 0 && options.originalTexture) {
      gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);
    }
    else {
      gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);
    }
    gl.useProgram(shader.program);
    this.sendAttributeData(gl, shader.attributeLocations, options.squareVertices);

    gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);
    gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);

    this.sendUniformData(gl, shader.uniformLocations);
    gl.viewport(0, 0, options.sourceWidth, options.sourceHeight);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  },

  bindAdditionalTexture: function(gl, texture, textureUnit) {
    gl.activeTexture(textureUnit);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    // reset active texture to 0 as usual
    gl.activeTexture(gl.TEXTURE0);
  },

  unbindAdditionalTexture: function(gl, textureUnit) {
    gl.activeTexture(textureUnit);
    gl.bindTexture(gl.TEXTURE_2D, null);
    gl.activeTexture(gl.TEXTURE0);
  },

  getMainParameter: function() {
    return this[this.mainParameter];
  },

  setMainParameter: function(value) {
    this[this.mainParameter] = value;
  },

  /**
   * Send uniform data from this filter to its shader program on the GPU.
   *
   * Intended to be overridden by subclasses.
   *
   * @param {WebGLRenderingContext} gl The canvas context used to compile the shader program.
   * @param {Object} uniformLocations A map of shader uniform names to their locations.
   */
  sendUniformData: function(/* gl, uniformLocations */) {
    // Intentionally left blank.  Override me in subclasses.
  },

  /**
   * If needed by a 2d filter, this functions can create an helper canvas to be used
   * remember that options.targetCanvas is available for use till end of chain.
   */
  createHelpLayer: function(options) {
    if (!options.helpLayer) {
      var helpLayer = document.createElement('canvas');
      helpLayer.width = options.sourceWidth;
      helpLayer.height = options.sourceHeight;
      options.helpLayer = helpLayer;
    }
  },

  /**
   * Returns object representation of an instance
   * @return {Object} Object representation of an instance
   */
  toObject: function() {
    var object = { type: this.type }, mainP = this.mainParameter;
    if (mainP) {
      object[mainP] = this[mainP];
    }
    return object;
  },

  /**
   * Returns a JSON representation of an instance
   * @return {Object} JSON
   */
  toJSON: function() {
    // delegate, not alias
    return this.toObject();
  }
});

fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {
  var filter = new fabric.Image.filters[object.type](object);
  callback && callback(filter);
  return filter;
};


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Color Matrix filter class
   * @class fabric.Image.filters.ColorMatrix
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.ColorMatrix#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @see {@Link http://www.webwasp.co.uk/tutorials/219/Color_Matrix_Filter.php}
   * @see {@Link http://phoboslab.org/log/2013/11/fast-image-filters-with-webgl}
   * @example <caption>Kodachrome filter</caption>
   * var filter = new fabric.Image.filters.ColorMatrix({
   *  matrix: [
       1.1285582396593525, -0.3967382283601348, -0.03992559172921793, 0, 63.72958762196502,
       -0.16404339962244616, 1.0835251566291304, -0.05498805115633132, 0, 24.732407896706203,
       -0.16786010706155763, -0.5603416277695248, 1.6014850761964943, 0, 35.62982807460946,
       0, 0, 0, 1, 0
      ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.ColorMatrix = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ColorMatrix.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'ColorMatrix',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'varying vec2 vTexCoord;\n' +
      'uniform mat4 uColorMatrix;\n' +
      'uniform vec4 uConstants;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'color *= uColorMatrix;\n' +
        'color += uConstants;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Colormatrix for pixels.
     * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
     * outside the -1, 1 range.
     * 0.0039215686 is the part of 1 that get translated to 1 in 2d
     * @param {Array} matrix array of 20 numbers.
     * @default
     */
    matrix: [
      1, 0, 0, 0, 0,
      0, 1, 0, 0, 0,
      0, 0, 1, 0, 0,
      0, 0, 0, 1, 0
    ],

    mainParameter: 'matrix',

    /**
     * Lock the colormatrix on the color part, skipping alpha, manly for non webgl scenario
     * to save some calculation
     */
    colorsOnly: true,

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      // create a new array instead mutating the prototype with push
      this.matrix = this.matrix.slice(0);
    },

    /**
     * Apply the ColorMatrix operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data,
          iLen = data.length,
          m = this.matrix,
          r, g, b, a, i, colorsOnly = this.colorsOnly;

      for (i = 0; i < iLen; i += 4) {
        r = data[i];
        g = data[i + 1];
        b = data[i + 2];
        if (colorsOnly) {
          data[i] = r * m[0] + g * m[1] + b * m[2] + m[4] * 255;
          data[i + 1] = r * m[5] + g * m[6] + b * m[7] + m[9] * 255;
          data[i + 2] = r * m[10] + g * m[11] + b * m[12] + m[14] * 255;
        }
        else {
          a = data[i + 3];
          data[i] = r * m[0] + g * m[1] + b * m[2] + a * m[3] + m[4] * 255;
          data[i + 1] = r * m[5] + g * m[6] + b * m[7] + a * m[8] + m[9] * 255;
          data[i + 2] = r * m[10] + g * m[11] + b * m[12] + a * m[13] + m[14] * 255;
          data[i + 3] = r * m[15] + g * m[16] + b * m[17] + a * m[18] + m[19] * 255;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uColorMatrix: gl.getUniformLocation(program, 'uColorMatrix'),
        uConstants: gl.getUniformLocation(program, 'uConstants'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var m = this.matrix,
          matrix = [
            m[0], m[1], m[2], m[3],
            m[5], m[6], m[7], m[8],
            m[10], m[11], m[12], m[13],
            m[15], m[16], m[17], m[18]
          ],
          constants = [m[4], m[9], m[14], m[19]];
      gl.uniformMatrix4fv(uniformLocations.uColorMatrix, false, matrix);
      gl.uniform4fv(uniformLocations.uConstants, constants);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] function to invoke after filter creation
   * @return {fabric.Image.filters.ColorMatrix} Instance of fabric.Image.filters.ColorMatrix
   */
  fabric.Image.filters.ColorMatrix.fromObject = fabric.Image.filters.BaseFilter.fromObject;
})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Brightness filter class
   * @class fabric.Image.filters.Brightness
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Brightness#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Brightness({
   *   brightness: 200
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Brightness = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Brightness.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Brightness',

    /**
     * Fragment source for the brightness program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uBrightness;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'color.rgb += uBrightness;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Brightness value, from -1 to 1.
     * translated to -255 to 255 for 2d
     * 0.0039215686 is the part of 1 that get translated to 1 in 2d
     * @param {Number} brightness
     * @default
     */
    brightness: 0,

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'brightness',

   /**
    * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
    *
    * @param {Object} options
    * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
    */
    applyTo2d: function(options) {
      if (this.brightness === 0) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data, i, len = data.length,
          brightness = Math.round(this.brightness * 255);
      for (i = 0; i < len; i += 4) {
        data[i] = data[i] + brightness;
        data[i + 1] = data[i + 1] + brightness;
        data[i + 2] = data[i + 2] + brightness;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uBrightness: gl.getUniformLocation(program, 'uBrightness'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uBrightness, this.brightness);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Brightness} Instance of fabric.Image.filters.Brightness
   */
  fabric.Image.filters.Brightness.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Adapted from <a href="http://www.html5rocks.com/en/tutorials/canvas/imagefilters/">html5rocks article</a>
   * @class fabric.Image.filters.Convolute
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Convolute#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example <caption>Sharpen filter</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   matrix: [ 0, -1,  0,
   *            -1,  5, -1,
   *             0, -1,  0 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   * @example <caption>Blur filter</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   matrix: [ 1/9, 1/9, 1/9,
   *             1/9, 1/9, 1/9,
   *             1/9, 1/9, 1/9 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   * @example <caption>Emboss filter</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   matrix: [ 1,   1,  1,
   *             1, 0.7, -1,
   *            -1,  -1, -1 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   * @example <caption>Emboss filter with opaqueness</caption>
   * var filter = new fabric.Image.filters.Convolute({
   *   opaque: true,
   *   matrix: [ 1,   1,  1,
   *             1, 0.7, -1,
   *            -1,  -1, -1 ]
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.Convolute = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Convolute.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Convolute',

    /*
     * Opaque value (true/false)
     */
    opaque: false,

    /*
     * matrix for the filter, max 9x9
     */
    matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0],

    /**
     * Fragment source for the brightness program
     */
    fragmentSource: {
      Convolute_3_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[9];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 3.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 3.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_3_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[9];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 3.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 3.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
      Convolute_5_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[25];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 5.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 5.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_5_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[25];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 5.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 5.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
      Convolute_7_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[49];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 7.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 7.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_7_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[49];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 7.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 7.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
      Convolute_9_1: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[81];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 0);\n' +
          'for (float h = 0.0; h < 9.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 9.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +
              'color += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'gl_FragColor = color;\n' +
        '}',
      Convolute_9_0: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform float uMatrix[81];\n' +
        'uniform float uStepW;\n' +
        'uniform float uStepH;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = vec4(0, 0, 0, 1);\n' +
          'for (float h = 0.0; h < 9.0; h+=1.0) {\n' +
            'for (float w = 0.0; w < 9.0; w+=1.0) {\n' +
              'vec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\n' +
              'color.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n' +
            '}\n' +
          '}\n' +
          'float alpha = texture2D(uTexture, vTexCoord).a;\n' +
          'gl_FragColor = color;\n' +
          'gl_FragColor.a = alpha;\n' +
        '}',
    },

    /**
     * Constructor
     * @memberOf fabric.Image.filters.Convolute.prototype
     * @param {Object} [options] Options object
     * @param {Boolean} [options.opaque=false] Opaque value (true/false)
     * @param {Array} [options.matrix] Filter matrix
     */


    /**
    * Retrieves the cached shader.
    * @param {Object} options
    * @param {WebGLRenderingContext} options.context The GL context used for rendering.
    * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
    */
    retrieveShader: function(options) {
      var size = Math.sqrt(this.matrix.length);
      var cacheKey = this.type + '_' + size + '_' + this.opaque ? 1 : 0;
      var shaderSource = this.fragmentSource[cacheKey];
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    /**
     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data,
          weights = this.matrix,
          side = Math.round(Math.sqrt(weights.length)),
          halfSide = Math.floor(side / 2),
          sw = imageData.width,
          sh = imageData.height,
          output = options.ctx.createImageData(sw, sh),
          dst = output.data,
          // go through the destination image pixels
          alphaFac = this.opaque ? 1 : 0,
          r, g, b, a, dstOff,
          scx, scy, srcOff, wt,
          x, y, cx, cy;

      for (y = 0; y < sh; y++) {
        for (x = 0; x < sw; x++) {
          dstOff = (y * sw + x) * 4;
          // calculate the weighed sum of the source image pixels that
          // fall under the convolution matrix
          r = 0; g = 0; b = 0; a = 0;

          for (cy = 0; cy < side; cy++) {
            for (cx = 0; cx < side; cx++) {
              scy = y + cy - halfSide;
              scx = x + cx - halfSide;

              // eslint-disable-next-line max-depth
              if (scy < 0 || scy > sh || scx < 0 || scx > sw) {
                continue;
              }

              srcOff = (scy * sw + scx) * 4;
              wt = weights[cy * side + cx];

              r += data[srcOff] * wt;
              g += data[srcOff + 1] * wt;
              b += data[srcOff + 2] * wt;
              // eslint-disable-next-line max-depth
              if (!alphaFac) {
                a += data[srcOff + 3] * wt;
              }
            }
          }
          dst[dstOff] = r;
          dst[dstOff + 1] = g;
          dst[dstOff + 2] = b;
          if (!alphaFac) {
            dst[dstOff + 3] = a;
          }
          else {
            dst[dstOff + 3] = data[dstOff + 3];
          }
        }
      }
      options.imageData = output;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uMatrix: gl.getUniformLocation(program, 'uMatrix'),
        uOpaque: gl.getUniformLocation(program, 'uOpaque'),
        uHalfSize: gl.getUniformLocation(program, 'uHalfSize'),
        uSize: gl.getUniformLocation(program, 'uSize'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1fv(uniformLocations.uMatrix, this.matrix);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return extend(this.callSuper('toObject'), {
        opaque: this.opaque,
        matrix: this.matrix
      });
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Convolute} Instance of fabric.Image.filters.Convolute
   */
  fabric.Image.filters.Convolute.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Grayscale image filter class
   * @class fabric.Image.filters.Grayscale
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Grayscale();
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Grayscale = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Grayscale.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Grayscale',

    fragmentSource: {
      average: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'float average = (color.r + color.b + color.g) / 3.0;\n' +
          'gl_FragColor = vec4(average, average, average, color.a);\n' +
        '}',
      lightness: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform int uMode;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 col = texture2D(uTexture, vTexCoord);\n' +
          'float average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\n' +
          'gl_FragColor = vec4(average, average, average, col.a);\n' +
        '}',
      luminosity: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform int uMode;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 col = texture2D(uTexture, vTexCoord);\n' +
          'float average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\n' +
          'gl_FragColor = vec4(average, average, average, col.a);\n' +
        '}',
    },


    /**
     * Grayscale mode, between 'average', 'lightness', 'luminosity'
     * @param {String} type
     * @default
     */
    mode: 'average',

    mainParameter: 'mode',

    /**
     * Apply the Grayscale operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, i,
          len = data.length, value,
          mode = this.mode;
      for (i = 0; i < len; i += 4) {
        if (mode === 'average') {
          value = (data[i] + data[i + 1] + data[i + 2]) / 3;
        }
        else if (mode === 'lightness') {
          value = (Math.min(data[i], data[i + 1], data[i + 2]) +
            Math.max(data[i], data[i + 1], data[i + 2])) / 2;
        }
        else if (mode === 'luminosity') {
          value = 0.21 * data[i] + 0.72 * data[i + 1] + 0.07 * data[i + 2];
        }
        data[i] = value;
        data[i + 1] = value;
        data[i + 2] = value;
      }
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var cacheKey = this.type + '_' + this.mode;
      var shaderSource = this.fragmentSource[this.mode];
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uMode: gl.getUniformLocation(program, 'uMode'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      // default average mode.
      var mode = 1;
      gl.uniform1i(uniformLocations.uMode, mode);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Grayscale} Instance of fabric.Image.filters.Grayscale
   */
  fabric.Image.filters.Grayscale.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Invert filter class
   * @class fabric.Image.filters.Invert
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Invert();
   * object.filters.push(filter);
   * object.applyFilters(canvas.renderAll.bind(canvas));
   */
  filters.Invert = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Invert.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Invert',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform int uInvert;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'if (uInvert == 1) {\n' +
          'gl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n' +
        '} else {\n' +
          'gl_FragColor = color;\n' +
        '}\n' +
      '}',

    /**
     * Filter invert. if false, does nothing
     * @param {Boolean} invert
     * @default
     */
    invert: true,

    mainParameter: 'invert',

    /**
     * Apply the Invert operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      if (!this.invert) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data, i,
          len = data.length;
      for (i = 0; i < len; i += 4) {
        data[i] = 255 - data[i];
        data[i + 1] = 255 - data[i + 1];
        data[i + 2] = 255 - data[i + 2];
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uInvert: gl.getUniformLocation(program, 'uInvert'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1i(uniformLocations.uInvert, this.invert);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Invert} Instance of fabric.Image.filters.Invert
   */
  fabric.Image.filters.Invert.fromObject = fabric.Image.filters.BaseFilter.fromObject;


})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Noise filter class
   * @class fabric.Image.filters.Noise
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Noise#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Noise({
   *   noise: 700
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.Noise = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Noise.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Noise',

    /**
     * Fragment source for the noise program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uStepH;\n' +
      'uniform float uNoise;\n' +
      'uniform float uSeed;\n' +
      'varying vec2 vTexCoord;\n' +
      'float rand(vec2 co, float seed, float vScale) {\n' +
        'return fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n' +
      '}\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'color.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'noise',

    /**
     * Noise value, from
     * @param {Number} noise
     * @default
     */
    noise: 0,

    /**
     * Apply the Brightness operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      if (this.noise === 0) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data, i, len = data.length,
          noise = this.noise, rand;

      for (i = 0, len = data.length; i < len; i += 4) {

        rand = (0.5 - Math.random()) * noise;

        data[i] += rand;
        data[i + 1] += rand;
        data[i + 2] += rand;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uNoise: gl.getUniformLocation(program, 'uNoise'),
        uSeed: gl.getUniformLocation(program, 'uSeed'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uNoise, this.noise / 255);
      gl.uniform1f(uniformLocations.uSeed, Math.random());
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return extend(this.callSuper('toObject'), {
        noise: this.noise
      });
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Noise} Instance of fabric.Image.filters.Noise
   */
  fabric.Image.filters.Noise.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Pixelate filter class
   * @class fabric.Image.filters.Pixelate
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Pixelate#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Pixelate({
   *   blocksize: 8
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Pixelate = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Pixelate.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Pixelate',

    blocksize: 4,

    mainParameter: 'blocksize',

    /**
     * Fragment source for the Pixelate program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uBlocksize;\n' +
      'uniform float uStepW;\n' +
      'uniform float uStepH;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'float blockW = uBlocksize * uStepW;\n' +
        'float blockH = uBlocksize * uStepW;\n' +
        'int posX = int(vTexCoord.x / blockW);\n' +
        'int posY = int(vTexCoord.y / blockH);\n' +
        'float fposX = float(posX);\n' +
        'float fposY = float(posY);\n' +
        'vec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\n' +
        'vec4 color = texture2D(uTexture, squareCoords);\n' +
        'gl_FragColor = color;\n' +
      '}',

    /**
     * Apply the Pixelate operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      if (this.blocksize === 1) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data,
          iLen = imageData.height,
          jLen = imageData.width,
          index, i, j, r, g, b, a,
          _i, _j, _iLen, _jLen;

      for (i = 0; i < iLen; i += this.blocksize) {
        for (j = 0; j < jLen; j += this.blocksize) {

          index = (i * 4) * jLen + (j * 4);

          r = data[index];
          g = data[index + 1];
          b = data[index + 2];
          a = data[index + 3];

          _iLen = Math.min(i + this.blocksize, iLen);
          _jLen = Math.min(j + this.blocksize, jLen);
          for (_i = i; _i < _iLen; _i++) {
            for (_j = j; _j < _jLen; _j++) {
              index = (_i * 4) * jLen + (_j * 4);
              data[index] = r;
              data[index + 1] = g;
              data[index + 2] = b;
              data[index + 3] = a;
            }
          }
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uBlocksize: gl.getUniformLocation(program, 'uBlocksize'),
        uStepW: gl.getUniformLocation(program, 'uStepW'),
        uStepH: gl.getUniformLocation(program, 'uStepH'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Pixelate} Instance of fabric.Image.filters.Pixelate
   */
  fabric.Image.filters.Pixelate.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      extend = fabric.util.object.extend,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Remove white filter class
   * @class fabric.Image.filters.RemoveColor
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.RemoveWhite#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.RemoveColor({
   *   threshold: 40,
   *   distance: 140
   * });
   * object.filters.push(filter);
   * object.applyFilters(canvas.renderAll.bind(canvas));
   */
  filters.RemoveColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.RemoveColor.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'RemoveColor',

    color: '#FFFFFF',

    /**
     * Fragment source for the brightness program
     */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec4 uLow;\n' +
      'uniform vec4 uHigh;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
        'if(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\n' +
          'gl_FragColor.a = 0.0;\n' +
        '}\n' +
      '}',

    /**
     * distance to actual color, as value up or down from each r,g,b
     * between 0 and 1
     **/
    distance: 0.02,

    /**
     * For color to remove inside distance, use alpha channel for a smoother deletion
     * NOT IMPLEMENTED YET
     **/
    useAlpha: false,

    /**
     * Constructor
     * @memberOf fabric.Image.filters.RemoveWhite.prototype
     * @param {Object} [options] Options object
     * @param {Number} [options.color=#RRGGBB] Threshold value
     * @param {Number} [options.distance=10] Distance value
     */

    /**
     * Applies filter to canvas element
     * @param {Object} canvasEl Canvas element to apply filter to
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, i,
          distance = this.distance * 255,
          r, g, b,
          source = new fabric.Color(this.color).getSource(),
          lowC = [
            source[0] - distance,
            source[1] - distance,
            source[2] - distance,
          ],
          highC = [
            source[0] + distance,
            source[1] + distance,
            source[2] + distance,
          ];


      for (i = 0; i < data.length; i += 4) {
        r = data[i];
        g = data[i + 1];
        b = data[i + 2];

        if (r > lowC[0] &&
            g > lowC[1] &&
            b > lowC[2] &&
            r < highC[0] &&
            g < highC[1] &&
            b < highC[2]) {
          data[i + 3] = 0;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uLow: gl.getUniformLocation(program, 'uLow'),
        uHigh: gl.getUniformLocation(program, 'uHigh'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var source = new fabric.Color(this.color).getSource(),
          distance = parseFloat(this.distance),
          lowC = [
            0 + source[0] / 255 - distance,
            0 + source[1] / 255 - distance,
            0 + source[2] / 255 - distance,
            1
          ],
          highC = [
            source[0] / 255 + distance,
            source[1] / 255 + distance,
            source[2] / 255 + distance,
            1
          ];
      gl.uniform4fv(uniformLocations.uLow, lowC);
      gl.uniform4fv(uniformLocations.uHigh, highC);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return extend(this.callSuper('toObject'), {
        color: this.color,
        distance: this.distance
      });
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.RemoveColor} Instance of fabric.Image.filters.RemoveWhite
   */
  fabric.Image.filters.RemoveColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  var matrices = {
    Brownie: [
      0.59970,0.34553,-0.27082,0,0.186,
      -0.03770,0.86095,0.15059,0,-0.1449,
      0.24113,-0.07441,0.44972,0,-0.02965,
      0,0,0,1,0
    ],
    Vintage: [
      0.62793,0.32021,-0.03965,0,0.03784,
      0.02578,0.64411,0.03259,0,0.02926,
      0.04660,-0.08512,0.52416,0,0.02023,
      0,0,0,1,0
    ],
    Kodachrome: [
      1.12855,-0.39673,-0.03992,0,0.24991,
      -0.16404,1.08352,-0.05498,0,0.09698,
      -0.16786,-0.56034,1.60148,0,0.13972,
      0,0,0,1,0
    ],
    Technicolor: [
      1.91252,-0.85453,-0.09155,0,0.04624,
      -0.30878,1.76589,-0.10601,0,-0.27589,
      -0.23110,-0.75018,1.84759,0,0.12137,
      0,0,0,1,0
    ],
    Polaroid: [
      1.438,-0.062,-0.062,0,0,
      -0.122,1.378,-0.122,0,0,
      -0.016,-0.016,1.483,0,0,
      0,0,0,1,0
    ],
    Sepia: [
      0.393, 0.769, 0.189, 0, 0,
      0.349, 0.686, 0.168, 0, 0,
      0.272, 0.534, 0.131, 0, 0,
      0, 0, 0, 1, 0
    ],
    BlackWhite: [
      1.5, 1.5, 1.5, 0, -1,
      1.5, 1.5, 1.5, 0, -1,
      1.5, 1.5, 1.5, 0, -1,
      0, 0, 0, 1, 0,
    ]
  };

  for (var key in matrices) {
    filters[key] = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.Sepia.prototype */ {

      /**
       * Filter type
       * @param {String} type
       * @default
       */
      type: key,

      /**
       * Colormatrix for the effect
       * array of 20 floats. Numbers in positions 4, 9, 14, 19 loose meaning
       * outside the -1, 1 range.
       * @param {Array} matrix array of 20 numbers.
       * @default
       */
      matrix: matrices[key],

      /**
       * Lock the matrix export for this kind of static, parameter less filters.
       */
      mainParameter: false,
      /**
       * Lock the colormatrix on the color part, skipping alpha
       */
      colorsOnly: true,

    });
    fabric.Image.filters[key].fromObject = fabric.Image.filters.BaseFilter.fromObject;
  }
})( true ? exports : this);


(function(global) {
  'use strict';

  var fabric = global.fabric,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Color Blend filter class
   * @class fabric.Image.filter.BlendColor
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @example
   * var filter = new fabric.Image.filters.BlendColor({
   *  color: '#000',
   *  mode: 'multiply'
   * });
   *
   * var filter = new fabric.Image.filters.BlendImage({
   *  image: fabricImageObject,
   *  mode: 'multiply',
   *  alpha: 0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */

  filters.BlendColor = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blend.prototype */ {
    type: 'BlendColor',

    /**
     * Color to make the blend operation with. default to a reddish color since black or white
     * gives always strong result.
     **/
    color: '#F95C63',

    /**
     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
     * darken, lighten, overlay, exclusion, tint.
     **/
    mode: 'multiply',

    /**
     * alpha value. represent the strength of the blend color operation.
     **/
    alpha: 1,

    /**
     * Fragment source for the Multiply program
     */
    fragmentSource: {
      multiply: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'color.rgb *= uColor.rgb;\n' +
          'gl_FragColor = color;\n' +
        '}',
      screen: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'color.rgb = 1.0 - (1.0 - color.rgb) * (1.0 - uColor.rgb);\n' +
          'gl_FragColor = color;\n' +
        '}',
      add: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
          'gl_FragColor.rgb += uColor.rgb;\n' +
        '}',
      diff: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
          'gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n' +
      '}',
      subtract: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
          'gl_FragColor.rgb -= uColor.rgb;\n' +
        '}',
      lighten: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
          'gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n' +
        '}',
      darken: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
          'gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n' +
        '}',
      exclusion: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
          'gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n' +
        '}',
      overlay: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
          'if (uColor.r < 0.5) {\n' +
            'gl_FragColor.r *= 2.0 * uColor.r;\n' +
          '} else {\n' +
            'gl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n' +
          '}\n' +
          'if (uColor.g < 0.5) {\n' +
            'gl_FragColor.g *= 2.0 * uColor.g;\n' +
          '} else {\n' +
            'gl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n' +
          '}\n' +
          'if (uColor.b < 0.5) {\n' +
            'gl_FragColor.b *= 2.0 * uColor.b;\n' +
          '} else {\n' +
            'gl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n' +
          '}\n' +
        '}',
      tint: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'void main() {\n' +
          'gl_FragColor = texture2D(uTexture, vTexCoord);\n' +
          'gl_FragColor.rgb *= (1.0 - uColor.a);\n' +
          'gl_FragColor.rgb += uColor.rgb;\n' +
        '}'
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var cacheKey = this.type + '_' + this.mode;
      var shaderSource = this.fragmentSource[this.mode];
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    /**
     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          data = imageData.data, iLen = data.length,
          tr, tg, tb,
          r, g, b,
          source, alpha1 = 1 - this.alpha;

      source = new fabric.Color(this.color).getSource();
      tr = source[0] * this.alpha;
      tg = source[1] * this.alpha;
      tb = source[2] * this.alpha;

      for (var i = 0; i < iLen; i += 4) {

        r = data[i];
        g = data[i + 1];
        b = data[i + 2];

        switch (this.mode) {
          case 'multiply':
            data[i] = r * tr / 255;
            data[i + 1] = g * tg / 255;
            data[i + 2] = b * tb / 255;
            break;
          case 'screen':
            data[i] = 255 - (255 - r) * (255 - tr) / 255;
            data[i + 1] = 255 - (255 - g) * (255 - tg) / 255;
            data[i + 2] = 255 - (255 - b) * (255 - tb) / 255;
            break;
          case 'add':
            data[i] = r + tr;
            data[i + 1] = g + tg;
            data[i + 2] = b + tb;
            break;
          case 'diff':
          case 'difference':
            data[i] = Math.abs(r - tr);
            data[i + 1] = Math.abs(g - tg);
            data[i + 2] = Math.abs(b - tb);
            break;
          case 'subtract':
            data[i] = r - tr;
            data[i + 1] = g - tg;
            data[i + 2] = b - tb;
            break;
          case 'darken':
            data[i] = Math.min(r, tr);
            data[i + 1] = Math.min(g, tg);
            data[i + 2] = Math.min(b, tb);
            break;
          case 'lighten':
            data[i] = Math.max(r, tr);
            data[i + 1] = Math.max(g, tg);
            data[i + 2] = Math.max(b, tb);
            break;
          case 'overlay':
            data[i] = tr < 128 ? (2 * r * tr / 255) : (255 - 2 * (255 - r) * (255 - tr) / 255);
            data[i + 1] = tg < 128 ? (2 * g * tg / 255) : (255 - 2 * (255 - g) * (255 - tg) / 255);
            data[i + 2] = tb < 128 ? (2 * b * tb / 255) : (255 - 2 * (255 - b) * (255 - tb) / 255);
            break;
          case 'exclusion':
            data[i] = tr + r - ((2 * tr * r) / 255);
            data[i + 1] = tg + g - ((2 * tg * g) / 255);
            data[i + 2] = tb + b - ((2 * tb * b) / 255);
            break;
          case 'tint':
            data[i] = tr + r * alpha1;
            data[i + 1] = tg + g * alpha1;
            data[i + 2] = tb + b * alpha1;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uColor: gl.getUniformLocation(program, 'uColor'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var source = new fabric.Color(this.color).getSource();
      source[0] = this.alpha * source[0] / 255;
      source[1] = this.alpha * source[1] / 255;
      source[2] = this.alpha * source[2] / 255;
      source[3] = this.alpha;
      gl.uniform4fv(uniformLocations.uColor, source);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return {
        type: this.type,
        color: this.color,
        mode: this.mode,
        alpha: this.alpha
      };
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.BlendColor} Instance of fabric.Image.filters.BlendColor
   */
  fabric.Image.filters.BlendColor.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : this);


(function(global) {
  'use strict';

  var fabric = global.fabric,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Image Blend filter class
   * @class fabric.Image.filter.BlendImage
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @example
   * var filter = new fabric.Image.filters.BlendColor({
   *  color: '#000',
   *  mode: 'multiply'
   * });
   *
   * var filter = new fabric.Image.filters.BlendImage({
   *  image: fabricImageObject,
   *  mode: 'multiply',
   *  alpha: 0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */

  filters.BlendImage = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.BlendImage.prototype */ {
    type: 'BlendImage',

    /**
     * Color to make the blend operation with. default to a reddish color since black or white
     * gives always strong result.
     **/
    image: null,

    /**
     * Blend mode for the filter: one of multiply, add, diff, screen, subtract,
     * darken, lighten, overlay, exclusion, tint.
     **/
    mode: 'multiply',

    /**
     * alpha value. represent the strength of the blend color operation.
     **/
    alpha: 1,

    vertexSource: 'attribute vec2 aPosition;\n' +
      'attribute vec2 aTexCoord;\n' +
      'varying vec2 vTexCoord;\n' +
      'varying vec2 vTexCoord2;\n' +
      'uniform mat3 uTransformMatrix;\n' +
      'void main() {\n' +
        'vTexCoord = aTexCoord;\n' +
        'vTexCoord2 = (uTransformMatrix * vec3(aTexCoord, 1.0)).xy;\n' +
        'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
      '}',

    /**
     * Fragment source for the Multiply program
     */
    fragmentSource: {
      multiply: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform sampler2D uImage;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'varying vec2 vTexCoord2;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +
          'color.rgba *= color2.rgba;\n' +
          'gl_FragColor = color;\n' +
        '}',
      mask: 'precision highp float;\n' +
        'uniform sampler2D uTexture;\n' +
        'uniform sampler2D uImage;\n' +
        'uniform vec4 uColor;\n' +
        'varying vec2 vTexCoord;\n' +
        'varying vec2 vTexCoord2;\n' +
        'void main() {\n' +
          'vec4 color = texture2D(uTexture, vTexCoord);\n' +
          'vec4 color2 = texture2D(uImage, vTexCoord2);\n' +
          'color.a = color2.a;\n' +
          'gl_FragColor = color;\n' +
        '}',
    },

    /**
     * Retrieves the cached shader.
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    retrieveShader: function(options) {
      var cacheKey = this.type + '_' + this.mode;
      var shaderSource = this.fragmentSource[this.mode];
      if (!options.programCache.hasOwnProperty(cacheKey)) {
        options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
      }
      return options.programCache[cacheKey];
    },

    applyToWebGL: function(options) {
      // load texture to blend.
      var gl = options.context,
          texture = this.createTexture(options.filterBackend, this.image);
      this.bindAdditionalTexture(gl, texture, gl.TEXTURE1);
      this.callSuper('applyToWebGL', options);
      this.unbindAdditionalTexture(gl, gl.TEXTURE1);
    },

    createTexture: function(backend, image) {
      return backend.getCachedTexture(image.cacheKey, image._element);
    },

    /**
     * Calculate a transformMatrix to adapt the image to blend over
     * @param {Object} options
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    calculateMatrix: function() {
      var image = this.image,
          width = image._element.width,
          height = image._element.height;
      return [
        1 / image.scaleX, 0, 0,
        0, 1 / image.scaleY, 0,
        -image.left / width, -image.top / height, 1
      ];
    },

    /**
     * Apply the Blend operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          resources = options.filterBackend.resources,
          data = imageData.data, iLen = data.length,
          width = options.imageData.width,
          height = options.imageData.height,
          tr, tg, tb, ta,
          r, g, b, a,
          canvas1, context, image = this.image, blendData;

      if (!resources.blendImage) {
        resources.blendImage = document.createElement('canvas');
      }
      canvas1 = resources.blendImage;
      if (canvas1.width !== width || canvas1.height !== height) {
        canvas1.width = width;
        canvas1.height = height;
      }
      context = canvas1.getContext('2d');
      context.setTransform(image.scaleX, 0, 0, image.scaleY, image.left, image.top);
      context.drawImage(image._element, 0, 0, width, height);
      blendData = context.getImageData(0, 0, width, height).data;
      for (var i = 0; i < iLen; i += 4) {

        r = data[i];
        g = data[i + 1];
        b = data[i + 2];
        a = data[i + 3];

        tr = blendData[i];
        tg = blendData[i + 1];
        tb = blendData[i + 2];
        ta = blendData[i + 3];

        switch (this.mode) {
          case 'multiply':
            data[i] = r * tr / 255;
            data[i + 1] = g * tg / 255;
            data[i + 2] = b * tb / 255;
            data[i + 3] = a * ta / 255;
            break;
          case 'mask':
            data[i + 3] = ta;
            break;
        }
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uTransformMatrix: gl.getUniformLocation(program, 'uTransformMatrix'),
        uImage: gl.getUniformLocation(program, 'uImage'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var matrix = this.calculateMatrix();
      gl.uniform1i(uniformLocations.uImage, 1); // texture unit 1.
      gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix);
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return {
        type: this.type,
        image: this.image && this.image.toObject(),
        mode: this.mode,
        alpha: this.alpha
      };
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} callback to be invoked after filter creation
   * @return {fabric.Image.filters.BlendImage} Instance of fabric.Image.filters.BlendImage
   */
  fabric.Image.filters.BlendImage.fromObject = function(object, callback) {
    fabric.Image.fromObject(object.image, function(image) {
      var options = fabric.util.object.clone(object);
      options.image = image;
      callback(new fabric.Image.filters.BlendImage(options));
    });
  };

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }), pow = Math.pow, floor = Math.floor,
      sqrt = Math.sqrt, abs = Math.abs, round = Math.round, sin = Math.sin,
      ceil = Math.ceil,
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Resize image filter class
   * @class fabric.Image.filters.Resize
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Resize();
   * object.filters.push(filter);
   * object.applyFilters(canvas.renderAll.bind(canvas));
   */
  filters.Resize = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Resize.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Resize',

    /**
     * Resize type
     * @param {String} resizeType
     * @default
     */
    resizeType: 'hermite',

    /**
     * Scale factor for resizing, x axis
     * @param {Number} scaleX
     * @default
     */
    scaleX: 0,

    /**
     * Scale factor for resizing, y axis
     * @param {Number} scaleY
     * @default
     */
    scaleY: 0,

    /**
     * LanczosLobes parameter for lanczos filter
     * @param {Number} lanczosLobes
     * @default
     */
    lanczosLobes: 3,

    // vertexSource: 'attribute vec2 aPosition;\n' +
    //   'attribute vec2 aTexCoord;\n' +
    //   'uniform float uStepW;\n' +
    //   'uniform float uStepH;\n' +
    //   'varying vec2 centerTextureCoordinate;\n' +
    //   'varying vec2 oneStepLeftTextureCoordinate;\n' +
    //   'varying vec2 twoStepsLeftTextureCoordinate;\n' +
    //   'varying vec2 threeStepsLeftTextureCoordinate;\n' +
    //   'varying vec2 fourStepsLeftTextureCoordinate;\n' +
    //   'varying vec2 oneStepRightTextureCoordinate;\n' +
    //   'varying vec2 twoStepsRightTextureCoordinate;\n' +
    //   'varying vec2 threeStepsRightTextureCoordinate;\n' +
    //   'varying vec2 fourStepsRightTextureCoordinate;\n' +
    //   'void main() {\n' +
    //       'vec2 firstOffset = vec2(uStepW, uStepH);\n' +
    //       'vec2 secondOffset = vec2(2.0 * uStepW, 2.0 * uStepH);\n' +
    //       'vec2 thirdOffset = vec2(3.0 * uStepW, 3.0 * uStepH);\n' +
    //       'vec2 fourthOffset = vec2(4.0 * uStepW, 4.0 * uStepH);\n' +
    //       'centerTextureCoordinate = aTexCoord;\n' +
    //       'oneStepLeftTextureCoordinate = aTexCoord - firstOffset;\n' +
    //       'twoStepsLeftTextureCoordinate = aTexCoord - secondOffset;\n' +
    //       'threeStepsLeftTextureCoordinate = aTexCoord - thirdOffset;\n' +
    //       'fourStepsLeftTextureCoordinate = aTexCoord - fourthOffset;\n' +
    //       'oneStepRightTextureCoordinate = aTexCoord + firstOffset;\n' +
    //       'twoStepsRightTextureCoordinate = aTexCoord + secondOffset;\n' +
    //       'threeStepsRightTextureCoordinate = aTexCoord + thirdOffset;\n' +
    //       'fourStepsRightTextureCoordinate = aTexCoord + fourthOffset;\n' +
    //       'gl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n' +
    //   '}',
    //
    // fragmentSource: 'precision highp float;\n' +
    //   'varying vec2 centerTextureCoordinate;\n' +
    //   'varying vec2 oneStepLeftTextureCoordinate;\n' +
    //   'varying vec2 twoStepsLeftTextureCoordinate;\n' +
    //   'varying vec2 threeStepsLeftTextureCoordinate;\n' +
    //   'varying vec2 fourStepsLeftTextureCoordinate;\n' +
    //   'varying vec2 oneStepRightTextureCoordinate;\n' +
    //   'varying vec2 twoStepsRightTextureCoordinate;\n' +
    //   'varying vec2 threeStepsRightTextureCoordinate;\n' +
    //   'varying vec2 fourStepsRightTextureCoordinate;\n' +
    //   'uniform sampler2D uTexture;\n' +
    //   'void main() {\n' +
    //     'vec4 color = texture2D(uTexture, centerTextureCoordinate) * 0.38026;\n' +
    //     'color += texture2D(uTexture, oneStepLeftTextureCoordinate) * 0.27667;\n' +
    //     'color += texture2D(uTexture, oneStepRightTextureCoordinate) * 0.27667;\n' +
    //     'color += texture2D(uTexture, twoStepsLeftTextureCoordinate) * 0.08074;\n' +
    //     'color += texture2D(uTexture, twoStepsRightTextureCoordinate) * 0.08074;\n' +
    //     'color += texture2D(uTexture, threeStepsLeftTextureCoordinate) * -0.02612;\n' +
    //     'color += texture2D(uTexture, threeStepsRightTextureCoordinate) * -0.02612;\n' +
    //     'color += texture2D(uTexture, fourStepsLeftTextureCoordinate) * -0.02143;\n' +
    //     'color += texture2D(uTexture, fourStepsRightTextureCoordinate) * -0.02143;\n' +
    //     'gl_FragColor = color;\n' +
    //   '}',

    /**
     * Applies filter to canvas element
     * @memberOf fabric.Image.filters.Resize.prototype
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} scaleX
     * @param {Number} scaleY
     */
    applyTo2d: function(options) {
      var imageData = options.imageData,
          scaleX = options.scaleX || this.scaleX,
          scaleY = options.scaleY || this.scaleY;
      if (scaleX === 1 && scaleY === 1) {
        return;
      }

      this.rcpScaleX = 1 / scaleX;
      this.rcpScaleY = 1 / scaleY;

      var oW = imageData.width, oH = imageData.height,
          dW = round(oW * scaleX), dH = round(oH * scaleY),
          newData;

      if (this.resizeType === 'sliceHack') {
        newData = this.sliceByTwo(options, oW, oH, dW, dH);
      }
      else if (this.resizeType === 'hermite') {
        newData = this.hermiteFastResize(options, oW, oH, dW, dH);
      }
      else if (this.resizeType === 'bilinear') {
        newData = this.bilinearFiltering(options, oW, oH, dW, dH);
      }
      else if (this.resizeType === 'lanczos') {
        newData = this.lanczosResize(options, oW, oH, dW, dH);
      }
      options.imageData = newData;
    },

    /**
     * Filter sliceByTwo
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    sliceByTwo: function(options, oW, oH, dW, dH) {
      var imageData = options.imageData,
          mult = 0.5, doneW = false, doneH = false, stepW = oW * mult,
          stepH = oH * mult, resources = fabric.filterBackend.resources,
          tmpCanvas, ctx, sX = 0, sY = 0, dX = oW, dY = 0;
      if (!resources.sliceByTwo) {
        resources.sliceByTwo = document.createElement('canvas');
      }
      tmpCanvas = resources.sliceByTwo;
      if (tmpCanvas.width < oW * 1.5 || tmpCanvas.height < oH) {
        tmpCanvas.width = oW * 1.5;
        tmpCanvas.height = oH;
      }
      ctx = tmpCanvas.getContext('2d');
      ctx.clearRect(0, 0, oW * 1.5, oH);
      ctx.putImageData(imageData, 0, 0);

      dW = floor(dW);
      dH = floor(dH);

      while (!doneW || !doneH) {
        oW = stepW;
        oH = stepH;
        if (dW < floor(stepW * mult)) {
          stepW = floor(stepW * mult);
        }
        else {
          stepW = dW;
          doneW = true;
        }
        if (dH < floor(stepH * mult)) {
          stepH = floor(stepH * mult);
        }
        else {
          stepH = dH;
          doneH = true;
        }
        ctx.drawImage(tmpCanvas, sX, sY, oW, oH, dX, dY, stepW, stepH);
        sX = dX;
        sY = dY;
        dY += stepH;
      }
      return ctx.getImageData(sX, sY, dW, dH);
    },

    /**
     * Filter lanczosResize
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    lanczosResize: function(options, oW, oH, dW, dH) {

      function lanczosCreate(lobes) {
        return function(x) {
          if (x > lobes) {
            return 0;
          }
          x *= Math.PI;
          if (abs(x) < 1e-16) {
            return 1;
          }
          var xx = x / lobes;
          return sin(x) * sin(xx) / x / xx;
        };
      }

      function process(u) {
        var v, i, weight, idx, a, red, green,
            blue, alpha, fX, fY;
        center.x = (u + 0.5) * ratioX;
        icenter.x = floor(center.x);
        for (v = 0; v < dH; v++) {
          center.y = (v + 0.5) * ratioY;
          icenter.y = floor(center.y);
          a = 0; red = 0; green = 0; blue = 0; alpha = 0;
          for (i = icenter.x - range2X; i <= icenter.x + range2X; i++) {
            if (i < 0 || i >= oW) {
              continue;
            }
            fX = floor(1000 * abs(i - center.x));
            if (!cacheLanc[fX]) {
              cacheLanc[fX] = { };
            }
            for (var j = icenter.y - range2Y; j <= icenter.y + range2Y; j++) {
              if (j < 0 || j >= oH) {
                continue;
              }
              fY = floor(1000 * abs(j - center.y));
              if (!cacheLanc[fX][fY]) {
                cacheLanc[fX][fY] = lanczos(sqrt(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1000);
              }
              weight = cacheLanc[fX][fY];
              if (weight > 0) {
                idx = (j * oW + i) * 4;
                a += weight;
                red += weight * srcData[idx];
                green += weight * srcData[idx + 1];
                blue += weight * srcData[idx + 2];
                alpha += weight * srcData[idx + 3];
              }
            }
          }
          idx = (v * dW + u) * 4;
          destData[idx] = red / a;
          destData[idx + 1] = green / a;
          destData[idx + 2] = blue / a;
          destData[idx + 3] = alpha / a;
        }

        if (++u < dW) {
          return process(u);
        }
        else {
          return destImg;
        }
      }

      var srcData = options.imageData.data,
          destImg = options.ctx.creteImageData(dW, dH),
          destData = destImg.data,
          lanczos = lanczosCreate(this.lanczosLobes),
          ratioX = this.rcpScaleX, ratioY = this.rcpScaleY,
          rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY,
          range2X = ceil(ratioX * this.lanczosLobes / 2),
          range2Y = ceil(ratioY * this.lanczosLobes / 2),
          cacheLanc = { }, center = { }, icenter = { };

      return process(0);
    },

    /**
     * bilinearFiltering
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    bilinearFiltering: function(options, oW, oH, dW, dH) {
      var a, b, c, d, x, y, i, j, xDiff, yDiff, chnl,
          color, offset = 0, origPix, ratioX = this.rcpScaleX,
          ratioY = this.rcpScaleY,
          w4 = 4 * (oW - 1), img = options.imageData,
          pixels = img.data, destImage = options.ctx.createImageData(dW, dH),
          destPixels = destImage.data;
      for (i = 0; i < dH; i++) {
        for (j = 0; j < dW; j++) {
          x = floor(ratioX * j);
          y = floor(ratioY * i);
          xDiff = ratioX * j - x;
          yDiff = ratioY * i - y;
          origPix = 4 * (y * oW + x);

          for (chnl = 0; chnl < 4; chnl++) {
            a = pixels[origPix + chnl];
            b = pixels[origPix + 4 + chnl];
            c = pixels[origPix + w4 + chnl];
            d = pixels[origPix + w4 + 4 + chnl];
            color = a * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) +
                    c * yDiff * (1 - xDiff) + d * xDiff * yDiff;
            destPixels[offset++] = color;
          }
        }
      }
      return destImage;
    },

    /**
     * hermiteFastResize
     * @param {Object} canvasEl Canvas element to apply filter to
     * @param {Number} oW Original Width
     * @param {Number} oH Original Height
     * @param {Number} dW Destination Width
     * @param {Number} dH Destination Height
     * @returns {ImageData}
     */
    hermiteFastResize: function(options, oW, oH, dW, dH) {
      var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY,
          ratioWHalf = ceil(ratioW / 2),
          ratioHHalf = ceil(ratioH / 2),
          img = options.imageData, data = img.data,
          img2 = options.ctx.createImageData(dW, dH), data2 = img2.data;
      for (var j = 0; j < dH; j++) {
        for (var i = 0; i < dW; i++) {
          var x2 = (i + j * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0,
              gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j + 0.5) * ratioH;
          for (var yy = floor(j * ratioH); yy < (j + 1) * ratioH; yy++) {
            var dy = abs(centerY - (yy + 0.5)) / ratioHHalf,
                centerX = (i + 0.5) * ratioW, w0 = dy * dy;
            for (var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++) {
              var dx = abs(centerX - (xx + 0.5)) / ratioWHalf,
                  w = sqrt(w0 + dx * dx);
              /* eslint-disable max-depth */
              if (w > 1 && w < -1) {
                continue;
              }
              //hermite filter
              weight = 2 * w * w * w - 3 * w * w + 1;
              if (weight > 0) {
                dx = 4 * (xx + yy * oW);
                //alpha
                gxA += weight * data[dx + 3];
                weightsAlpha += weight;
                //colors
                if (data[dx + 3] < 255) {
                  weight = weight * data[dx + 3] / 250;
                }
                gxR += weight * data[dx];
                gxG += weight * data[dx + 1];
                gxB += weight * data[dx + 2];
                weights += weight;
              }
              /* eslint-enable max-depth */
            }
          }
          data2[x2] = gxR / weights;
          data2[x2 + 1] = gxG / weights;
          data2[x2 + 2] = gxB / weights;
          data2[x2 + 3] = gxA / weightsAlpha;
        }
      }
      return img2;
    },

    /**
     * Returns object representation of an instance
     * @return {Object} Object representation of an instance
     */
    toObject: function() {
      return {
        type: this.type,
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        resizeType: this.resizeType,
        lanczosLobes: this.lanczosLobes
      };
    }
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Resize} Instance of fabric.Image.filters.Resize
   */
  fabric.Image.filters.Resize.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Contrast filter class
   * @class fabric.Image.filters.Contrast
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Contrast#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Contrast({
   *   contrast: 40
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Contrast = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Contrast.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Contrast',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uContrast;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'float contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\n' +
        'color.rgb = contrastF * (color.rgb - 0.5) + 0.5;\n' +
        'gl_FragColor = color;\n' +
      '}',

    contrast: 0,

    mainParameter: 'contrast',

    /**
     * Constructor
     * @memberOf fabric.Image.filters.Contrast.prototype
     * @param {Object} [options] Options object
     * @param {Number} [options.contrast=0] Value to contrast the image up (-1...1)
     */

     /**
      * Apply the Contrast operation to a Uint8Array representing the pixels of an image.
      *
      * @param {Object} options
      * @param {ImageData} options.imageData The Uint8Array to be filtered.
      */
    applyTo2d: function(options) {
      if (this.contrast === 0) {
        return;
      }
      var imageData = options.imageData, i, len,
          data = imageData.data, len = data.length,
          contrast = Math.floor(this.contrast * 255),
          contrastF = 259 * (contrast + 255) / (255 * (259 - contrast));

      for (i = 0; i < len; i += 4) {
        data[i] = contrastF * (data[i] - 128) + 128;
        data[i + 1] = contrastF * (data[i + 1] - 128) + 128;
        data[i + 2] = contrastF * (data[i + 2] - 128) + 128;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uContrast: gl.getUniformLocation(program, 'uContrast'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uContrast, this.contrast);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Contrast} Instance of fabric.Image.filters.Contrast
   */
  fabric.Image.filters.Contrast.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Saturate filter class
   * @class fabric.Image.filters.Saturation
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Saturation#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Saturation({
   *   saturation: 100
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Saturation = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Saturation.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Saturation',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform float uSaturation;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'float rgMax = max(color.r, color.g);\n' +
        'float rgbMax = max(rgMax, color.b);\n' +
        'color.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\n' +
        'color.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\n' +
        'color.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\n' +
        'gl_FragColor = color;\n' +
      '}',

    saturation: 0,

    mainParameter: 'saturation',

    /**
     * Constructor
     * @memberOf fabric.Image.filters.Saturate.prototype
     * @param {Object} [options] Options object
     * @param {Number} [options.saturate=0] Value to saturate the image (-1...1)
     */

    /**
     * Apply the Saturation operation to a Uint8ClampedArray representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8ClampedArray to be filtered.
     */
    applyTo2d: function(options) {
      if (this.saturation === 0) {
        return;
      }
      var imageData = options.imageData,
          data = imageData.data, len = data.length,
          adjust = -this.saturation, i, max;

      for (i = 0; i < len; i += 4) {
        max = Math.max(data[i], data[i + 1], data[i + 2]);
        data[i] += max !== data[i] ? (max - data[i]) * adjust : 0;
        data[i + 1] += max !== data[i + 1] ? (max - data[i + 1]) * adjust : 0;
        data[i + 2] += max !== data[i + 2] ? (max - data[i + 2]) * adjust : 0;
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uSaturation: gl.getUniformLocation(program, 'uSaturation'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform1f(uniformLocations.uSaturation, -this.saturation);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Saturation} Instance of fabric.Image.filters.Saturate
   */
  fabric.Image.filters.Saturation.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Blur filter class
   * @class fabric.Image.filters.Blur
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Blur#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Blur({
   *   blur: 0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   * canvas.renderAll();
   */
  filters.Blur = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Blur.prototype */ {

    type: 'Blur',

/*
'gl_FragColor = vec4(0.0);',
'gl_FragColor += texture2D(texture, vTexCoord + -7 * uDelta)*0.0044299121055113265;',
'gl_FragColor += texture2D(texture, vTexCoord + -6 * uDelta)*0.00895781211794;',
'gl_FragColor += texture2D(texture, vTexCoord + -5 * uDelta)*0.0215963866053;',
'gl_FragColor += texture2D(texture, vTexCoord + -4 * uDelta)*0.0443683338718;',
'gl_FragColor += texture2D(texture, vTexCoord + -3 * uDelta)*0.0776744219933;',
'gl_FragColor += texture2D(texture, vTexCoord + -2 * uDelta)*0.115876621105;',
'gl_FragColor += texture2D(texture, vTexCoord + -1 * uDelta)*0.147308056121;',
'gl_FragColor += texture2D(texture, vTexCoord              )*0.159576912161;',
'gl_FragColor += texture2D(texture, vTexCoord + 1 * uDelta)*0.147308056121;',
'gl_FragColor += texture2D(texture, vTexCoord + 2 * uDelta)*0.115876621105;',
'gl_FragColor += texture2D(texture, vTexCoord + 3 * uDelta)*0.0776744219933;',
'gl_FragColor += texture2D(texture, vTexCoord + 4 * uDelta)*0.0443683338718;',
'gl_FragColor += texture2D(texture, vTexCoord + 5 * uDelta)*0.0215963866053;',
'gl_FragColor += texture2D(texture, vTexCoord + 6 * uDelta)*0.00895781211794;',
'gl_FragColor += texture2D(texture, vTexCoord + 7 * uDelta)*0.0044299121055113265;',
*/

    /* eslint-disable max-len */
    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec2 uDelta;\n' +
      'varying vec2 vTexCoord;\n' +
      'const float nSamples = 15.0;\n' +
      'vec3 v3offset = vec3(12.9898, 78.233, 151.7182);\n' +
      'float random(vec3 scale) {\n' +
        /* use the fragment position for a different seed per-pixel */
        'return fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n' +
      '}\n' +
      'void main() {\n' +
        'vec4 color = vec4(0.0);\n' +
        'float total = 0.0;\n' +
        'float offset = random(v3offset);\n' +
        'for (float t = -nSamples; t <= nSamples; t++) {\n' +
          'float percent = (t + offset - 0.5) / nSamples;\n' +
          'float weight = 1.0 - abs(percent);\n' +
          'color += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\n' +
          'total += weight;\n' +
        '}\n' +
        'gl_FragColor = color / total;\n' +
      '}',
    /* eslint-enable max-len */

    /**
     * blur value, in percentage of image dimensions.
     * specific to keep the image blur constant at different resolutions
     * range bewteen 0 and 1.
     */
    blur: 0,

    mainParameter: 'blur',

    applyTo: function(options) {
      if (options.webgl) {
        // this aspectRatio is used to give the same blur to vertical and horizontal
        this.aspectRatio = options.sourceWidth / options.sourceHeight;
        options.passes++;
        this._setupFrameBuffer(options);
        this.horizontal = true;
        this.applyToWebGL(options);
        this._swapTextures(options);
        this._setupFrameBuffer(options);
        this.horizontal = false;
        this.applyToWebGL(options);
        this._swapTextures(options);
      }
      else {
        this.applyTo2d(options);
      }
    },

    applyTo2d: function(options) {
      // paint canvasEl with current image data.
      //options.ctx.putImageData(options.imageData, 0, 0);
      options.imageData = this.simpleBlur(options);
    },

    simpleBlur: function(options) {
      var resources = options.filterBackend.resources, canvas1, canvas2,
          width = options.imageData.width,
          height = options.imageData.height;

      if (!resources.blurLayer1) {
        resources.blurLayer1 = document.createElement('canvas');
        resources.blurLayer2 = document.createElement('canvas');
      }
      canvas1 = resources.blurLayer1;
      canvas2 = resources.blurLayer2;
      if (canvas1.width !== width || canvas1.height !== height) {
        canvas2.width = canvas1.width = width;
        canvas2.height = canvas1.height = height;
      }
      var ctx1 = canvas1.getContext('2d'),
          ctx2 = canvas2.getContext('2d'),
          nSamples = 15,
          random, percent, j, i,
          blur = this.blur * 0.06 * 0.5;

      // load first canvas
      ctx1.putImageData(options.imageData, 0, 0);
      ctx2.clearRect(0, 0, width, height);

      for (i = -nSamples; i <= nSamples; i++) {
        random = (Math.random() - 0.5) / 4;
        percent = i / nSamples;
        j = blur * percent * width + random;
        ctx2.globalAlpha = 1 - Math.abs(percent);
        ctx2.drawImage(canvas1, j, random);
        ctx1.drawImage(canvas2, 0, 0);
        ctx2.globalAlpha = 1;
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
      }
      for (i = -nSamples; i <= nSamples; i++) {
        random = (Math.random() - 0.5) / 4;
        percent = i / nSamples;
        j = blur * percent * height + random;
        ctx2.globalAlpha = 1 - Math.abs(percent);
        ctx2.drawImage(canvas1, random, j);
        ctx1.drawImage(canvas2, 0, 0);
        ctx2.globalAlpha = 1;
        ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
      }
      options.ctx.drawImage(canvas1, 0, 0);
      var newImageData = options.ctx.getImageData(0, 0, canvas1.width, canvas1.height);
      ctx1.globalAlpha = 1;
      ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
      return newImageData;
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        delta: gl.getUniformLocation(program, 'uDelta'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      var delta = this.chooseRightDelta();
      gl.uniform2fv(uniformLocations.delta, delta);
    },

    /**
     * choose right value of image percentage to blur with
     * @returns {Array} a numeric array with delta values
     */
    chooseRightDelta: function() {
      var blurScale = 1, delta = [0, 0], blur;
      if (this.horizontal) {
        if (this.aspectRatio > 1) {
          // image is wide, i want to shrink radius horizontal
          blurScale = 1 / this.aspectRatio;
        }
      }
      else {
        if (this.aspectRatio < 1) {
          // image is tall, i want to shrink radius vertical
          blurScale = this.aspectRatio;
        }
      }
      blur = blurScale * this.blur * 0.12;
      if (this.horizontal) {
        delta[0] = blur;
      }
      else {
        delta[1] = blur;
      }
      return delta;
    },
  });

  /**
   * Deserialize a JSON definition of a BlurFilter into a concrete instance.
   */
  filters.Blur.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * Gamma filter class
   * @class fabric.Image.filters.Gamma
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.Gamma#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.Gamma({
   *   brightness: 200
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.Gamma = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Gamma.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'Gamma',

    fragmentSource: 'precision highp float;\n' +
      'uniform sampler2D uTexture;\n' +
      'uniform vec3 uGamma;\n' +
      'varying vec2 vTexCoord;\n' +
      'void main() {\n' +
        'vec4 color = texture2D(uTexture, vTexCoord);\n' +
        'vec3 correction = (1.0 / uGamma);\n' +
        'color.r = pow(color.r, correction.r);\n' +
        'color.g = pow(color.g, correction.g);\n' +
        'color.b = pow(color.b, correction.b);\n' +
        'gl_FragColor = color;\n' +
        'gl_FragColor.rgb *= color.a;\n' +
      '}',

    /**
     * Gamma array value, from 0.01 to 2.2.
     * @param {Array} gamma
     * @default
     */
    gamma: [1, 1, 1],

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'gamma',

    /**
     * Apply the Gamma operation to a Uint8Array representing the pixels of an image.
     *
     * @param {Object} options
     * @param {ImageData} options.imageData The Uint8Array to be filtered.
     */
    applyTo2d: function(options) {
      var imageData = options.imageData, data = imageData.data,
          gamma = this.gamma, len = data.length,
          rInv = 1 / gamma[0], gInv = 1 / gamma[1],
          bInv = 1 / gamma[2], i;

      if (!this.rVals) {
        // eslint-disable-next-line
        this.rVals = new Uint8Array(256);
        // eslint-disable-next-line
        this.gVals = new Uint8Array(256);
        // eslint-disable-next-line
        this.bVals = new Uint8Array(256);
      }

      // This is an optimization - pre-compute a look-up table for each color channel
      // instead of performing these pow calls for each pixel in the image.
      for (i = 0, len = 256; i < len; i++) {
        this.rVals[i] = Math.pow(i / 255, rInv) * 255;
        this.gVals[i] = Math.pow(i / 255, gInv) * 255;
        this.bVals[i] = Math.pow(i / 255, bInv) * 255;
      }
      for (i = 0, len = data.length; i < len; i += 4) {
        data[i] = this.rVals[data[i]];
        data[i + 1] = this.gVals[data[i + 1]];
        data[i + 2] = this.bVals[data[i + 2]];
      }
    },

    /**
     * Return WebGL uniform locations for this filter's shader.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {WebGLShaderProgram} program This filter's compiled shader program.
     */
    getUniformLocations: function(gl, program) {
      return {
        uGamma: gl.getUniformLocation(program, 'uGamma'),
      };
    },

    /**
     * Send data from this filter to its shader program's uniforms.
     *
     * @param {WebGLRenderingContext} gl The GL canvas context used to compile this filter's shader.
     * @param {Object} uniformLocations A map of string uniform names to WebGLUniformLocation objects
     */
    sendUniformData: function(gl, uniformLocations) {
      gl.uniform3fv(uniformLocations.uGamma, this.gamma);
    },
  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.Gamma} Instance of fabric.Image.filters.Gamma
   */
  fabric.Image.filters.Gamma.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * A container class that knows how to apply a sequence of filters to an input image.
   */
  filters.Composed = createClass(filters.BaseFilter, /** @lends fabric.Image.filters.Composed.prototype */ {

    type: 'Composed',

    /**
     * A non sparse array of filters to apply
     */
    subFilters: [],

    /**
     * Constructor
     * @param {Object} [options] Options object
     */
    initialize: function(options) {
      this.callSuper('initialize', options);
      // create a new array instead mutating the prototype with push
      this.subFilters = this.subFilters.slice(0);
    },

    /**
     * Apply this container's filters to the input image provided.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be applied.
     */
    applyTo: function(options) {
      options.passes += this.subFilters.length - 1;
      this.subFilters.forEach(function(filter) {
        filter.applyTo(options);
      });
    },

    /**
     * Serialize this filter into JSON.
     *
     * @returns {Object} A JSON representation of this filter.
     */
    toObject: function() {
      return fabric.util.object.extend(this.callSuper('toObject'), {
        subFilters: this.subFilters.map(function(filter) { return filter.toObject(); }),
      });
    },
  });

  /**
   * Deserialize a JSON definition of a ComposedFilter into a concrete instance.
   */
  fabric.Image.filters.Composed.fromObject = function(object, callback) {
    var filters = object.subFilters || [],
        subFilters = filters.map(function(filter) {
          return new fabric.Image.filters[filter.type](filter);
        }),
        instance = new fabric.Image.filters.Composed({ subFilters: subFilters });
    callback && callback(instance);
    return instance;
  };
})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric  = global.fabric || (global.fabric = { }),
      filters = fabric.Image.filters,
      createClass = fabric.util.createClass;

  /**
   * HueRotation filter class
   * @class fabric.Image.filters.HueRotation
   * @memberOf fabric.Image.filters
   * @extends fabric.Image.filters.BaseFilter
   * @see {@link fabric.Image.filters.HueRotation#initialize} for constructor definition
   * @see {@link http://fabricjs.com/image-filters|ImageFilters demo}
   * @example
   * var filter = new fabric.Image.filters.HueRotation({
   *   rotation: -0.5
   * });
   * object.filters.push(filter);
   * object.applyFilters();
   */
  filters.HueRotation = createClass(filters.ColorMatrix, /** @lends fabric.Image.filters.HueRotation.prototype */ {

    /**
     * Filter type
     * @param {String} type
     * @default
     */
    type: 'HueRotation',

    /**
     * HueRotation value, from -1 to 1.
     * the unit is radians
     * @param {Number} myParameter
     * @default
     */
    rotation: 0,

    /**
     * Describe the property that is the filter parameter
     * @param {String} m
     * @default
     */
    mainParameter: 'rotation',

    calculateMatrix: function() {
      var rad = this.rotation * Math.PI, cos = Math.cos(rad), sin = Math.sin(rad),
          aThird = 1 / 3, aThirdSqtSin = Math.sqrt(aThird) * sin, OneMinusCos = 1 - cos;
      this.matrix = [
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        0, 0, 0, 1, 0
      ];
      this.matrix[0] = cos + OneMinusCos / 3;
      this.matrix[1] = aThird * OneMinusCos - aThirdSqtSin;
      this.matrix[2] = aThird * OneMinusCos + aThirdSqtSin;
      this.matrix[5] = aThird * OneMinusCos + aThirdSqtSin;
      this.matrix[6] = cos + aThird * OneMinusCos;
      this.matrix[7] = aThird * OneMinusCos - aThirdSqtSin;
      this.matrix[10] = aThird * OneMinusCos - aThirdSqtSin;
      this.matrix[11] = aThird * OneMinusCos + aThirdSqtSin;
      this.matrix[12] = cos + aThird * OneMinusCos;
    },

    /**
     * Apply this filter to the input image data provided.
     *
     * Determines whether to use WebGL or Canvas2D based on the options.webgl flag.
     *
     * @param {Object} options
     * @param {Number} options.passes The number of filters remaining to be executed
     * @param {Boolean} options.webgl Whether to use webgl to render the filter.
     * @param {WebGLTexture} options.sourceTexture The texture setup as the source to be filtered.
     * @param {WebGLTexture} options.targetTexture The texture where filtered output should be drawn.
     * @param {WebGLRenderingContext} options.context The GL context used for rendering.
     * @param {Object} options.programCache A map of compiled shader programs, keyed by filter type.
     */
    applyTo: function(options) {
      this.calculateMatrix();
      fabric.Image.filters.BaseFilter.prototype.applyTo.call(this, options);
    },

  });

  /**
   * Returns filter instance from an object representation
   * @static
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] to be invoked after filter creation
   * @return {fabric.Image.filters.HueRotation} Instance of fabric.Image.filters.HueRotation
   */
  fabric.Image.filters.HueRotation.fromObject = fabric.Image.filters.BaseFilter.fromObject;

})( true ? exports : this);


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = { }),
      clone = fabric.util.object.clone,
      MIN_TEXT_WIDTH = 2,
      CACHE_FONT_SIZE = 200;

  if (fabric.Text) {
    fabric.warn('fabric.Text is already defined');
    return;
  }

  var stateProperties = fabric.Object.prototype.stateProperties.concat();
  stateProperties.push(
    'fontFamily',
    'fontWeight',
    'fontSize',
    'text',
    'underline',
    'overline',
    'linethrough',
    'textAlign',
    'fontStyle',
    'lineHeight',
    'textBackgroundColor',
    'charSpacing',
    'styles'
  );

  var cacheProperties = fabric.Object.prototype.cacheProperties.concat();
  cacheProperties.push(
    'fontFamily',
    'fontWeight',
    'fontSize',
    'text',
    'underline',
    'overline',
    'linethrough',
    'textAlign',
    'fontStyle',
    'lineHeight',
    'textBackgroundColor',
    'charSpacing',
    'styles'
  );
  /**
   * Text class
   * @class fabric.Text
   * @extends fabric.Object
   * @return {fabric.Text} thisArg
   * @tutorial {@link http://fabricjs.com/fabric-intro-part-2#text}
   * @see {@link fabric.Text#initialize} for constructor definition
   */
  fabric.Text = fabric.util.createClass(fabric.Object, /** @lends fabric.Text.prototype */ {

    /**
     * Properties which when set cause object to change dimensions
     * @type Object
     * @private
     */
    _dimensionAffectingProps: [
      'fontSize',
      'fontWeight',
      'fontFamily',
      'fontStyle',
      'lineHeight',
      'text',
      'charSpacing',
      'textAlign',
      'styles',
    ],

    /**
     * @private
     */
    _reNewline: /\r?\n/,

    /**
     * Use this regular expression to filter for whitespaces that is not a new line.
     * Mostly used when text is 'justify' aligned.
     * @private
     */
    _reSpacesAndTabs: /[ \t\r]/g,

    /**
     * Use this regular expression to filter for whitespace that is not a new line.
     * Mostly used when text is 'justify' aligned.
     * @private
     */
    _reSpaceAndTab: /[ \t\r]/,

    /**
     * Use this regular expression to filter consecutive groups of non spaces.
     * Mostly used when text is 'justify' aligned.
     * @private
     */
    _reWords: /\S+/g,

    /**
     * Type of an object
     * @type String
     * @default
     */
    type:                 'text',

    /**
     * Font size (in pixels)
     * @type Number
     * @default
     */
    fontSize:             40,

    /**
     * Font weight (e.g. bold, normal, 400, 600, 800)
     * @type {(Number|String)}
     * @default
     */
    fontWeight:           'normal',

    /**
     * Font family
     * @type String
     * @default
     */
    fontFamily:           'Times New Roman',

    /**
     * Text decoration underline.
     * @type String
     * @default
     */
    underline:       false,

    /**
     * Text decoration overline.
     * @type String
     * @default
     */
    overline:       false,

    /**
     * Text decoration linethrough.
     * @type String
     * @default
     */
    linethrough:       false,

    /**
     * Text alignment. Possible values: "left", "center", "right" or "justify".
     * @type String
     * @default
     */
    textAlign:            'left',

    /**
     * Font style . Possible values: "", "normal", "italic" or "oblique".
     * @type String
     * @default
     */
    fontStyle:            'normal',

    /**
     * Line height
     * @type Number
     * @default
     */
    lineHeight:           1.16,

    /**
     * Background color of text lines
     * @type String
     * @default
     */
    textBackgroundColor:  '',

    /**
     * List of properties to consider when checking if
     * state of an object is changed ({@link fabric.Object#hasStateChanged})
     * as well as for history (undo/redo) purposes
     * @type Array
     */
    stateProperties:      stateProperties,

    /**
     * List of properties to consider when checking if cache needs refresh
     * @type Array
     */
    cacheProperties:      cacheProperties,

    /**
     * When defined, an object is rendered via stroke and this property specifies its color.
     * <b>Backwards incompatibility note:</b> This property was named "strokeStyle" until v1.1.6
     * @type String
     * @default
     */
    stroke:               null,

    /**
     * Shadow object representing shadow of this shape.
     * <b>Backwards incompatibility note:</b> This property was named "textShadow" (String) until v1.2.11
     * @type fabric.Shadow
     * @default
     */
    shadow:               null,

    /**
     * @private
     */
    _fontSizeFraction: 0.222,

    /**
     * @private
     */
    offsets: {
      underline: 0.10,
      linethrough: -0.315,
      overline: -0.88
    },

    /**
     * Text Line proportion to font Size (in pixels)
     * @type Number
     * @default
     */
    _fontSizeMult:             1.13,

    /**
     * additional space between characters
     * expressed in thousands of em unit
     * @type Number
     * @default
     */
    charSpacing:             0,

    /**
     * Object containing character styles
     * (where top-level properties corresponds to line number and 2nd-level properties -- to char number in a line)
     * @type Object
     * @default
     */
    styles: null,

    /**
     * Reference to a context to measure text char or couple of chars
     * the cacheContext of the canvas will be used or a freshly created one if the object is not on canvas
     * once created it will be referenced on fabric._measuringContext to avoide creating a canvas for every
     * text object created.
     * @type {CanvasRenderingContext2D}
     * @default
     */
    _measuringContext: null,

    /**
     * Array of properties that define a style unit.
     * @type {Array}
     * @default
     */
    _styleProperties: [
      'stroke',
      'strokeWidth',
      'fill',
      'fontFamily',
      'fontSize',
      'fontWeight',
      'fontStyle',
      'underline',
      'overline',
      'linethrough',
      'textBackgroundColor',
    ],

    /**
     * contains characters bounding boxes
     */
    __charBounds: [],

    /**
     * Constructor
     * @param {String} text Text string
     * @param {Object} [options] Options object
     * @return {fabric.Text} thisArg
     */
    initialize: function(text, options) {
      this.styles = options ? (options.styles || { }) : { };
      this.text = text;
      this.__skipDimension = true;
      this.callSuper('initialize', options);
      this.__skipDimension = false;
      this.initDimensions();
      this.setCoords();
      this.setupState({ propertySet: '_dimensionAffectingProps' });
    },

    /**
     * Return a contex for measurement of text string.
     * if created it gets stored for reuse
     * @param {String} text Text string
     * @param {Object} [options] Options object
     * @return {fabric.Text} thisArg
     */
    getMeasuringContext: function() {
      // if we did not return we have to measure something.
      if (!fabric._measuringContext) {
        fabric._measuringContext = this.canvas && this.canvas.contextCache ||
          fabric.util.createCanvasElement().getContext('2d');
      }
      return fabric._measuringContext;
    },

    /**
     * Returns true if object has no styling or no styling in a line
     * @param {Number} lineIndex
     * @return {Boolean}
     */
    isEmptyStyles: function(lineIndex) {
      if (!this.styles) {
        return true;
      }
      if (typeof lineIndex !== 'undefined' && !this.styles[lineIndex]) {
        return true;
      }
      var obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
      for (var p1 in obj) {
        for (var p2 in obj[p1]) {
          // eslint-disable-next-line no-unused-vars
          for (var p3 in obj[p1][p2]) {
            return false;
          }
        }
      }
      return true;
    },

    /**
     * Returns true if object has a style property or has it ina specified line
     * @param {Number} lineIndex
     * @return {Boolean}
     */
    styleHas: function(property, lineIndex) {
      if (!this.styles || !property || property === '') {
        return false;
      }
      if (typeof lineIndex !== 'undefined' && !this.styles[lineIndex]) {
        return false;
      }
      var obj = typeof lineIndex === 'undefined' ? this.styles : { line: this.styles[lineIndex] };
      // eslint-disable-next-line
      for (var p1 in obj) {
        // eslint-disable-next-line
        for (var p2 in obj[p1]) {
          if (typeof obj[p1][p2][property] !== 'undefined') {
            return true;
          }
        }
      }
      return false;
    },

    /**
     * Check if characters in a text have a value for a property
     * whose value matches the textbox's value for that property.  If so,
     * the character-level property is deleted.  If the character
     * has no other properties, then it is also deleted.  Finally,
     * if the line containing that character has no other characters
     * then it also is deleted.
     *
     * @param {string} property The property to compare between characters and text.
     */
    cleanStyle: function(property) {
      if (!this.styles || !property || property === '') {
        return false;
      }
      var obj = this.styles, stylesCount = 0, letterCount, foundStyle = false, style,
          canBeSwapped = true, graphemeCount = 0;
      // eslint-disable-next-line
      for (var p1 in obj) {
        letterCount = 0;
        // eslint-disable-next-line
        for (var p2 in obj[p1]) {
          stylesCount++;
          if (!foundStyle) {
            style = obj[p1][p2][property];
            foundStyle = true;
          }
          else if (obj[p1][p2][property] !== style) {
            canBeSwapped = false;
          }
          if (obj[p1][p2][property] === this[property]) {
            delete obj[p1][p2][property];
          }
          if (Object.keys(obj[p1][p2]).length !== 0) {
            letterCount++;
          }
          else {
            delete obj[p1][p2];
          }
        }
        if (letterCount === 0) {
          delete obj[p1];
        }
      }
      // if every grapheme has the same style set then
      // delete those styles and set it on the parent
      for (var i = 0; i < this._textLines.length; i++) {
        graphemeCount += this._textLines[i].length;
      }
      if (canBeSwapped && stylesCount === graphemeCount) {
        this[property] = style;
        this.removeStyle(property);
      }
    },

    /**
     * Remove a style property or properties from all individual character styles
     * in a text object.  Deletes the character style object if it contains no other style
     * props.  Deletes a line style object if it contains no other character styles.
     *
     * @param {String} props The property to remove from character styles.
     */
    removeStyle: function(property) {
      if (!this.styles || !property || property === '') {
        return;
      }
      var obj = this.styles, line, lineNum, charNum;
      for (lineNum in obj) {
        line = obj[lineNum];
        for (charNum in line) {
          delete line[charNum][property];
          if (Object.keys(line[charNum]).length === 0) {
            delete line[charNum];
          }
        }
        if (Object.keys(line).length === 0) {
          delete obj[lineNum];
        }
      }
    },

    /**
     * @private
     */
    _extendStyles: function(index, styles) {
      var loc = this.get2DCursorLocation(index);

      if (!this._getLineStyle(loc.lineIndex)) {
        this._setLineStyle(loc.lineIndex, {});
      }

      if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {
        this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});
      }

      fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);
    },

    /**
     * Initialize or update text dimensions.
     * Updates this.width and this.height with the proper values.
     * Does not return dimensions.
     */
    initDimensions: function() {
      if (this.__skipDimension) {
        return;
      }
      var newLines = this._splitTextIntoLines(this.text);
      this.textLines = newLines.lines;
      this._unwrappedTextLines = newLines._unwrappedLines;
      this._textLines = newLines.graphemeLines;
      this._text = newLines.graphemeText;
      this._clearCache();
      this.width = this.calcTextWidth() || this.cursorWidth || MIN_TEXT_WIDTH;
      if (this.textAlign === 'justify') {
        // once text is misured we need to make space fatter to make justified text.
        this.enlargeSpaces();
      }
      this.height = this.calcTextHeight();
    },

    /**
     * Enlarge space boxes and shift the others
     */
    enlargeSpaces: function() {
      var diffSpace, currentLineWidth, numberOfSpaces, accumulatedSpace, line, charBound, spaces;
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        accumulatedSpace = 0;
        line = this._textLines[i];
        currentLineWidth = this.getLineWidth(i);
        if (currentLineWidth < this.width && (spaces = this.textLines[i].match(this._reSpacesAndTabs))) {
          numberOfSpaces = spaces.length;
          diffSpace = (this.width - currentLineWidth) / numberOfSpaces;
          for (var j = 0, jlen = line.length; j <= jlen; j++) {
            charBound = this.__charBounds[i][j];
            if (this._reSpaceAndTab.test(line[j])) {
              charBound.width += diffSpace;
              charBound.kernedWidth += diffSpace;
              charBound.left += accumulatedSpace;
              accumulatedSpace += diffSpace;
            }
            else {
              charBound.left += accumulatedSpace;
            }
          }
        }
      }
    },

    /**
     * Returns string representation of an instance
     * @return {String} String representation of text object
     */
    toString: function() {
      return '#<fabric.Text (' + this.complexity() +
        '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>';
    },

    /**
     * Return the dimension and the zoom level needed to create a cache canvas
     * big enough to host the object to be cached.
     * @private
     * @return {Object}.width width of canvas
     * @return {Object}.height height of canvas
     * @return {Object}.zoomX zoomX zoom value to unscale the canvas before drawing cache
     * @return {Object}.zoomY zoomY zoom value to unscale the canvas before drawing cache
     */
    _getCacheCanvasDimensions: function() {
      var dim = this.callSuper('_getCacheCanvasDimensions');
      var fontSize = this.fontSize;
      dim.width += fontSize * dim.zoomX;
      dim.height += fontSize * dim.zoomY;
      return dim;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      this._setTextStyles(ctx);
      this._renderTextLinesBackground(ctx);
      this._renderTextDecoration(ctx, 'underline');
      this._renderText(ctx);
      this._renderTextDecoration(ctx, 'overline');
      this._renderTextDecoration(ctx, 'linethrough');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderText: function(ctx) {
      this._renderTextFill(ctx);
      this._renderTextStroke(ctx);
    },

    /**
     * Set the font parameter of the context with the object properties or with charStyle
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Object} [charStyle] object with font style properties
     * @param {String} [charStyle.fontFamily] Font Family
     * @param {Number} [charStyle.fontSize] Font size in pixels. ( without px suffix )
     * @param {String} [charStyle.fontWeight] Font weight
     * @param {String} [charStyle.fontStyle] Font style (italic|normal)
     */
    _setTextStyles: function(ctx, charStyle, forMeasuring) {
      ctx.textBaseline = 'alphabetic';
      ctx.font = this._getFontDeclaration(charStyle, forMeasuring);
    },

    /**
     * calculate and return the text Width measuring each line.
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @return {Number} Maximum width of fabric.Text object
     */
    calcTextWidth: function() {
      var maxWidth = this.getLineWidth(0);

      for (var i = 1, len = this._textLines.length; i < len; i++) {
        var currentLineWidth = this.getLineWidth(i);
        if (currentLineWidth > maxWidth) {
          maxWidth = currentLineWidth;
        }
      }
      return maxWidth;
    },

    /**
     * @private
     * @param {String} method Method name ("fillText" or "strokeText")
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {String} line Text to render
     * @param {Number} left Left position of text
     * @param {Number} top Top position of text
     * @param {Number} lineIndex Index of a line in a text
     */
    _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
      this._renderChars(method, ctx, line, left, top, lineIndex);
    },

    /**
     * Renders the text background for lines, taking care of style
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextLinesBackground: function(ctx) {
      if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor')) {
        return;
      }
      var lineTopOffset = 0, heightOfLine,
          lineLeftOffset, originalFill = ctx.fillStyle,
          line, lastColor,
          leftOffset = this._getLeftOffset(),
          topOffset = this._getTopOffset(),
          boxStart = 0, boxWidth = 0, charBox, currentColor;

      for (var i = 0, len = this._textLines.length; i < len; i++) {
        heightOfLine = this.getHeightOfLine(i);
        if (!this.textBackgroundColor && !this.styleHas('textBackgroundColor', i)) {
          lineTopOffset += heightOfLine;
          continue;
        }
        line = this._textLines[i];
        lineLeftOffset = this._getLineLeftOffset(i);
        boxWidth = 0;
        boxStart = 0;
        lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
        for (var j = 0, jlen = line.length; j < jlen; j++) {
          charBox = this.__charBounds[i][j];
          currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
          if (currentColor !== lastColor) {
            ctx.fillStyle = lastColor;
            lastColor && ctx.fillRect(
              leftOffset + lineLeftOffset + boxStart,
              topOffset + lineTopOffset,
              boxWidth,
              heightOfLine / this.lineHeight
            );
            boxStart = charBox.left;
            boxWidth = charBox.width;
            lastColor = currentColor;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
        }
        if (currentColor) {
          ctx.fillStyle = currentColor;
          ctx.fillRect(
            leftOffset + lineLeftOffset + boxStart,
            topOffset + lineTopOffset,
            boxWidth,
            heightOfLine / this.lineHeight
          );
        }
        lineTopOffset += heightOfLine;
      }
      ctx.fillStyle = originalFill;
      // if there is text background color no
      // other shadows should be casted
      this._removeShadow(ctx);
    },

    /**
     * @private
     * @param {Object} decl style declaration for cache
     * @param {String} decl.fontFamily fontFamily
     * @param {String} decl.fontStyle fontStyle
     * @param {String} decl.fontWeight fontWeight
     * @return {Object} reference to cache
     */
    getFontCache: function(decl) {
      var fontFamily = decl.fontFamily.toLowerCase();
      if (!fabric.charWidthsCache[fontFamily]) {
        fabric.charWidthsCache[fontFamily] = { };
      }
      var cache = fabric.charWidthsCache[fontFamily],
          cacheProp = decl.fontStyle.toLowerCase() + '_' + (decl.fontWeight + '').toLowerCase();
      if (!cache[cacheProp]) {
        cache[cacheProp] = { };
      }
      return cache[cacheProp];
    },

    /**
     * apply all the character style to canvas for rendering
     * @private
     * @param {String} _char
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {Object} [decl]
     */
    _applyCharStyles: function(method, ctx, lineIndex, charIndex, styleDeclaration) {

      this._setFillStyles(ctx, styleDeclaration);
      this._setStrokeStyles(ctx, styleDeclaration);

      ctx.font = this._getFontDeclaration(styleDeclaration);
    },

    /**
     * get the reference, not a clone, of the style object for a given character
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @return {Object} style object
     */
    _getStyleDeclaration: function(lineIndex, charIndex) {
      var lineStyle = this.styles && this.styles[lineIndex];
      if (!lineStyle) {
        return null;
      }
      return lineStyle[charIndex];
    },

    /**
     * return a new object that contains all the style property for a character
     * the object returned is newly created
     * @param {Number} lineIndex of the line where the character is
     * @param {Number} charIndex position of the character on the line
     * @return {Object} style object
     */
    getCompleteStyleDeclaration: function(lineIndex, charIndex) {
      var style = this._getStyleDeclaration(lineIndex, charIndex) || { },
          styleObject = { }, prop;
      for (var i = 0; i < this._styleProperties.length; i++) {
        prop = this._styleProperties[i];
        styleObject[prop] = typeof style[prop] === 'undefined' ? this[prop] : style[prop];
      }
      return styleObject;
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {Object} style
     * @private
     */
    _setStyleDeclaration: function(lineIndex, charIndex, style) {
      this.styles[lineIndex][charIndex] = style;
    },

    /**
     *
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @private
     */
    _deleteStyleDeclaration: function(lineIndex, charIndex) {
      delete this.styles[lineIndex][charIndex];
    },

    /**
     * @param {Number} lineIndex
     * @private
     */
    _getLineStyle: function(lineIndex) {
      return this.styles[lineIndex];
    },

    /**
     * @param {Number} lineIndex
     * @param {Object} style
     * @private
     */
    _setLineStyle: function(lineIndex, style) {
      this.styles[lineIndex] = style;
    },

    /**
     * @param {Number} lineIndex
     * @private
     */
    _deleteLineStyle: function(lineIndex) {
      delete this.styles[lineIndex];
    },

    /**
     * measure and return the width of a single character.
     * possibly overridden to accommodate different measure logic or
     * to hook some external lib for character measurement
     * @private
     * @param {String} char to be measured
     * @param {Object} charStyle style of char to be measured
     * @param {String} [previousChar] previous char
     * @param {Object} [prevCharStyle] style of previous char
     */
    _measureChar: function(_char, charStyle, previousChar, prevCharStyle) {
      // first i try to return from cache
      var fontCache = this.getFontCache(charStyle), fontDeclaration = this._getFontDeclaration(charStyle),
          previousFontDeclaration = this._getFontDeclaration(prevCharStyle), couple = previousChar + _char,
          stylesAreEqual = fontDeclaration === previousFontDeclaration, width, coupleWidth, previousWidth,
          fontMultiplier = charStyle.fontSize / CACHE_FONT_SIZE, kernedWidth;

      if (previousChar && fontCache[previousChar]) {
        previousWidth = fontCache[previousChar];
      }
      if (fontCache[_char]) {
        kernedWidth = width = fontCache[_char];
      }
      if (stylesAreEqual && fontCache[couple]) {
        coupleWidth = fontCache[couple];
        kernedWidth = coupleWidth - previousWidth;
      }
      if (!width || !previousWidth || !coupleWidth) {
        var ctx = this.getMeasuringContext();
        // send a TRUE to specify measuring font size CACHE_FONT_SIZE
        this._setTextStyles(ctx, charStyle, true);
      }
      if (!width) {
        kernedWidth = width = ctx.measureText(_char).width;
        fontCache[_char] = width;
      }
      if (!previousWidth && stylesAreEqual && previousChar) {
        previousWidth = ctx.measureText(previousChar).width;
        fontCache[previousChar] = previousWidth;
      }
      if (stylesAreEqual && !coupleWidth) {
        // we can measure the kerning couple and subtract the width of the previous character
        coupleWidth = ctx.measureText(couple).width;
        fontCache[couple] = coupleWidth;
        kernedWidth = coupleWidth - previousWidth;
        // try to fix a MS browsers oddity
        if (kernedWidth > width) {
          var diff = kernedWidth - width;
          fontCache[_char] = kernedWidth;
          fontCache[couple] += diff;
          width = kernedWidth;
        }
      }
      return { width: width * fontMultiplier, kernedWidth: kernedWidth * fontMultiplier };
    },

    /**
     * return height of char in fontSize for a character at lineIndex, charIndex
     * @param {Number} l line Index
     * @param {Number} c char index
     * @return {Number} fontSize of that character
     */
    getHeightOfChar: function(l, c) {
      return this.getValueOfPropertyAt(l, c, 'fontSize');
    },

    /**
     * measure a text line measuring all characters.
     * @param {Number} lineIndex line number
     * @return {Number} Line width
     */
    measureLine: function(lineIndex) {
      var lineInfo = this._measureLine(lineIndex);
      if (this.charSpacing !== 0) {
        lineInfo.width -= this._getWidthOfCharSpacing();
      }
      if (lineInfo.width < 0) {
        lineInfo.width = 0;
      }
      return lineInfo;
    },

    /**
     * measure every grapheme of a line, populating __charBounds
     * @param {Number} lineIndex
     * @return {Object} object.width total width of characters
     * @return {Object} object.widthOfSpaces length of chars that match this._reSpacesAndTabs
     */
    _measureLine: function(lineIndex) {
      var width = 0, i, grapheme, line = this._textLines[lineIndex], prevGrapheme,
          graphemeInfo, numOfSpaces = 0, lineBounds = new Array(line.length);

      this.__charBounds[lineIndex] = lineBounds;
      for (i = 0; i < line.length; i++) {
        grapheme = line[i];
        graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);
        lineBounds[i] = graphemeInfo;
        width += graphemeInfo.kernedWidth;
        prevGrapheme = grapheme;
      }
      // this latest bound box represent the last character of the line
      // to simplify cursor handling in interactive mode.
      lineBounds[i] = {
        left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,
        width: 0,
        kernedWidth: 0,
        height: this.fontSize
      };
      return { width: width, numOfSpaces: numOfSpaces };
    },

    /**
     * Measure and return the info of a single grapheme.
     * needs the the info of previous graphemes already filled
     * @private
     * @param {String} grapheme to be measured
     * @param {Number} lineIndex index of the line where the char is
     * @param {Number} charIndex position in the line
     * @param {String} [previousChar] character preceding the one to be measured
     */
    _getGraphemeBox: function(grapheme, lineIndex, charIndex, previousGrapheme, skipLeft) {
      var charStyle = this.getCompleteStyleDeclaration(lineIndex, charIndex),
          prevCharStyle = previousGrapheme ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1) : { },
          info = this._measureChar(grapheme, charStyle, previousGrapheme, prevCharStyle),
          kernedWidth = info.kernedWidth, width = info.width;

      if (this.charSpacing !== 0) {
        width += this._getWidthOfCharSpacing();
        kernedWidth += this._getWidthOfCharSpacing();
      }
      var box = {
        width: width,
        left: 0,
        height: charStyle.fontSize,
        kernedWidth: kernedWidth,
      };
      if (charIndex > 0 && !skipLeft) {
        var previousBox = this.__charBounds[lineIndex][charIndex - 1];
        box.left = previousBox.left + previousBox.width + info.kernedWidth - info.width;
      }
      return box;
    },

    /**
     * Calculate height of chosen line
     * height of line is based mainly on fontSize
     * @private
     * @param {Number} lineIndex index of the line to calculate
     */
    getHeightOfLine: function(lineIndex) {
      if (this.__lineHeights[lineIndex]) {
        return this.__lineHeights[lineIndex];
      }

      var line = this._textLines[lineIndex],
          maxHeight = this.getHeightOfChar(lineIndex, 0);

      for (var i = 1, len = line.length; i < len; i++) {
        var currentCharHeight = this.getHeightOfChar(lineIndex, i);
        if (currentCharHeight > maxHeight) {
          maxHeight = currentCharHeight;
        }
      }
      this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;
      return this.__lineHeights[lineIndex];
    },

    /**
     * calculate text box height
     * @private
     */
    calcTextHeight: function() {
      var lineHeight, height = 0;
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        lineHeight = this.getHeightOfLine(i);
        height += (i === len - 1 ? lineHeight / this.lineHeight : lineHeight);
      }
      return height;
    },

    /**
     * @private
     * @return {Number} Left offset
     */
    _getLeftOffset: function() {
      return -this.width / 2;
    },

    /**
     * @private
     * @return {Number} Top offset
     */
    _getTopOffset: function() {
      return -this.height / 2;
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {String} method Method name ("fillText" or "strokeText")
     */
    _renderTextCommon: function(ctx, method) {
      ctx.save();
      var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset(),
          offsets = this._applyPatternGradientTransform(ctx, method === 'fillText' ? this.fill : this.stroke);
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        var heightOfLine = this.getHeightOfLine(i),
            maxHeight = heightOfLine / this.lineHeight,
            leftOffset = this._getLineLeftOffset(i);
        this._renderTextLine(
          method,
          ctx,
          this._textLines[i],
          left + leftOffset - offsets.offsetX,
          top + lineHeights + maxHeight - offsets.offsetY,
          i
        );
        lineHeights += heightOfLine;
      }
      ctx.restore();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextFill: function(ctx) {
      if (!this.fill && !this.styleHas('fill')) {
        return;
      }

      this._renderTextCommon(ctx, 'fillText');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextStroke: function(ctx) {
      if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {
        return;
      }

      if (this.shadow && !this.shadow.affectStroke) {
        this._removeShadow(ctx);
      }

      ctx.save();
      this._setLineDash(ctx, this.strokeDashArray);
      ctx.beginPath();
      this._renderTextCommon(ctx, 'strokeText');
      ctx.closePath();
      ctx.restore();
    },

    /**
     * @private
     * @param {String} method
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {String} line Content of the line
     * @param {Number} left
     * @param {Number} top
     * @param {Number} lineIndex
     * @param {Number} charOffset
     */
    _renderChars: function(method, ctx, line, left, top, lineIndex) {
      // set proper line offset
      var lineHeight = this.getHeightOfLine(lineIndex),
          actualStyle,
          nextStyle,
          charsToRender = '',
          charBox,
          boxWidth = 0,
          timeToRender;

      ctx.save();
      top -= lineHeight * this._fontSizeFraction / this.lineHeight;
      for (var i = 0, len = line.length - 1; i <= len; i++) {
        timeToRender = i === len || this.charSpacing;
        charsToRender += line[i];
        charBox = this.__charBounds[lineIndex][i];
        if (boxWidth === 0) {
          left += charBox.kernedWidth - charBox.width;
        }
        boxWidth += charBox.kernedWidth;
        if (this.textAlign === 'justify' && !timeToRender) {
          if (this._reSpaceAndTab.test(line[i])) {
            timeToRender = true;
          }
        }
        if (!timeToRender) {
          // if we have charSpacing, we render char by char
          actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
          nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
          timeToRender = this._hasStyleChanged(actualStyle, nextStyle);
        }
        if (timeToRender) {
          this._renderChar(method, ctx, lineIndex, i, charsToRender, left, top, lineHeight);
          charsToRender = '';
          actualStyle = nextStyle;
          left += boxWidth;
          boxWidth = 0;
        }
      }
      ctx.restore();
    },

    /**
     * @private
     * @param {String} method
     * @param {CanvasRenderingContext2D} ctx Context to render on
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {String} _char
     * @param {Number} left Left coordinate
     * @param {Number} top Top coordinate
     * @param {Number} lineHeight Height of the line
     */
    _renderChar: function(method, ctx, lineIndex, charIndex, _char, left, top) {
      var decl = this._getStyleDeclaration(lineIndex, charIndex),
          fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex),
          shouldFill = method === 'fillText' && fullDecl.fill,
          shouldStroke = method === 'strokeText' && fullDecl.stroke && fullDecl.strokeWidth;

      if (!shouldStroke && !shouldFill) {
        return;
      }
      decl && ctx.save();

      this._applyCharStyles(method, ctx, lineIndex, charIndex, fullDecl);

      if (decl && decl.textBackgroundColor) {
        this._removeShadow(ctx);
      }
      shouldFill && ctx.fillText(_char, left, top);
      shouldStroke && ctx.strokeText(_char, left, top);
      decl && ctx.restore();
    },

    /**
     * @private
     * @param {Object} prevStyle
     * @param {Object} thisStyle
     */
    _hasStyleChanged: function(prevStyle, thisStyle) {
      return (prevStyle.fill !== thisStyle.fill ||
              prevStyle.stroke !== thisStyle.stroke ||
              prevStyle.strokeWidth !== thisStyle.strokeWidth ||
              prevStyle.fontSize !== thisStyle.fontSize ||
              prevStyle.fontFamily !== thisStyle.fontFamily ||
              prevStyle.fontWeight !== thisStyle.fontWeight ||
              prevStyle.fontStyle !== thisStyle.fontStyle
      );
    },

    /**
     * @private
     * @param {Number} lineIndex index text line
     * @return {Number} Line left offset
     */
    _getLineLeftOffset: function(lineIndex) {
      var lineWidth = this.getLineWidth(lineIndex);
      if (this.textAlign === 'center') {
        return (this.width - lineWidth) / 2;
      }
      if (this.textAlign === 'right') {
        return this.width - lineWidth;
      }
      return 0;
    },

    /**
     * @private
     */
    _clearCache: function() {
      this.__lineWidths = [];
      this.__lineHeights = [];
      this.__numberOfSpaces = [];
      this.__charBounds = [];
    },

    /**
     * @private
     */
    _shouldClearDimensionCache: function() {
      var shouldClear = this._forceClearCache;
      shouldClear || (shouldClear = this.hasStateChanged('_dimensionAffectingProps'));
      if (shouldClear) {
        this.saveState({ propertySet: '_dimensionAffectingProps' });
        this.dirty = true;
        this._forceClearCache = false;
      }
      return shouldClear;
    },

    /**
     * Measure a single line given its index. Used to calculate the initial
     * text bounding box. The values are calculated and stored in __lineWidths cache.
     * @private
     * @param {Number} lineIndex line number
     * @return {Number} Line width
     */
    getLineWidth: function(lineIndex) {
      if (this.__lineWidths[lineIndex]) {
        return this.__lineWidths[lineIndex];
      }

      var width, line = this._textLines[lineIndex], lineInfo;

      if (line === '') {
        width = 0;
      }
      else {
        lineInfo = this.measureLine(lineIndex);
        width = lineInfo.width;
      }
      this.__lineWidths[lineIndex] = width;
      this.__numberOfSpaces[lineIndex] = lineInfo.numberOfSpaces;
      return width;
    },

    _getWidthOfCharSpacing: function() {
      if (this.charSpacing !== 0) {
        return this.fontSize * this.charSpacing / 1000;
      }
      return 0;
    },

    /**
     * @private
     * @param {Number} LineIndex
     * @param {Number} charIndex
     * @param {String} property

     */
    getValueOfPropertyAt: function(lineIndex, charIndex, property) {
      var charStyle = this._getStyleDeclaration(lineIndex, charIndex),
          styleDecoration = charStyle && typeof charStyle[property] !== 'undefined';
      return styleDecoration ? charStyle[property] : this[property];
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _renderTextDecoration: function(ctx, type) {
      if (!this[type] && !this.styleHas(type)) {
        return;
      }
      var heightOfLine,
          lineLeftOffset,
          line, lastDecoration,
          leftOffset = this._getLeftOffset(),
          topOffset = this._getTopOffset(),
          boxStart, boxWidth, charBox, currentDecoration,
          maxHeight, currentFill, lastFill;

      for (var i = 0, len = this._textLines.length; i < len; i++) {
        heightOfLine = this.getHeightOfLine(i);
        if (!this[type] && !this.styleHas(type, i)) {
          topOffset += heightOfLine;
          continue;
        }
        line = this._textLines[i];
        maxHeight = heightOfLine / this.lineHeight;
        lineLeftOffset = this._getLineLeftOffset(i);
        boxStart = 0;
        boxWidth = 0;
        lastDecoration = this.getValueOfPropertyAt(i, 0, type);
        lastFill = this.getValueOfPropertyAt(i, 0, 'fill');
        for (var j = 0, jlen = line.length; j < jlen; j++) {
          charBox = this.__charBounds[i][j];
          currentDecoration = this.getValueOfPropertyAt(i, j, type);
          currentFill = this.getValueOfPropertyAt(i, j, 'fill');
          if ((currentDecoration !== lastDecoration || currentFill !== lastFill) && boxWidth > 0) {
            ctx.fillStyle = lastFill;
            lastDecoration && lastFill && ctx.fillRect(
              leftOffset + lineLeftOffset + boxStart,
              topOffset + maxHeight * (1 - this._fontSizeFraction) + this.offsets[type] * this.fontSize,
              boxWidth,
              this.fontSize / 15);
            boxStart = charBox.left;
            boxWidth = charBox.width;
            lastDecoration = currentDecoration;
            lastFill = currentFill;
          }
          else {
            boxWidth += charBox.kernedWidth;
          }
        }
        ctx.fillStyle = currentFill;
        currentDecoration && currentFill && ctx.fillRect(
          leftOffset + lineLeftOffset + boxStart,
          topOffset + maxHeight * (1 - this._fontSizeFraction) + this.offsets[type] * this.fontSize,
          boxWidth,
          this.fontSize / 15
        );
        topOffset += heightOfLine;
      }
      // if there is text background color no
      // other shadows should be casted
      this._removeShadow(ctx);
    },

    /**
     * return font declaration string for canvas context
     * @param {Object} [styleObject] object
     * @returns {String} font declaration formatted for canvas context.
     */
    _getFontDeclaration: function(styleObject, forMeasuring) {
      var style = styleObject || this;
      return [
        // node-canvas needs "weight style", while browsers need "style weight"
        (fabric.isLikelyNode ? style.fontWeight : style.fontStyle),
        (fabric.isLikelyNode ? style.fontStyle : style.fontWeight),
        forMeasuring ? CACHE_FONT_SIZE + 'px' : style.fontSize + 'px',
        (fabric.isLikelyNode ? ('"' + style.fontFamily + '"') : style.fontFamily)
      ].join(' ');
    },

    /**
     * Renders text instance on a specified context
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    render: function(ctx) {
      // do not render if object is not visible
      if (!this.visible) {
        return;
      }
      if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
        return;
      }
      if (this._shouldClearDimensionCache()) {
        this.initDimensions();
      }
      this.callSuper('render', ctx);
    },

    /**
     * Returns the text as an array of lines.
     * @param {String} text text to split
     * @returns {Array} Lines in the text
     */
    _splitTextIntoLines: function(text) {
      var lines = text.split(this._reNewline),
          newLines = new Array(lines.length),
          newLine = ['\n'],
          newText = [];
      for (var i = 0; i < lines.length; i++) {
        newLines[i] = fabric.util.string.graphemeSplit(lines[i]);
        newText = newText.concat(newLines[i], newLine);
      }
      newText.pop();
      return { _unwrappedLines: newLines, lines: lines, graphemeText: newText, graphemeLines: newLines };
    },

    /**
     * Returns object representation of an instance
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} Object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      var additionalProperties = [
        'text',
        'fontSize',
        'fontWeight',
        'fontFamily',
        'fontStyle',
        'lineHeight',
        'underline',
        'overline',
        'linethrough',
        'textAlign',
        'textBackgroundColor',
        'charSpacing',
      ].concat(propertiesToInclude);
      var obj = this.callSuper('toObject', additionalProperties);
      obj.styles = clone(this.styles, true);
      return obj;
    },

    /**
     * Sets specified property to a specified value
     * @param {String} key
     * @param {*} value
     * @return {fabric.Text} thisArg
     * @chainable
     */
    _set: function(key, value) {
      this.callSuper('_set', key, value);

      if (this._dimensionAffectingProps.indexOf(key) > -1) {
        this.initDimensions();
        this.setCoords();
      }
    },

    /**
     * Returns complexity of an instance
     * @return {Number} complexity
     */
    complexity: function() {
      return 1;
    }
  });

  /* _FROM_SVG_START_ */
  /**
   * List of attribute names to account for when parsing SVG element (used by {@link fabric.Text.fromElement})
   * @static
   * @memberOf fabric.Text
   * @see: http://www.w3.org/TR/SVG/text.html#TextElement
   */
  fabric.Text.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(
    'x y dx dy font-family font-style font-weight font-size text-decoration text-anchor'.split(' '));

  /**
   * Default SVG font size
   * @static
   * @memberOf fabric.Text
   */
  fabric.Text.DEFAULT_SVG_FONT_SIZE = 16;

  /**
   * Returns fabric.Text instance from an SVG element (<b>not yet implemented</b>)
   * @static
   * @memberOf fabric.Text
   * @param {SVGElement} element Element to parse
   * @param {Function} callback callback function invoked after parsing
   * @param {Object} [options] Options object
   */
  fabric.Text.fromElement = function(element, callback, options) {
    if (!element) {
      return callback(null);
    }

    var parsedAttributes = fabric.parseAttributes(element, fabric.Text.ATTRIBUTE_NAMES),
        parsedAnchor = parsedAttributes.textAnchor || 'left';
    options = fabric.util.object.extend((options ? clone(options) : { }), parsedAttributes);

    options.top = options.top || 0;
    options.left = options.left || 0;
    if (parsedAttributes.textDecoration) {
      var textDecoration = parsedAttributes.textDecoration;
      if (textDecoration.indexOf('underline') !== -1) {
        options.underline = true;
      }
      if (textDecoration.indexOf('overline') !== -1) {
        options.overline = true;
      }
      if (textDecoration.indexOf('line-through') !== -1) {
        options.linethrough = true;
      }
      delete options.textDecoration;
    }
    if ('dx' in parsedAttributes) {
      options.left += parsedAttributes.dx;
    }
    if ('dy' in parsedAttributes) {
      options.top += parsedAttributes.dy;
    }
    if (!('fontSize' in options)) {
      options.fontSize = fabric.Text.DEFAULT_SVG_FONT_SIZE;
    }

    var textContent = '';

    // The XML is not properly parsed in IE9 so a workaround to get
    // textContent is through firstChild.data. Another workaround would be
    // to convert XML loaded from a file to be converted using DOMParser (same way loadSVGFromString() does)
    if (!('textContent' in element)) {
      if ('firstChild' in element && element.firstChild !== null) {
        if ('data' in element.firstChild && element.firstChild.data !== null) {
          textContent = element.firstChild.data;
        }
      }
    }
    else {
      textContent = element.textContent;
    }

    textContent = textContent.replace(/^\s+|\s+$|\n+/g, '').replace(/\s+/g, ' ');

    var text = new fabric.Text(textContent, options),
        textHeightScaleFactor = text.getScaledHeight() / text.height,
        lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height,
        scaledDiff = lineHeightDiff * textHeightScaleFactor,
        textHeight = text.getScaledHeight() + scaledDiff,
        offX = 0;
    /*
      Adjust positioning:
        x/y attributes in SVG correspond to the bottom-left corner of text bounding box
        fabric output by default at top, left.
    */
    if (parsedAnchor === 'center') {
      offX = text.getScaledWidth() / 2;
    }
    if (parsedAnchor === 'right') {
      offX = text.getScaledWidth();
    }
    text.set({
      left: text.left - offX,
      top: text.top - (textHeight - text.fontSize * (0.18 + text._fontSizeFraction)) / text.lineHeight
    });
    callback(text);
  };
  /* _FROM_SVG_END_ */

  /**
   * Returns fabric.Text instance from an object representation
   * @static
   * @memberOf fabric.Text
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Text instance is created
   */
  fabric.Text.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Text', object, callback, 'text');
  };

  fabric.util.createAccessors && fabric.util.createAccessors(fabric.Text);

})( true ? exports : this);


(function() {

  function parseDecoration(object) {
    if (object.textDecoration) {
      object.textDecoration.indexOf('underline') > -1 && (object.underline = true);
      object.textDecoration.indexOf('line-through') > -1 && (object.linethrough = true);
      object.textDecoration.indexOf('overline') > -1 && (object.overline = true);
      delete object.textDecoration;
    }
  }

  /**
   * IText class (introduced in <b>v1.4</b>) Events are also fired with "text:"
   * prefix when observing canvas.
   * @class fabric.IText
   * @extends fabric.Text
   * @mixes fabric.Observable
   *
   * @fires changed
   * @fires selection:changed
   * @fires editing:entered
   * @fires editing:exited
   *
   * @return {fabric.IText} thisArg
   * @see {@link fabric.IText#initialize} for constructor definition
   *
   * <p>Supported key combinations:</p>
   * <pre>
   *   Move cursor:                    left, right, up, down
   *   Select character:               shift + left, shift + right
   *   Select text vertically:         shift + up, shift + down
   *   Move cursor by word:            alt + left, alt + right
   *   Select words:                   shift + alt + left, shift + alt + right
   *   Move cursor to line start/end:  cmd + left, cmd + right or home, end
   *   Select till start/end of line:  cmd + shift + left, cmd + shift + right or shift + home, shift + end
   *   Jump to start/end of text:      cmd + up, cmd + down
   *   Select till start/end of text:  cmd + shift + up, cmd + shift + down or shift + pgUp, shift + pgDown
   *   Delete character:               backspace
   *   Delete word:                    alt + backspace
   *   Delete line:                    cmd + backspace
   *   Forward delete:                 delete
   *   Copy text:                      ctrl/cmd + c
   *   Paste text:                     ctrl/cmd + v
   *   Cut text:                       ctrl/cmd + x
   *   Select entire text:             ctrl/cmd + a
   *   Quit editing                    tab or esc
   * </pre>
   *
   * <p>Supported mouse/touch combination</p>
   * <pre>
   *   Position cursor:                click/touch
   *   Create selection:               click/touch & drag
   *   Create selection:               click & shift + click
   *   Select word:                    double click
   *   Select line:                    triple click
   * </pre>
   */
  fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, /** @lends fabric.IText.prototype */ {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'i-text',

    /**
     * Index where text selection starts (or where cursor is when there is no selection)
     * @type Number
     * @default
     */
    selectionStart: 0,

    /**
     * Index where text selection ends
     * @type Number
     * @default
     */
    selectionEnd: 0,

    /**
     * Color of text selection
     * @type String
     * @default
     */
    selectionColor: 'rgba(17,119,255,0.3)',

    /**
     * Indicates whether text is in editing mode
     * @type Boolean
     * @default
     */
    isEditing: false,

    /**
     * Indicates whether a text can be edited
     * @type Boolean
     * @default
     */
    editable: true,

    /**
     * Border color of text object while it's in editing mode
     * @type String
     * @default
     */
    editingBorderColor: 'rgba(102,153,255,0.25)',

    /**
     * Width of cursor (in px)
     * @type Number
     * @default
     */
    cursorWidth: 2,

    /**
     * Color of default cursor (when not overwritten by character style)
     * @type String
     * @default
     */
    cursorColor: '#333',

    /**
     * Delay between cursor blink (in ms)
     * @type Number
     * @default
     */
    cursorDelay: 1000,

    /**
     * Duration of cursor fadein (in ms)
     * @type Number
     * @default
     */
    cursorDuration: 600,

    /**
     * Indicates whether internal text char widths can be cached
     * @type Boolean
     * @default
     */
    caching: true,

    /**
     * @private
     */
    _reSpace: /\s|\n/,

    /**
     * @private
     */
    _currentCursorOpacity: 0,

    /**
     * @private
     */
    _selectionDirection: null,

    /**
     * @private
     */
    _abortCursorAnimation: false,

    /**
     * @private
     */
    __widthOfSpace: [],

    /**
     * Helps determining when the text is in composition, so that the cursor
     * rendering is altered.
     */
    inCompositionMode: false,

    /**
     * Constructor
     * @param {String} text Text string
     * @param {Object} [options] Options object
     * @return {fabric.IText} thisArg
     */
    initialize: function(text, options) {
      this.callSuper('initialize', text, options);
      this.initBehavior();
    },

    /**
     * Sets selection start (left boundary of a selection)
     * @param {Number} index Index to set selection start to
     */
    setSelectionStart: function(index) {
      index = Math.max(index, 0);
      this._updateAndFire('selectionStart', index);
    },

    /**
     * Sets selection end (right boundary of a selection)
     * @param {Number} index Index to set selection end to
     */
    setSelectionEnd: function(index) {
      index = Math.min(index, this.text.length);
      this._updateAndFire('selectionEnd', index);
    },

    /**
     * @private
     * @param {String} property 'selectionStart' or 'selectionEnd'
     * @param {Number} index new position of property
     */
    _updateAndFire: function(property, index) {
      if (this[property] !== index) {
        this._fireSelectionChanged();
        this[property] = index;
      }
      this._updateTextarea();
    },

    /**
     * Fires the even of selection changed
     * @private
     */
    _fireSelectionChanged: function() {
      this.fire('selection:changed');
      this.canvas && this.canvas.fire('text:selection:changed', { target: this });
    },

    /**
     * Gets style of a current selection/cursor (at the start position)
     * @param {Number} [startIndex] Start index to get styles at
     * @param {Number} [endIndex] End index to get styles at
     * @param {Boolean} [endIndex] End index to get styles at
     * @return {Object} styles Style object at a specified (or current) index
     */
    getSelectionStyles: function(startIndex, endIndex, complete) {

      if (endIndex && startIndex !== endIndex) {
        var styles = [];
        for (var i = startIndex; i < endIndex; i++) {
          styles.push(this.getSelectionStyles(i, i, complete));
        }
        return styles;
      }

      var loc = this.get2DCursorLocation(startIndex),
          style = complete ? this.getCompleteStyleDeclaration(loc.lineIndex, loc.charIndex) :
            this._getStyleDeclaration(loc.lineIndex, loc.charIndex);

      return style || {};
    },

    /**
     * Sets style of a current selection, if no selection exist, do not set anything.
     * @param {Object} [styles] Styles object
     * @return {fabric.IText} thisArg
     * @chainable
     */
    setSelectionStyles: function(styles) {
      if (this.selectionStart === this.selectionEnd) {
        return this;
      }
      else {
        for (var i = this.selectionStart; i < this.selectionEnd; i++) {
          this._extendStyles(i, styles);
        }
      }
      /* not included in _extendStyles to avoid clearing cache more than once */
      this._forceClearCache = true;
      return this;
    },

    /**
     * Initialize text dimensions. Render all text on given context
     * or on a offscreen canvas to get the text width with measureText.
     * Updates this.width and this.height with the proper values.
     * Does not return dimensions.
     * @private
     */
    initDimensions: function() {
      this.isEditing && this.initDelayedCursor();
      this.clearContextTop();
      this.callSuper('initDimensions');
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    render: function(ctx) {
      this.clearContextTop();
      this.callSuper('render', ctx);
      // clear the cursorOffsetCache, so we ensure to calculate once per renderCursor
      // the correct position but not at every cursor animation.
      this.cursorOffsetCache = { };
      this.renderCursorOrSelection();
    },

    /**
     * @private
     * @param {CanvasRenderingContext2D} ctx Context to render on
     */
    _render: function(ctx) {
      this.callSuper('_render', ctx);
      this.ctx = ctx;
    },

    /**
     * Prepare and clean the contextTop
     */
    clearContextTop: function(skipRestore) {
      if (!this.active || !this.isEditing) {
        return;
      }
      if (this.canvas && this.canvas.contextTop) {
        var ctx = this.canvas.contextTop;
        ctx.save();
        ctx.transform.apply(ctx, this.canvas.viewportTransform);
        this.transform(ctx);
        this.transformMatrix && ctx.transform.apply(ctx, this.transformMatrix);
        this._clearTextArea(ctx);
        skipRestore || ctx.restore();
      }
    },

    /**
     * Renders cursor or selection (depending on what exists)
     */
    renderCursorOrSelection: function() {
      if (!this.active || !this.isEditing) {
        return;
      }
      var boundaries = this._getCursorBoundaries(), ctx;
      if (this.canvas && this.canvas.contextTop) {
        ctx = this.canvas.contextTop;
        this.clearContextTop(true);
      }
      else {
        ctx = this.ctx;
        ctx.save();
      }
      if (this.selectionStart === this.selectionEnd) {
        this.renderCursor(boundaries, ctx);
      }
      else {
        this.renderSelection(boundaries, ctx);
      }
      ctx.restore();
    },

    _clearTextArea: function(ctx) {
      // we add 4 pixel, to be sure to do not leave any pixel out
      var width = this.width + 4, height = this.height + 4;
      ctx.clearRect(-width / 2, -height / 2, width, height);
    },
    /**
     * Returns 2d representation (lineIndex and charIndex) of cursor (or selection start)
     * @param {Number} [selectionStart] Optional index. When not given, current selectionStart is used.
     * @param {Boolean} [skipWrapping] consider the location for unwrapped lines. usefull to manage styles.
     */
    get2DCursorLocation: function(selectionStart, skipWrapping) {
      if (typeof selectionStart === 'undefined') {
        selectionStart = this.selectionStart;
      }
      var lines = skipWrapping ? this._unwrappedTextLines : this._textLines;
      var len = lines.length;
      for (var i = 0; i < len; i++) {
        if (selectionStart <= lines[i].length) {
          return {
            lineIndex: i,
            charIndex: selectionStart
          };
        }
        selectionStart -= lines[i].length + 1;
      }
      return {
        lineIndex: i - 1,
        charIndex: lines[i - 1].length < selectionStart ? lines[i - 1].length : selectionStart
      };
    },

    /**
     * Returns cursor boundaries (left, top, leftOffset, topOffset)
     * @private
     * @param {Array} chars Array of characters
     * @param {String} typeOfBoundaries
     */
    _getCursorBoundaries: function(position) {

      // left/top are left/top of entire text box
      // leftOffset/topOffset are offset from that left/top point of a text box

      if (typeof position === 'undefined') {
        position = this.selectionStart;
      }

      var left = this._getLeftOffset(),
          top = this._getTopOffset(),
          offsets = this._getCursorBoundariesOffsets(position);

      return {
        left: left,
        top: top,
        leftOffset: offsets.left,
        topOffset: offsets.top
      };
    },

    /**
     * @private
     */
    _getCursorBoundariesOffsets: function(position) {
      if (this.cursorOffsetCache && 'top' in this.cursorOffsetCache) {
        return this.cursorOffsetCache;
      }
      var lineLeftOffset,
          lineIndex = 0,
          charIndex = 0,
          topOffset = 0,
          leftOffset = 0,
          boundaries,
          cursorPosition = this.get2DCursorLocation(position);
      for (var i = 0; i < cursorPosition.lineIndex; i++) {
        topOffset += this.getHeightOfLine(i);
      }

      lineLeftOffset = this._getLineLeftOffset(cursorPosition.lineIndex);
      var bound = this.__charBounds[cursorPosition.lineIndex][cursorPosition.charIndex];
      bound && (leftOffset = bound.left);
      if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {
        leftOffset -= this._getWidthOfCharSpacing();
      }
      boundaries = {
        top: topOffset,
        left: lineLeftOffset + (leftOffset > 0 ? leftOffset : 0),
      };
      this.cursorOffsetCache = boundaries;
      return this.cursorOffsetCache;
    },

    /**
     * Renders cursor
     * @param {Object} boundaries
     * @param {CanvasRenderingContext2D} ctx transformed context to draw on
     */
    renderCursor: function(boundaries, ctx) {
      var cursorLocation = this.get2DCursorLocation(),
          lineIndex = cursorLocation.lineIndex,
          charIndex = cursorLocation.charIndex > 0 ? cursorLocation.charIndex - 1 : 0,
          charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize'),
          multiplier = this.scaleX * this.canvas.getZoom(),
          cursorWidth = this.cursorWidth / multiplier,
          topOffset = boundaries.topOffset;

      topOffset += (1 - this._fontSizeFraction) * this.getHeightOfLine(lineIndex) / this.lineHeight
        - charHeight * (1 - this._fontSizeFraction);

      if (this.inCompositionMode) {
        this.renderSelection(boundaries, ctx);
      }

      ctx.fillStyle = this.getValueOfPropertyAt(lineIndex, charIndex, 'fill');
      ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;
      ctx.fillRect(
        boundaries.left + boundaries.leftOffset - cursorWidth / 2,
        topOffset + boundaries.top,
        cursorWidth,
        charHeight);
    },

    /**
     * Renders text selection
     * @param {Object} boundaries Object with left/top/leftOffset/topOffset
     * @param {CanvasRenderingContext2D} ctx transformed context to draw on
     */
    renderSelection: function(boundaries, ctx) {

      var selectionStart = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart,
          selectionEnd = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd,
          start = this.get2DCursorLocation(selectionStart),
          end = this.get2DCursorLocation(selectionEnd),
          startLine = start.lineIndex,
          endLine = end.lineIndex,
          startChar = start.charIndex < 0 ? 0 : start.charIndex,
          endChar = end.charIndex < 0 ? 0 : end.charIndex;

      for (var i = startLine; i <= endLine; i++) {
        var lineOffset = this._getLineLeftOffset(i) || 0,
            lineHeight = this.getHeightOfLine(i),
            realLineHeight = 0, boxStart = 0, boxEnd = 0;

        if (i === startLine) {
          boxStart = this.__charBounds[startLine][startChar].left;
        }
        if (i >= startLine && i < endLine) {
          boxEnd = this.getLineWidth(i) || 5; // WTF is this 5?
        }
        else if (i === endLine) {
          if (endChar === 0) {
            boxEnd = this.__charBounds[endLine][endChar].left;
          }
          else {
            boxEnd = this.__charBounds[endLine][endChar - 1].left + this.__charBounds[endLine][endChar - 1].width;
          }
        }
        realLineHeight = lineHeight;
        if (this.lineHeight < 1 || (i === endLine && this.lineHeight > 1)) {
          lineHeight /= this.lineHeight;
        }
        if (this.inCompositionMode) {
          ctx.fillStyle = this.compositionColor || 'black';
          ctx.fillRect(
            boundaries.left + lineOffset + boxStart,
            boundaries.top + boundaries.topOffset + lineHeight,
            boxEnd - boxStart,
            1);
        }
        else {
          ctx.fillStyle = this.selectionColor;
          ctx.fillRect(
            boundaries.left + lineOffset + boxStart,
            boundaries.top + boundaries.topOffset,
            boxEnd - boxStart,
            lineHeight);
        }


        boundaries.topOffset += realLineHeight;
      }
    },

    /**
     * High level function to know the height of the cursor.
     * the currentChar is the one that precedes the cursor
     * Returns fontSize of char at the current cursor
     * @return {Number} Character font size
     */
    getCurrentCharFontSize: function() {
      var cp = this._getCurrentCharIndex();
      return this.getValueOfPropertyAt(cp.l, cp.c, 'fontSize');
    },

    /**
     * High level function to know the color of the cursor.
     * the currentChar is the one that precedes the cursor
     * Returns color (fill) of char at the current cursor
     * @return {String} Character color (fill)
     */
    getCurrentCharColor: function() {
      var cp = this._getCurrentCharIndex();
      return this.getValueOfPropertyAt(cp.l, cp.c, 'fill');
    },

    /**
     * Returns the cursor position for the getCurrent.. functions
     * @private
     */
    _getCurrentCharIndex: function() {
      var cursorPosition = this.get2DCursorLocation(this.selectionStart, true),
          charIndex = cursorPosition.charIndex > 0 ? cursorPosition.charIndex - 1 : 0;
      return { l: cursorPosition.lineIndex, c: charIndex };
    }
  });

  /**
   * Returns fabric.IText instance from an object representation
   * @static
   * @memberOf fabric.IText
   * @param {Object} object Object to create an instance from
   * @param {function} [callback] invoked with new instance as argument
   */
  fabric.IText.fromObject = function(object, callback) {
    parseDecoration(object);
    if (object.styles) {
      for (var i in object.styles) {
        for (var j in object.styles[i]) {
          parseDecoration(object.styles[i][j]);
        }
      }
    }
    fabric.Object._fromObject('IText', object, callback, 'text');
  };
})();


(function() {

  var clone = fabric.util.object.clone;

  fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {

    /**
     * Initializes all the interactive behavior of IText
     */
    initBehavior: function() {
      this.initAddedHandler();
      this.initRemovedHandler();
      this.initCursorSelectionHandlers();
      this.initDoubleClickSimulation();
      this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
    },

    onDeselect: function(options) {
      this.isEditing && this.exitEditing();
      this.selected = false;
      fabric.Object.prototype.onDeselect.call(this, options);
    },

    /**
     * Initializes "added" event handler
     */
    initAddedHandler: function() {
      var _this = this;
      this.on('added', function() {
        var canvas = _this.canvas;
        if (canvas) {
          if (!canvas._hasITextHandlers) {
            canvas._hasITextHandlers = true;
            _this._initCanvasHandlers(canvas);
          }
          canvas._iTextInstances = canvas._iTextInstances || [];
          canvas._iTextInstances.push(_this);
        }
      });
    },

    initRemovedHandler: function() {
      var _this = this;
      this.on('removed', function() {
        var canvas = _this.canvas;
        if (canvas) {
          canvas._iTextInstances = canvas._iTextInstances || [];
          fabric.util.removeFromArray(canvas._iTextInstances, _this);
          if (canvas._iTextInstances.length === 0) {
            canvas._hasITextHandlers = false;
            _this._removeCanvasHandlers(canvas);
          }
        }
      });
    },

    /**
     * register canvas event to manage exiting on other instances
     * @private
     */
    _initCanvasHandlers: function(canvas) {
      canvas._mouseUpITextHandler = (function() {
        if (canvas._iTextInstances) {
          canvas._iTextInstances.forEach(function(obj) {
            obj.__isMousedown = false;
          });
        }
      }).bind(this);
      canvas.on('mouse:up', canvas._mouseUpITextHandler);
    },

    /**
     * remove canvas event to manage exiting on other instances
     * @private
     */
    _removeCanvasHandlers: function(canvas) {
      canvas.off('mouse:up', canvas._mouseUpITextHandler);
    },

    /**
     * @private
     */
    _tick: function() {
      this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, '_onTickComplete');
    },

    /**
     * @private
     */
    _animateCursor: function(obj, targetOpacity, duration, completeMethod) {

      var tickState;

      tickState = {
        isAborted: false,
        abort: function() {
          this.isAborted = true;
        },
      };

      obj.animate('_currentCursorOpacity', targetOpacity, {
        duration: duration,
        onComplete: function() {
          if (!tickState.isAborted) {
            obj[completeMethod]();
          }
        },
        onChange: function() {
          // we do not want to animate a selection, only cursor
          if (obj.canvas && obj.selectionStart === obj.selectionEnd) {
            obj.renderCursorOrSelection();
          }
        },
        abort: function() {
          return tickState.isAborted;
        }
      });
      return tickState;
    },

    /**
     * @private
     */
    _onTickComplete: function() {

      var _this = this;

      if (this._cursorTimeout1) {
        clearTimeout(this._cursorTimeout1);
      }
      this._cursorTimeout1 = setTimeout(function() {
        _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, '_tick');
      }, 100);
    },

    /**
     * Initializes delayed cursor
     */
    initDelayedCursor: function(restart) {
      var _this = this,
          delay = restart ? 0 : this.cursorDelay;

      this.abortCursorAnimation();
      this._currentCursorOpacity = 1;
      this._cursorTimeout2 = setTimeout(function() {
        _this._tick();
      }, delay);
    },

    /**
     * Aborts cursor animation and clears all timeouts
     */
    abortCursorAnimation: function() {
      var shouldClear = this._currentTickState || this._currentTickCompleteState;
      this._currentTickState && this._currentTickState.abort();
      this._currentTickCompleteState && this._currentTickCompleteState.abort();

      clearTimeout(this._cursorTimeout1);
      clearTimeout(this._cursorTimeout2);

      this._currentCursorOpacity = 0;
      // to clear just itext area we need to transform the context
      // it may not be worth it
      if (shouldClear) {
        this.canvas && this.canvas.clearContext(this.canvas.contextTop || this.ctx);
      }

    },

    /**
     * Selects entire text
     * @return {fabric.IText} thisArg
     * @chainable
     */
    selectAll: function() {
      this.selectionStart = 0;
      this.selectionEnd = this._text.length;
      this._fireSelectionChanged();
      this._updateTextarea();
      return this;
    },

    /**
     * Returns selected text
     * @return {String}
     */
    getSelectedText: function() {
      return this._text.slice(this.selectionStart, this.selectionEnd).join('');
    },

    /**
     * Find new selection index representing start of current word according to current selection index
     * @param {Number} startFrom Surrent selection index
     * @return {Number} New selection index
     */
    findWordBoundaryLeft: function(startFrom) {
      var offset = 0, index = startFrom - 1;

      // remove space before cursor first
      if (this._reSpace.test(this._text[index])) {
        while (this._reSpace.test(this._text[index])) {
          offset++;
          index--;
        }
      }
      while (/\S/.test(this._text[index]) && index > -1) {
        offset++;
        index--;
      }

      return startFrom - offset;
    },

    /**
     * Find new selection index representing end of current word according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findWordBoundaryRight: function(startFrom) {
      var offset = 0, index = startFrom;

      // remove space after cursor first
      if (this._reSpace.test(this._text[index])) {
        while (this._reSpace.test(this._text[index])) {
          offset++;
          index++;
        }
      }
      while (/\S/.test(this._text[index]) && index < this.text.length) {
        offset++;
        index++;
      }

      return startFrom + offset;
    },

    /**
     * Find new selection index representing start of current line according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findLineBoundaryLeft: function(startFrom) {
      var offset = 0, index = startFrom - 1;

      while (!/\n/.test(this._text[index]) && index > -1) {
        offset++;
        index--;
      }

      return startFrom - offset;
    },

    /**
     * Find new selection index representing end of current line according to current selection index
     * @param {Number} startFrom Current selection index
     * @return {Number} New selection index
     */
    findLineBoundaryRight: function(startFrom) {
      var offset = 0, index = startFrom;

      while (!/\n/.test(this._text[index]) && index < this.text.length) {
        offset++;
        index++;
      }

      return startFrom + offset;
    },

    /**
     * Finds index corresponding to beginning or end of a word
     * @param {Number} selectionStart Index of a character
     * @param {Number} direction 1 or -1
     * @return {Number} Index of the beginning or end of a word
     */
    searchWordBoundary: function(selectionStart, direction) {
      var index     = this._reSpace.test(this.text.charAt(selectionStart)) ? selectionStart - 1 : selectionStart,
          _char     = this.text.charAt(index),
          reNonWord = /[ \n\.,;!\?\-]/;

      while (!reNonWord.test(_char) && index > 0 && index < this.text.length) {
        index += direction;
        _char = this.text.charAt(index);
      }
      if (reNonWord.test(_char) && _char !== '\n') {
        index += direction === 1 ? 0 : 1;
      }
      return index;
    },

    /**
     * Selects a word based on the index
     * @param {Number} selectionStart Index of a character
     */
    selectWord: function(selectionStart) {
      selectionStart = selectionStart || this.selectionStart;
      var newSelectionStart = this.searchWordBoundary(selectionStart, -1), /* search backwards */
          newSelectionEnd = this.searchWordBoundary(selectionStart, 1); /* search forward */

      this.selectionStart = newSelectionStart;
      this.selectionEnd = newSelectionEnd;
      this._fireSelectionChanged();
      this._updateTextarea();
      this.renderCursorOrSelection();
    },

    /**
     * Selects a line based on the index
     * @param {Number} selectionStart Index of a character
     * @return {fabric.IText} thisArg
     * @chainable
     */
    selectLine: function(selectionStart) {
      selectionStart = selectionStart || this.selectionStart;
      var newSelectionStart = this.findLineBoundaryLeft(selectionStart),
          newSelectionEnd = this.findLineBoundaryRight(selectionStart);

      this.selectionStart = newSelectionStart;
      this.selectionEnd = newSelectionEnd;
      this._fireSelectionChanged();
      this._updateTextarea();
      return this;
    },

    /**
     * Enters editing state
     * @return {fabric.IText} thisArg
     * @chainable
     */
    enterEditing: function(e) {
      if (this.isEditing || !this.editable) {
        return;
      }

      if (this.canvas) {
        this.exitEditingOnOthers(this.canvas);
      }

      this.isEditing = true;

      this.initHiddenTextarea(e);
      this.hiddenTextarea.focus();
      this.hiddenTextarea.value = this.text;
      this._updateTextarea();
      this._saveEditingProps();
      this._setEditingProps();
      this._textBeforeEdit = this.text;

      this._tick();
      this.fire('editing:entered');
      this._fireSelectionChanged();
      if (!this.canvas) {
        return this;
      }
      this.canvas.fire('text:editing:entered', { target: this });
      this.initMouseMoveHandler();
      this.canvas.requestRenderAll();
      return this;
    },

    exitEditingOnOthers: function(canvas) {
      if (canvas._iTextInstances) {
        canvas._iTextInstances.forEach(function(obj) {
          obj.selected = false;
          if (obj.isEditing) {
            obj.exitEditing();
          }
        });
      }
    },

    /**
     * Initializes "mousemove" event handler
     */
    initMouseMoveHandler: function() {
      this.canvas.on('mouse:move', this.mouseMoveHandler);
    },

    /**
     * @private
     */
    mouseMoveHandler: function(options) {
      if (!this.__isMousedown || !this.isEditing) {
        return;
      }

      var newSelectionStart = this.getSelectionStartFromPointer(options.e),
          currentStart = this.selectionStart,
          currentEnd = this.selectionEnd;
      if (
        (newSelectionStart !== this.__selectionStartOnMouseDown || currentStart === currentEnd)
        &&
        (currentStart === newSelectionStart || currentEnd === newSelectionStart)
      ) {
        return;
      }
      if (newSelectionStart > this.__selectionStartOnMouseDown) {
        this.selectionStart = this.__selectionStartOnMouseDown;
        this.selectionEnd = newSelectionStart;
      }
      else {
        this.selectionStart = newSelectionStart;
        this.selectionEnd = this.__selectionStartOnMouseDown;
      }
      if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {
        this.restartCursorIfNeeded();
        this._fireSelectionChanged();
        this._updateTextarea();
        this.renderCursorOrSelection();
      }
    },

    /**
     * @private
     */
    _setEditingProps: function() {
      this.hoverCursor = 'text';

      if (this.canvas) {
        this.canvas.defaultCursor = this.canvas.moveCursor = 'text';
      }

      this.borderColor = this.editingBorderColor;

      this.hasControls = this.selectable = false;
      this.lockMovementX = this.lockMovementY = true;
    },

    /**
     * convert from textarea to grapheme indexes
     */
    fromStringToGraphemeSelection: function(start, end, text) {
      var smallerTextStart = text.slice(0, start),
          graphemeStart = fabric.util.string.graphemeSplit(smallerTextStart).length;
      if (start === end) {
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
      }
      var smallerTextEnd = text.slice(start, end),
          graphemeEnd = fabric.util.string.graphemeSplit(smallerTextEnd).length;
      return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
    },

    /**
     * convert from fabric to textarea values
     */
    fromGraphemeToStringSelection: function(start, end, _text) {
      var smallerTextStart = _text.slice(0, start),
          graphemeStart = smallerTextStart.join('').length;
      if (start === end) {
        return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
      }
      var smallerTextEnd = _text.slice(start, end),
          graphemeEnd = smallerTextEnd.join('').length;
      return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
    },

    /**
     * @private
     */
    _updateTextarea: function() {
      this.cursorOffsetCache = { };
      if (!this.hiddenTextarea) {
        return;
      }
      if (!this.inCompositionMode) {
        var newSelection = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
        this.hiddenTextarea.selectionStart = newSelection.selectionStart;
        this.hiddenTextarea.selectionEnd = newSelection.selectionEnd;
      }
      this.updateTextareaPosition();
    },

    /**
     * @private
     */
    updateFromTextArea: function() {
      if (!this.hiddenTextarea) {
        return;
      }
      this.cursorOffsetCache = { };
      this.text = this.hiddenTextarea.value;
      var newSelection = this.fromStringToGraphemeSelection(
        this.hiddenTextarea.selectionStart, this.hiddenTextarea.selectionEnd, this.hiddenTextarea.value);
      this.selectionEnd = this.selectionStart = newSelection.selectionEnd;
      if (!this.inCompositionMode) {
        this.selectionStart = newSelection.selectionStart;
      }
      this.updateTextareaPosition();
    },

    /**
     * @private
     */
    updateTextareaPosition: function() {
      if (this.selectionStart === this.selectionEnd) {
        var style = this._calcTextareaPosition();
        this.hiddenTextarea.style.left = style.left;
        this.hiddenTextarea.style.top = style.top;
      }
    },

    /**
     * @private
     * @return {Object} style contains style for hiddenTextarea
     */
    _calcTextareaPosition: function() {
      if (!this.canvas) {
        return { x: 1, y: 1 };
      }
      var desiredPostion = this.inCompositionMode ? this.compositionStart : this.selectionStart,
          boundaries = this._getCursorBoundaries(desiredPostion),
          cursorLocation = this.get2DCursorLocation(desiredPostion),
          lineIndex = cursorLocation.lineIndex,
          charIndex = cursorLocation.charIndex,
          charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, 'fontSize') * this.lineHeight,
          leftOffset = boundaries.leftOffset,
          m = this.calcTransformMatrix(),
          p = {
            x: boundaries.left + leftOffset,
            y: boundaries.top + boundaries.topOffset + charHeight
          },
          upperCanvas = this.canvas.upperCanvasEl,
          maxWidth = upperCanvas.width - charHeight,
          maxHeight = upperCanvas.height - charHeight;

      p = fabric.util.transformPoint(p, m);
      p = fabric.util.transformPoint(p, this.canvas.viewportTransform);
      if (p.x < 0) {
        p.x = 0;
      }
      if (p.x > maxWidth) {
        p.x = maxWidth;
      }
      if (p.y < 0) {
        p.y = 0;
      }
      if (p.y > maxHeight) {
        p.y = maxHeight;
      }

      // add canvas offset on document
      p.x += this.canvas._offset.left;
      p.y += this.canvas._offset.top;

      return { left: p.x + 'px', top: p.y + 'px', fontSize: charHeight + 'px', charHeight: charHeight };
    },

    /**
     * @private
     */
    _saveEditingProps: function() {
      this._savedProps = {
        hasControls: this.hasControls,
        borderColor: this.borderColor,
        lockMovementX: this.lockMovementX,
        lockMovementY: this.lockMovementY,
        hoverCursor: this.hoverCursor,
        defaultCursor: this.canvas && this.canvas.defaultCursor,
        moveCursor: this.canvas && this.canvas.moveCursor
      };
    },

    /**
     * @private
     */
    _restoreEditingProps: function() {
      if (!this._savedProps) {
        return;
      }

      this.hoverCursor = this._savedProps.overCursor;
      this.hasControls = this._savedProps.hasControls;
      this.borderColor = this._savedProps.borderColor;
      this.lockMovementX = this._savedProps.lockMovementX;
      this.lockMovementY = this._savedProps.lockMovementY;

      if (this.canvas) {
        this.canvas.defaultCursor = this._savedProps.defaultCursor;
        this.canvas.moveCursor = this._savedProps.moveCursor;
      }
    },

    /**
     * Exits from editing state
     * @return {fabric.IText} thisArg
     * @chainable
     */
    exitEditing: function() {
      var isTextChanged = (this._textBeforeEdit !== this.text);
      this.selected = false;
      this.isEditing = false;
      this.selectable = true;

      this.selectionEnd = this.selectionStart;

      if (this.hiddenTextarea) {
        this.hiddenTextarea.blur && this.hiddenTextarea.blur();
        this.canvas && this.hiddenTextarea.parentNode.removeChild(this.hiddenTextarea);
        this.hiddenTextarea = null;
      }

      this.abortCursorAnimation();
      this._restoreEditingProps();
      this._currentCursorOpacity = 0;

      this.fire('editing:exited');
      isTextChanged && this.fire('modified');
      if (this.canvas) {
        this.canvas.off('mouse:move', this.mouseMoveHandler);
        this.canvas.fire('text:editing:exited', { target: this });
        isTextChanged && this.canvas.fire('object:modified', { target: this });
      }
      return this;
    },

    /**
     * @private
     */
    _removeExtraneousStyles: function() {
      for (var prop in this.styles) {
        if (!this._textLines[prop]) {
          delete this.styles[prop];
        }
      }
    },

    /**
     * remove and reflow a style block from start to end.
     * @param {Number} start linear start position for removal (included in removal)
     * @param {Number} end linear end position for removal ( excluded from removal )
     */
    removeStyleFromTo: function(start, end) {
      var cursorStart = this.get2DCursorLocation(start, true),
          cursorEnd = this.get2DCursorLocation(end, true),
          lineStart = cursorStart.lineIndex,
          charStart = cursorStart.charIndex,
          lineEnd = cursorEnd.lineIndex,
          charEnd = cursorEnd.charIndex,
          i, styleObj;
      if (lineStart !== lineEnd) {
        // step1 remove the trailing of lineStart
        if (this.styles[lineStart]) {
          for (i = charStart; i < this._textLines[lineStart].length; i++) {
            delete this.styles[lineStart][i];
          }
        }
        // step2 move the trailing of lineEnd to lineStart if needed
        if (this.styles[lineEnd]) {
          for (i = charEnd; i < this._textLines[lineEnd].length; i++) {
            styleObj = this.styles[lineEnd][i];
            if (styleObj) {
              this.styles[lineStart] || (this.styles[lineStart] = { });
              this.styles[lineStart][charStart + i - charEnd] = styleObj;
            }
          }
        }
        // step3 detects lines will be completely removed.
        for (i = lineStart + 1; i <= lineEnd; i++) {
          delete this.styles[i];
        }
        // step4 shift remaining lines.
        this.shiftLineStyles(lineEnd, lineStart - lineEnd);
      }
      else {
        // remove and shift left on the same line
        if (this.styles[lineStart]) {
          styleObj = this.styles[lineStart];
          var diff = charEnd - charStart, numericChar, _char;
          for (i = charStart; i < charEnd; i++) {
            delete styleObj[i];
          }
          for (_char in this.styles[lineStart]) {
            numericChar = parseInt(_char, 10);
            if (numericChar >= charEnd) {
              styleObj[numericChar - diff] = styleObj[_char];
              delete styleObj[_char];
            }
          }
        }
      }
    },

    /**
     * Shifts line styles up or down
     * @param {Number} lineIndex Index of a line
     * @param {Number} offset Can any number?
     */
    shiftLineStyles: function(lineIndex, offset) {
      // shift all line styles by offset upward or downward
      // do not clone deep. we need new array, not new style objects
      var clonedStyles = clone(this.styles);
      for (var line in this.styles) {
        var numericLine = parseInt(line, 10);
        if (numericLine > lineIndex) {
          this.styles[numericLine + offset] = clonedStyles[numericLine];
          if (!clonedStyles[numericLine - offset]) {
            delete this.styles[numericLine];
          }
        }
      }
    },

    restartCursorIfNeeded: function() {
      if (!this._currentTickState || this._currentTickState.isAborted
        || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted
      ) {
        this.initDelayedCursor();
      }
    },

    /**
     * Inserts new style object
     * @param {Number} lineIndex Index of a line
     * @param {Number} charIndex Index of a char
     * @param {Number} qty number of lines to add
     * @param {Array} copiedStyle Array of objects styles
     */
    insertNewlineStyleObject: function(lineIndex, charIndex, qty, copiedStyle) {
      var currentCharStyle,
          newLineStyles = {},
          somethingAdded = false;

      qty || (qty = 1);
      this.shiftLineStyles(lineIndex, qty);
      if (this.styles[lineIndex]) {
        currentCharStyle = this.styles[lineIndex][charIndex === 0 ? charIndex : charIndex - 1];
      }

      // we clone styles of all chars
      // after cursor onto the current line
      for (var index in this.styles[lineIndex]) {
        var numIndex = parseInt(index, 10);
        if (numIndex >= charIndex) {
          somethingAdded = true;
          newLineStyles[numIndex - charIndex] = this.styles[lineIndex][index];
          // remove lines from the previous line since they're on a new line now
          delete this.styles[lineIndex][index];
        }
      }
      if (somethingAdded) {
        this.styles[lineIndex + qty] = newLineStyles;
      }
      else {
        delete this.styles[lineIndex + qty];
      }
      // for the other lines
      // we clone current char style onto the next (otherwise empty) line
      while (qty > 1) {
        qty--;
        if (copiedStyle && copiedStyle[qty]) {
          this.styles[lineIndex + qty] = { 0: clone(copiedStyle[qty]) };
        }
        else if (currentCharStyle) {
          this.styles[lineIndex + qty] = { 0: clone(currentCharStyle) };
        }
        else {
          delete this.styles[lineIndex + qty];
        }
      }
      this._forceClearCache = true;
    },

    /**
     * Inserts style object for a given line/char index
     * @param {Number} lineIndex Index of a line
     * @param {Number} charIndex Index of a char
     * @param {Number} quantity number Style object to insert, if given
     * @param {Array} copiedStyle array of style objecs
     */
    insertCharStyleObject: function(lineIndex, charIndex, quantity, copiedStyle) {
      if (!this.styles) {
        this.styles = {};
      }
      var currentLineStyles       = this.styles[lineIndex],
          currentLineStylesCloned = currentLineStyles ? clone(currentLineStyles) : {};

      quantity || (quantity = 1);
      // shift all char styles by quantity forward
      // 0,1,2,3 -> (charIndex=2) -> 0,1,3,4 -> (insert 2) -> 0,1,2,3,4
      for (var index in currentLineStylesCloned) {
        var numericIndex = parseInt(index, 10);
        if (numericIndex >= charIndex) {
          currentLineStyles[numericIndex + quantity] = currentLineStylesCloned[numericIndex];
          // only delete the style if there was nothing moved there
          if (!currentLineStylesCloned[numericIndex - quantity]) {
            delete currentLineStyles[numericIndex];
          }
        }
      }
      this._forceClearCache = true;
      if (copiedStyle) {
        while (quantity--) {
          if (!Object.keys(copiedStyle[quantity]).length) {
            continue;
          }
          if (!this.styles[lineIndex]) {
            this.styles[lineIndex] = {};
          }
          this.styles[lineIndex][charIndex + quantity] = clone(copiedStyle[quantity]);
        }
        return;
      }
      if (!currentLineStyles) {
        return;
      }
      var newStyle = currentLineStyles[charIndex ? charIndex - 1 : 1];
      while (newStyle && quantity--) {
        this.styles[lineIndex][charIndex + quantity] = clone(newStyle);
      }
    },

    /**
     * Inserts style object(s)
     * @param {Array} insertedText Characters at the location where style is inserted
     * @param {Number} start cursor index for inserting style
     * @param {Array} [copiedStyle] array of style objects to insert.
     */
    insertNewStyleBlock: function(insertedText, start, copiedStyle) {
      var cursorLoc = this.get2DCursorLocation(start, true),
          addedLines = [0], linesLenght = 0;
      for (var i = 0; i < insertedText.length; i++) {
        if (insertedText[i] === '\n') {
          linesLenght++;
          addedLines[linesLenght] = 0;
        }
        else {
          addedLines[linesLenght]++;
        }
      }
      if (addedLines[0] > 0) {
        this.insertCharStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex, addedLines[0], copiedStyle);
        copiedStyle = copiedStyle && copiedStyle.slice(addedLines[0] + 1);
      }
      linesLenght && this.insertNewlineStyleObject(
        cursorLoc.lineIndex, cursorLoc.charIndex + addedLines[0], linesLenght);
      for (var i = 1; i <= linesLenght; i++) {
        this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
        copiedStyle = copiedStyle && copiedStyle.slice(addedLines[i] + 1);
      }
    },

    /**
     * Set the selectionStart and selectionEnd according to the ne postion of cursor
     * mimic the key - mouse navigation when shift is pressed.
     */
    setSelectionStartEndWithShift: function(start, end, newSelection) {
      if (newSelection <= start) {
        if (end === start) {
          this._selectionDirection = 'left';
        }
        else if (this._selectionDirection === 'right') {
          this._selectionDirection = 'left';
          this.selectionEnd = start;
        }
        this.selectionStart = newSelection;
      }
      else if (newSelection > start && newSelection < end) {
        if (this._selectionDirection === 'right') {
          this.selectionEnd = newSelection;
        }
        else {
          this.selectionStart = newSelection;
        }
      }
      else {
        // newSelection is > selection start and end
        if (end === start) {
          this._selectionDirection = 'right';
        }
        else if (this._selectionDirection === 'left') {
          this._selectionDirection = 'right';
          this.selectionStart = end;
        }
        this.selectionEnd = newSelection;
      }
    },

    setSelectionInBoundaries: function() {
      var length = this.text.length;
      if (this.selectionStart > length) {
        this.selectionStart = length;
      }
      else if (this.selectionStart < 0) {
        this.selectionStart = 0;
      }
      if (this.selectionEnd > length) {
        this.selectionEnd = length;
      }
      else if (this.selectionEnd < 0) {
        this.selectionEnd = 0;
      }
    }
  });
})();


fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {
  /**
   * Initializes "dbclick" event handler
   */
  initDoubleClickSimulation: function() {

    // for double click
    this.__lastClickTime = +new Date();

    // for triple click
    this.__lastLastClickTime = +new Date();

    this.__lastPointer = { };

    this.on('mousedown', this.onMouseDown.bind(this));
  },

  onMouseDown: function(options) {

    this.__newClickTime = +new Date();
    var newPointer = this.canvas.getPointer(options.e);

    if (this.isTripleClick(newPointer, options.e)) {
      this.fire('tripleclick', options);
      this._stopEvent(options.e);
    }
    this.__lastLastClickTime = this.__lastClickTime;
    this.__lastClickTime = this.__newClickTime;
    this.__lastPointer = newPointer;
    this.__lastIsEditing = this.isEditing;
    this.__lastSelected = this.selected;
  },

  isTripleClick: function(newPointer) {
    return this.__newClickTime - this.__lastClickTime < 500 &&
        this.__lastClickTime - this.__lastLastClickTime < 500 &&
        this.__lastPointer.x === newPointer.x &&
        this.__lastPointer.y === newPointer.y;
  },

  /**
   * @private
   */
  _stopEvent: function(e) {
    e.preventDefault && e.preventDefault();
    e.stopPropagation && e.stopPropagation();
  },

  /**
   * Initializes event handlers related to cursor or selection
   */
  initCursorSelectionHandlers: function() {
    this.initMousedownHandler();
    this.initMouseupHandler();
    this.initClicks();
  },

  /**
   * Initializes double and triple click event handlers
   */
  initClicks: function() {
    this.on('mousedblclick', function(options) {
      this.selectWord(this.getSelectionStartFromPointer(options.e));
    });
    this.on('tripleclick', function(options) {
      this.selectLine(this.getSelectionStartFromPointer(options.e));
    });
  },

  /**
   * Initializes "mousedown" event handler
   */
  initMousedownHandler: function() {
    this.on('mousedown', function(options) {
      if (!this.editable || (options.e.button && options.e.button !== 1)) {
        return;
      }
      var pointer = this.canvas.getPointer(options.e);

      this.__mousedownX = pointer.x;
      this.__mousedownY = pointer.y;
      this.__isMousedown = true;

      if (this.selected) {
        this.setCursorByClick(options.e);
      }

      if (this.isEditing) {
        this.__selectionStartOnMouseDown = this.selectionStart;
        if (this.selectionStart === this.selectionEnd) {
          this.abortCursorAnimation();
        }
        this.renderCursorOrSelection();
      }
    });
  },

  /**
   * @private
   */
  _isObjectMoved: function(e) {
    var pointer = this.canvas.getPointer(e);

    return this.__mousedownX !== pointer.x ||
           this.__mousedownY !== pointer.y;
  },

  /**
   * Initializes "mouseup" event handler
   */
  initMouseupHandler: function() {
    this.on('mouseup', function(options) {
      this.__isMousedown = false;
      if (!this.editable || this._isObjectMoved(options.e) || (options.e.button && options.e.button !== 1)) {
        return;
      }

      if (this.__lastSelected && !this.__corner) {
        this.enterEditing(options.e);
        if (this.selectionStart === this.selectionEnd) {
          this.initDelayedCursor(true);
        }
        else {
          this.renderCursorOrSelection();
        }
      }
      this.selected = true;
    });
  },

  /**
   * Changes cursor location in a text depending on passed pointer (x/y) object
   * @param {Event} e Event object
   */
  setCursorByClick: function(e) {
    var newSelection = this.getSelectionStartFromPointer(e),
        start = this.selectionStart, end = this.selectionEnd;
    if (e.shiftKey) {
      this.setSelectionStartEndWithShift(start, end, newSelection);
    }
    else {
      this.selectionStart = newSelection;
      this.selectionEnd = newSelection;
    }
    if (this.isEditing) {
      this._fireSelectionChanged();
      this._updateTextarea();
    }
  },

  /**
   * Returns index of a character corresponding to where an object was clicked
   * @param {Event} e Event object
   * @return {Number} Index of a character
   */
  getSelectionStartFromPointer: function(e) {
    var mouseOffset = this.getLocalPointer(e),
        prevWidth = 0,
        width = 0,
        height = 0,
        charIndex = 0,
        lineIndex = 0,
        lineLeftOffset,
        line;

    for (var i = 0, len = this._textLines.length; i < len; i++) {
      if (height <= mouseOffset.y) {
        height += this.getHeightOfLine(i) * this.scaleY;
        lineIndex = i;
        if (i > 0) {
          charIndex += this._textLines[i - 1].length + 1;
        }
      }
      else {
        break;
      }
    }
    lineLeftOffset = this._getLineLeftOffset(lineIndex);
    width = lineLeftOffset * this.scaleX;
    line = this._textLines[lineIndex];
    for (var j = 0, jlen = line.length; j < jlen; j++) {
      prevWidth = width;
      // i removed something about flipX here, check.
      width += this.__charBounds[lineIndex][j].kernedWidth * this.scaleX;
      if (width <= mouseOffset.x) {
        charIndex++;
      }
      else {
        break;
      }
    }
    return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);
  },

  /**
   * @private
   */
  _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index, jlen) {

    var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth,
        distanceBtwNextCharAndCursor = width - mouseOffset.x,
        offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor ? 0 : 1,
        newSelectionStart = index + offset;
    // if object is horizontally flipped, mirror cursor location from the end
    if (this.flipX) {
      newSelectionStart = jlen - newSelectionStart;
    }

    if (newSelectionStart > this._text.length) {
      newSelectionStart = this._text.length;
    }

    return newSelectionStart;
  }
});


fabric.util.object.extend(fabric.IText.prototype, /** @lends fabric.IText.prototype */ {

  /**
   * Initializes hidden textarea (needed to bring up keyboard in iOS)
   */
  initHiddenTextarea: function() {
    this.hiddenTextarea = fabric.document.createElement('textarea');
    this.hiddenTextarea.setAttribute('autocapitalize', 'off');
    this.hiddenTextarea.setAttribute('autocorrect', 'off');
    this.hiddenTextarea.setAttribute('autocomplete', 'off');
    this.hiddenTextarea.setAttribute('spellcheck', 'false');
    this.hiddenTextarea.setAttribute('data-fabric-hiddentextarea', '');
    this.hiddenTextarea.setAttribute('wrap', 'off');
    var style = this._calcTextareaPosition();
    this.hiddenTextarea.style.cssText = 'position: absolute; top: ' + style.top +
    '; left: ' + style.left + '; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px;' +
    ' line-height: 1px; paddingｰtop: ' + style.fontSize + ';';
    fabric.document.body.appendChild(this.hiddenTextarea);

    fabric.util.addListener(this.hiddenTextarea, 'keydown', this.onKeyDown.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'keyup', this.onKeyUp.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'input', this.onInput.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'copy', this.copy.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'cut', this.copy.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'paste', this.paste.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'compositionstart', this.onCompositionStart.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'compositionupdate', this.onCompositionUpdate.bind(this));
    fabric.util.addListener(this.hiddenTextarea, 'compositionend', this.onCompositionEnd.bind(this));

    if (!this._clickHandlerInitialized && this.canvas) {
      fabric.util.addListener(this.canvas.upperCanvasEl, 'click', this.onClick.bind(this));
      this._clickHandlerInitialized = true;
    }
  },

  /**
   * For functionalities on keyDown
   * Map a special key to a function of the instance/prototype
   * If you need different behaviour for ESC or TAB or arrows, you have to change
   * this map setting the name of a function that you build on the fabric.Itext or
   * your prototype.
   * the map change will affect all Instances unless you need for only some text Instances
   * in that case you have to clone this object and assign your Instance.
   * this.keysMap = fabric.util.object.clone(this.keysMap);
   * The function must be in fabric.Itext.prototype.myFunction And will receive event as args[0]
   */
  keysMap: {
    9:  'exitEditing',
    27: 'exitEditing',
    33: 'moveCursorUp',
    34: 'moveCursorDown',
    35: 'moveCursorRight',
    36: 'moveCursorLeft',
    37: 'moveCursorLeft',
    38: 'moveCursorUp',
    39: 'moveCursorRight',
    40: 'moveCursorDown',
  },

  /**
   * For functionalities on keyUp + ctrl || cmd
   */
  ctrlKeysMapUp: {
    67: 'copy',
    88: 'cut'
  },

  /**
   * For functionalities on keyDown + ctrl || cmd
   */
  ctrlKeysMapDown: {
    65: 'selectAll'
  },

  onClick: function() {
    // No need to trigger click event here, focus is enough to have the keyboard appear on Android
    this.hiddenTextarea && this.hiddenTextarea.focus();
  },

  /**
   * Handles keyup event
   * @param {Event} e Event object
   */
  onKeyDown: function(e) {
    if (!this.isEditing　|| this.inCompositionMode) {
      return;
    }
    if (e.keyCode in this.keysMap) {
      this[this.keysMap[e.keyCode]](e);
    }
    else if ((e.keyCode in this.ctrlKeysMapDown) && (e.ctrlKey || e.metaKey)) {
      this[this.ctrlKeysMapDown[e.keyCode]](e);
    }
    else {
      return;
    }
    e.stopImmediatePropagation();
    e.preventDefault();
    if (e.keyCode >= 33 && e.keyCode <= 40) {
      // if i press an arrow key just update selection
      this.clearContextTop();
      this.renderCursorOrSelection();
    }
    else {
      this.canvas && this.canvas.requestRenderAll();
    }
  },

  /**
   * Handles keyup event
   * We handle KeyUp because ie11 and edge have difficulties copy/pasting
   * if a copy/cut event fired, keyup is dismissed
   * @param {Event} e Event object
   */
  onKeyUp: function(e) {
    if (!this.isEditing || this._copyDone || this.inCompositionMode) {
      this._copyDone = false;
      return;
    }
    if ((e.keyCode in this.ctrlKeysMapUp) && (e.ctrlKey || e.metaKey)) {
      this[this.ctrlKeysMapUp[e.keyCode]](e);
    }
    else {
      return;
    }
    e.stopImmediatePropagation();
    e.preventDefault();
    this.canvas && this.canvas.requestRenderAll();
  },

  /**
   * Handles onInput event
   * @param {Event} e Event object
   */
  onInput: function(e) {
    var fromPaste = this.fromPaste;
    this.fromPaste = false;
    e && e.stopPropagation();
    if (!this.isEditing) {
      return;
    }
    // decisions about style changes.
    var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText,
        charCount = this._text.length,
        nextCharCount = nextText.length,
        removedText, insertedText,
        charDiff = nextCharCount - charCount;

    if (this.hiddenTextarea.value === '') {
      this.styles = { };
      this.updateFromTextArea();
      this.fire('changed');
      if (this.canvas) {
        this.canvas.fire('text:changed', { target: this });
        this.canvas.requestRenderAll();
      }
    }

    if (this.selectionStart !== this.selectionEnd) {
      removedText = this._text.slice(this.selectionStart, this.selectionEnd);
      charDiff += this.selectionEnd - this.selectionStart;
    }
    else if (nextCharCount < charCount) {
      removedText = this._text.slice(this.selectionEnd + charDiff, this.selectionEnd);
    }
    var textareaSelection = this.fromStringToGraphemeSelection(
      this.hiddenTextarea.selectionStart,
      this.hiddenTextarea.selectionEnd,
      this.hiddenTextarea.value
    );
    insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);
    if (removedText && removedText.length) {
      if (this.selectionStart !== this.selectionEnd) {
        this.removeStyleFromTo(this.selectionStart, this.selectionEnd);
      }
      else if (this.selectionStart > textareaSelection.selectionStart) {
        // detect differencies between forwardDelete and backDelete
        this.removeStyleFromTo(this.selectionEnd - removedText.length, this.selectionEnd);
      }
      else {
        this.removeStyleFromTo(this.selectionEnd, this.selectionEnd + removedText.length);
      }
    }
    if (insertedText.length) {
      if (fromPaste && insertedText.join('') === fabric.copiedText) {
        this.insertNewStyleBlock(insertedText, this.selectionStart, fabric.copiedTextStyle);
      }
      else {
        this.insertNewStyleBlock(insertedText, this.selectionStart);
      }
    }
    this.updateFromTextArea();
    this.fire('changed');
    if (this.canvas) {
      this.canvas.fire('text:changed', { target: this });
      this.canvas.requestRenderAll();
    }
  },
  /**
   * Composition start
   */
  onCompositionStart: function() {
    this.inCompositionMode = true;
  },

  /**
   * Composition end
   */
  onCompositionEnd: function() {
    this.inCompositionMode = false;
  },

  // /**
  //  * Composition update
  //  */
  onCompositionUpdate: function(e) {
    this.compositionStart = e.target.selectionStart;
    this.compositionEnd = e.target.selectionEnd;
    this.updateTextareaPosition();
  },

  /**
   * Copies selected text
   * @param {Event} e Event object
   */
  copy: function() {
    if (this.selectionStart === this.selectionEnd) {
      //do not cut-copy if no selection
      return;
    }

    fabric.copiedText = this.getSelectedText();
    fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);
    this._copyDone = true;
  },

  /**
   * Pastes text
   * @param {Event} e Event object
   */
  paste: function() {
    this.fromPaste = true;
  },

  /**
   * @private
   * @param {Event} e Event object
   * @return {Object} Clipboard data object
   */
  _getClipboardData: function(e) {
    return (e && e.clipboardData) || fabric.window.clipboardData;
  },

  /**
   * Finds the width in pixels before the cursor on the same line
   * @private
   * @param {Number} lineIndex
   * @param {Number} charIndex
   * @return {Number} widthBeforeCursor width before cursor
   */
  _getWidthBeforeCursor: function(lineIndex, charIndex) {
    var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;

    if (charIndex > 0) {
      bound = this.__charBounds[lineIndex][charIndex - 1];
      widthBeforeCursor += bound.left + bound.width;
    }
    return widthBeforeCursor;
  },

  /**
   * Gets start offset of a selection
   * @param {Event} e Event object
   * @param {Boolean} isRight
   * @return {Number}
   */
  getDownCursorOffset: function(e, isRight) {
    var selectionProp = this._getSelectionForOffset(e, isRight),
        cursorLocation = this.get2DCursorLocation(selectionProp),
        lineIndex = cursorLocation.lineIndex;
    // if on last line, down cursor goes to end of line
    if (lineIndex === this._textLines.length - 1 || e.metaKey || e.keyCode === 34) {
      // move to the end of a text
      return this._text.length - selectionProp;
    }
    var charIndex = cursorLocation.charIndex,
        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
        indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor),
        textAfterCursor = this._textLines[lineIndex].slice(charIndex);
    return textAfterCursor.length + indexOnOtherLine + 2;
  },

  /**
   * private
   * Helps finding if the offset should be counted from Start or End
   * @param {Event} e Event object
   * @param {Boolean} isRight
   * @return {Number}
   */
  _getSelectionForOffset: function(e, isRight) {
    if (e.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {
      return this.selectionEnd;
    }
    else {
      return this.selectionStart;
    }
  },

  /**
   * @param {Event} e Event object
   * @param {Boolean} isRight
   * @return {Number}
   */
  getUpCursorOffset: function(e, isRight) {
    var selectionProp = this._getSelectionForOffset(e, isRight),
        cursorLocation = this.get2DCursorLocation(selectionProp),
        lineIndex = cursorLocation.lineIndex;
    if (lineIndex === 0 || e.metaKey || e.keyCode === 33) {
      // if on first line, up cursor goes to start of line
      return -selectionProp;
    }
    var charIndex = cursorLocation.charIndex,
        widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex),
        indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor),
        textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex);
    // return a negative offset
    return -this._textLines[lineIndex - 1].length + indexOnOtherLine - textBeforeCursor.length;
  },

  /**
   * for a given width it founds the matching character.
   * @private
   */
  _getIndexOnLine: function(lineIndex, width) {

    var line = this._textLines[lineIndex],
        lineLeftOffset = this._getLineLeftOffset(lineIndex),
        widthOfCharsOnLine = lineLeftOffset,
        indexOnLine = 0, charWidth, foundMatch;

    for (var j = 0, jlen = line.length; j < jlen; j++) {
      charWidth = this.__charBounds[lineIndex][j].width;
      widthOfCharsOnLine += charWidth;
      if (widthOfCharsOnLine > width) {
        foundMatch = true;
        var leftEdge = widthOfCharsOnLine - charWidth,
            rightEdge = widthOfCharsOnLine,
            offsetFromLeftEdge = Math.abs(leftEdge - width),
            offsetFromRightEdge = Math.abs(rightEdge - width);

        indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j : (j - 1);
        break;
      }
    }

    // reached end
    if (!foundMatch) {
      indexOnLine = line.length - 1;
    }

    return indexOnLine;
  },


  /**
   * Moves cursor down
   * @param {Event} e Event object
   */
  moveCursorDown: function(e) {
    if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
      return;
    }
    this._moveCursorUpOrDown('Down', e);
  },

  /**
   * Moves cursor up
   * @param {Event} e Event object
   */
  moveCursorUp: function(e) {
    if (this.selectionStart === 0 && this.selectionEnd === 0) {
      return;
    }
    this._moveCursorUpOrDown('Up', e);
  },

  /**
   * Moves cursor up or down, fires the events
   * @param {String} direction 'Up' or 'Down'
   * @param {Event} e Event object
   */
  _moveCursorUpOrDown: function(direction, e) {
    // getUpCursorOffset
    // getDownCursorOffset
    var action = 'get' + direction + 'CursorOffset',
        offset = this[action](e, this._selectionDirection === 'right');
    if (e.shiftKey) {
      this.moveCursorWithShift(offset);
    }
    else {
      this.moveCursorWithoutShift(offset);
    }
    if (offset !== 0) {
      this.setSelectionInBoundaries();
      this.abortCursorAnimation();
      this._currentCursorOpacity = 1;
      this.initDelayedCursor();
      this._fireSelectionChanged();
      this._updateTextarea();
    }
  },

  /**
   * Moves cursor with shift
   * @param {Number} offset
   */
  moveCursorWithShift: function(offset) {
    var newSelection = this._selectionDirection === 'left'
    ? this.selectionStart + offset
    : this.selectionEnd + offset;
    this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);
    return offset !== 0;
  },

  /**
   * Moves cursor up without shift
   * @param {Number} offset
   */
  moveCursorWithoutShift: function(offset) {
    if (offset < 0) {
      this.selectionStart += offset;
      this.selectionEnd = this.selectionStart;
    }
    else {
      this.selectionEnd += offset;
      this.selectionStart = this.selectionEnd;
    }
    return offset !== 0;
  },

  /**
   * Moves cursor left
   * @param {Event} e Event object
   */
  moveCursorLeft: function(e) {
    if (this.selectionStart === 0 && this.selectionEnd === 0) {
      return;
    }
    this._moveCursorLeftOrRight('Left', e);
  },

  /**
   * @private
   * @return {Boolean} true if a change happened
   */
  _move: function(e, prop, direction) {
    var newValue;
    if (e.altKey) {
      newValue = this['findWordBoundary' + direction](this[prop]);
    }
    else if (e.metaKey || e.keyCode === 35 ||  e.keyCode === 36 ) {
      newValue = this['findLineBoundary' + direction](this[prop]);
    }
    else {
      this[prop] += direction === 'Left' ? -1 : 1;
      return true;
    }
    if (typeof newValue !== undefined && this[prop] !== newValue) {
      this[prop] = newValue;
      return true;
    }
  },

  /**
   * @private
   */
  _moveLeft: function(e, prop) {
    return this._move(e, prop, 'Left');
  },

  /**
   * @private
   */
  _moveRight: function(e, prop) {
    return this._move(e, prop, 'Right');
  },

  /**
   * Moves cursor left without keeping selection
   * @param {Event} e
   */
  moveCursorLeftWithoutShift: function(e) {
    var change = true;
    this._selectionDirection = 'left';

    // only move cursor when there is no selection,
    // otherwise we discard it, and leave cursor on same place
    if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {
      change = this._moveLeft(e, 'selectionStart');

    }
    this.selectionEnd = this.selectionStart;
    return change;
  },

  /**
   * Moves cursor left while keeping selection
   * @param {Event} e
   */
  moveCursorLeftWithShift: function(e) {
    if (this._selectionDirection === 'right' && this.selectionStart !== this.selectionEnd) {
      return this._moveLeft(e, 'selectionEnd');
    }
    else if (this.selectionStart !== 0){
      this._selectionDirection = 'left';
      return this._moveLeft(e, 'selectionStart');
    }
  },

  /**
   * Moves cursor right
   * @param {Event} e Event object
   */
  moveCursorRight: function(e) {
    if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
      return;
    }
    this._moveCursorLeftOrRight('Right', e);
  },

  /**
   * Moves cursor right or Left, fires event
   * @param {String} direction 'Left', 'Right'
   * @param {Event} e Event object
   */
  _moveCursorLeftOrRight: function(direction, e) {
    var actionName = 'moveCursor' + direction + 'With';
    this._currentCursorOpacity = 1;

    if (e.shiftKey) {
      actionName += 'Shift';
    }
    else {
      actionName += 'outShift';
    }
    if (this[actionName](e)) {
      this.abortCursorAnimation();
      this.initDelayedCursor();
      this._fireSelectionChanged();
      this._updateTextarea();
    }
  },

  /**
   * Moves cursor right while keeping selection
   * @param {Event} e
   */
  moveCursorRightWithShift: function(e) {
    if (this._selectionDirection === 'left' && this.selectionStart !== this.selectionEnd) {
      return this._moveRight(e, 'selectionStart');
    }
    else if (this.selectionEnd !== this._text.length) {
      this._selectionDirection = 'right';
      return this._moveRight(e, 'selectionEnd');
    }
  },

  /**
   * Moves cursor right without keeping selection
   * @param {Event} e Event object
   */
  moveCursorRightWithoutShift: function(e) {
    var changed = true;
    this._selectionDirection = 'right';

    if (this.selectionStart === this.selectionEnd) {
      changed = this._moveRight(e, 'selectionStart');
      this.selectionEnd = this.selectionStart;
    }
    else {
      this.selectionStart = this.selectionEnd;
    }
    return changed;
  },

  /**
   * Removes characters selected by selection
   * @param {Event} e Event object
   */
  removeChars: function(e) {
    if (this.selectionStart === this.selectionEnd) {
      this._removeCharsNearCursor(e);
    }
    else {
      this._removeCharsFromTo(this.selectionStart, this.selectionEnd);
    }

    this.set('dirty', true);
    this.setSelectionEnd(this.selectionStart);

    this._removeExtraneousStyles();

    this.canvas && this.canvas.requestRenderAll();

    this.setCoords();
    this.fire('changed');
    this.canvas && this.canvas.fire('text:changed', { target: this });
  },

  /**
   * @private
   * @param {Event} e Event object
   */
  _removeCharsNearCursor: function(e) {
    if (this.selectionStart === 0) {
      return;
    }
    if (e.metaKey) {
      // remove all till the start of current line
      var leftLineBoundary = this.findLineBoundaryLeft(this.selectionStart);

      this._removeCharsFromTo(leftLineBoundary, this.selectionStart);
      this.setSelectionStart(leftLineBoundary);
    }
    else if (e.altKey) {
      // remove all till the start of current word
      var leftWordBoundary = this.findWordBoundaryLeft(this.selectionStart);

      this._removeCharsFromTo(leftWordBoundary, this.selectionStart);
      this.setSelectionStart(leftWordBoundary);
    }
    else {
      this._removeSingleCharAndStyle(this.selectionStart);
      this.setSelectionStart(this.selectionStart - 1);
    }
  }
});


/* _TO_SVG_START_ */
(function() {
  var toFixed = fabric.util.toFixed,
      NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;

  fabric.util.object.extend(fabric.Text.prototype, /** @lends fabric.Text.prototype */ {

    /**
     * Returns SVG representation of an instance
     * @param {Function} [reviver] Method for further parsing of svg representation.
     * @return {String} svg representation of an instance
     */
    toSVG: function(reviver) {
      var markup = this._createBaseSVGMarkup(),
          offsets = this._getSVGLeftTopOffsets(),
          textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);
      this._wrapSVGTextAndBg(markup, textAndBg);

      return reviver ? reviver(markup.join('')) : markup.join('');
    },

    /**
     * @private
     */
    _getSVGLeftTopOffsets: function() {
      return {
        textLeft: -this.width / 2,
        textTop: -this.height / 2,
        lineTop: this.getHeightOfLine(0)
      };
    },

    /**
     * @private
     */
    _wrapSVGTextAndBg: function(markup, textAndBg) {
      var noShadow = true, filter = this.getSvgFilter(),
          style = filter === '' ? '' : ' style="' + filter + '"';

      markup.push(
        '\t<g ', this.getSvgId(), 'transform="', this.getSvgTransform(), this.getSvgTransformMatrix(), '"',
          style, '>\n',
          textAndBg.textBgRects.join(''),
          '\t\t<text xml:space="preserve" ',
            (this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, '\'') + '" ' : ''),
            (this.fontSize ? 'font-size="' + this.fontSize + '" ' : ''),
            (this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : ''),
            (this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : ''),
            (this.textDecoration ? 'text-decoration="' + this.textDecoration + '" ' : ''),
            'style="', this.getSvgStyles(noShadow), '" >\n',
            textAndBg.textSpans.join(''),
          '\t\t</text>\n',
        '\t</g>\n'
      );
    },

    /**
     * @private
     * @param {Number} textTopOffset Text top offset
     * @param {Number} textLeftOffset Text left offset
     * @return {Object}
     */
    _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {
      var textSpans = [],
          textBgRects = [],
          height = textTopOffset, lineOffset;
      // bounding-box background
      this._setSVGBg(textBgRects);

      // text and text-background
      for (var i = 0, len = this._textLines.length; i < len; i++) {
        lineOffset = this._getLineLeftOffset(i);
        if (this.textBackgroundColor || this.styleHas('textBackgroundColor', i)) {
          this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);
        }
        this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);
        height += this.getHeightOfLine(i);
      }

      return {
        textSpans: textSpans,
        textBgRects: textBgRects
      };
    },

    /**
     * @private
     */
    _createTextCharSpan: function(_char, styleDecl, left, top) {
      var styleProps = this.getSvgSpanStyles(styleDecl, false),
          fillStyles = styleProps ? 'style="' + styleProps + '"' : '';

      return [
        '\t\t\t<tspan x="', toFixed(left, NUM_FRACTION_DIGITS), '" y="',
        toFixed(top, NUM_FRACTION_DIGITS), '" ',
        fillStyles, '>',
        fabric.util.string.escapeXml(_char),
        '</tspan>\n'
      ].join('');
    },

    _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {
      // set proper line offset
      var lineHeight = this.getHeightOfLine(lineIndex),
          actualStyle,
          nextStyle,
          charsToRender = '',
          charBox, style,
          boxWidth = 0,
          line = this._textLines[lineIndex],
          timeToRender;

      textTopOffset += lineHeight * (1 - this._fontSizeFraction) / this.lineHeight;
      for (var i = 0, len = line.length - 1; i <= len; i++) {
        timeToRender = i === len || this.charSpacing;
        charsToRender += line[i];
        charBox = this.__charBounds[lineIndex][i];
        if (boxWidth === 0) {
          textLeftOffset += charBox.kernedWidth - charBox.width;
        }
        boxWidth += charBox.kernedWidth;
        if (this.textAlign === 'justify' && !timeToRender) {
          if (this._reSpaceAndTab.test(line[i])) {
            timeToRender = true;
          }
        }
        if (!timeToRender) {
          // if we have charSpacing, we render char by char
          actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
          nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
          timeToRender = this._hasStyleChanged(actualStyle, nextStyle);
        }
        if (timeToRender) {
          style = this._getStyleDeclaration(lineIndex, i) || { };
          textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));
          charsToRender = '';
          actualStyle = nextStyle;
          textLeftOffset += boxWidth;
          boxWidth = 0;
        }
      }
    },

    _pushTextBgRect: function(textBgRects, color, left, top, width, height) {
      textBgRects.push(
        '\t\t<rect ',
          this._getFillAttributes(color),
          ' x="',
          toFixed(left, NUM_FRACTION_DIGITS),
          '" y="',
          toFixed(top, NUM_FRACTION_DIGITS),
          '" width="',
          toFixed(width, NUM_FRACTION_DIGITS),
          '" height="',
          toFixed(height, NUM_FRACTION_DIGITS),
        '"></rect>\n');
    },

    _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {
      var line = this._textLines[i],
          heightOfLine = this.getHeightOfLine(i) / this.lineHeight,
          boxWidth = 0,
          boxStart = 0,
          charBox, currentColor,
          lastColor = this.getValueOfPropertyAt(i, 0, 'textBackgroundColor');
      for (var j = 0, jlen = line.length; j < jlen; j++) {
        charBox = this.__charBounds[i][j];
        currentColor = this.getValueOfPropertyAt(i, j, 'textBackgroundColor');
        if (currentColor !== lastColor) {
          lastColor && this._pushTextBgRect(textBgRects, lastColor, leftOffset + boxStart,
            textTopOffset, boxWidth, heightOfLine);
          boxStart = charBox.left;
          boxWidth = charBox.width;
          lastColor = currentColor;
        }
        else {
          boxWidth += charBox.kernedWidth;
        }
      }
      currentColor && this._pushTextBgRect(textBgRects, currentColor, leftOffset + boxStart,
        textTopOffset, boxWidth, heightOfLine);
    },

    /**
     * Adobe Illustrator (at least CS5) is unable to render rgba()-based fill values
     * we work around it by "moving" alpha channel into opacity attribute and setting fill's alpha to 1
     *
     * @private
     * @param {*} value
     * @return {String}
     */
    _getFillAttributes: function(value) {
      var fillColor = (value && typeof value === 'string') ? new fabric.Color(value) : '';
      if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {
        return 'fill="' + value + '"';
      }
      return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';
    },

    /**
     * @private
     */
    _getSVGLineTopOffset: function(lineIndex) {
      var lineTopOffset = 0, lastHeight = 0;
      for (var j = 0; j < lineIndex; j++) {
        lineTopOffset += this.getHeightOfLine(j);
      }
      lastHeight = this.getHeightOfLine(j);
      return {
        lineTop: lineTopOffset,
        offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)
      };
    },

    getSvgStyles: function(skipShadow) {

      var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);
      return svgStyle + ' white-space: pre;';
    },
  });
})();
/* _TO_SVG_END_ */


(function(global) {

  'use strict';

  var fabric = global.fabric || (global.fabric = {});

  /**
   * Textbox class, based on IText, allows the user to resize the text rectangle
   * and wraps lines automatically. Textboxes have their Y scaling locked, the
   * user can only change width. Height is adjusted automatically based on the
   * wrapping of lines.
   * @class fabric.Textbox
   * @extends fabric.IText
   * @mixes fabric.Observable
   * @return {fabric.Textbox} thisArg
   * @see {@link fabric.Textbox#initialize} for constructor definition
   */
  fabric.Textbox = fabric.util.createClass(fabric.IText, fabric.Observable, {

    /**
     * Type of an object
     * @type String
     * @default
     */
    type: 'textbox',

    /**
     * Minimum width of textbox, in pixels.
     * @type Number
     * @default
     */
    minWidth: 20,

    /**
     * Minimum calculated width of a textbox, in pixels.
     * fixed to 2 so that an empty textbox cannot go to 0
     * and is still selectable without text.
     * @type Number
     * @default
     */
    dynamicMinWidth: 2,

    /**
     * Cached array of text wrapping.
     * @type Array
     */
    __cachedLines: null,

    /**
     * Override standard Object class values
     */
    lockScalingFlip: true,

    /**
     * Override standard Object class values
     * Textbox needs this on false
     */
    noScaleCache: false,

    /**
     * Constructor. Some scaling related property values are forced. Visibility
     * of controls is also fixed; only the rotation and width controls are
     * made available.
     * @param {String} text Text string
     * @param {Object} [options] Options object
     * @return {fabric.Textbox} thisArg
     */
    initialize: function(text, options) {

      this.callSuper('initialize', text, options);
      this.ctx = this.objectCaching ? this._cacheContext : fabric.util.createCanvasElement().getContext('2d');
      // add width to this list of props that effect line wrapping.
      this._dimensionAffectingProps.push('width');
    },

    /**
     * Unlike superclass's version of this function, Textbox does not update
     * its width.
     * @private
     * @override
     */
    initDimensions: function() {
      if (this.__skipDimension) {
        return;
      }
      this.isEditing && this.initDelayedCursor();
      this.clearContextTop();
      this._clearCache();
      // clear dynamicMinWidth as it will be different after we re-wrap line
      this.dynamicMinWidth = 0;
      // wrap lines
      var newText = this._splitTextIntoLines(this.text);
      this.textLines = newText.lines;
      this._textLines = newText.graphemeLines;
      this._unwrappedTextLines = newText._unwrappedLines;
      this._text = newText.graphemeText;
      this._styleMap = this._generateStyleMap(newText);
      // if after wrapping, the width is smaller than dynamicMinWidth, change the width and re-wrap
      if (this.dynamicMinWidth > this.width) {
        this._set('width', this.dynamicMinWidth);
      }
      if (this.textAlign === 'justify') {
        // once text is measured we need to make space fatter to make justified text.
        this.enlargeSpaces();
      }
      // clear cache and re-calculate height
      this.height = this.calcTextHeight();
    },

    /**
     * Generate an object that translates the style object so that it is
     * broken up by visual lines (new lines and automatic wrapping).
     * The original text styles object is broken up by actual lines (new lines only),
     * which is only sufficient for Text / IText
     * @private
     */
    _generateStyleMap: function(textInfo) {
      var realLineCount     = 0,
          realLineCharCount = 0,
          charCount         = 0,
          map               = {};

      for (var i = 0; i < textInfo.graphemeLines.length; i++) {
        if (textInfo.graphemeText[charCount] === '\n' && i > 0) {
          realLineCharCount = 0;
          charCount++;
          realLineCount++;
        }
        else if (this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i > 0) {
          // this case deals with space's that are removed from end of lines when wrapping
          realLineCharCount++;
          charCount++;
        }

        map[i] = { line: realLineCount, offset: realLineCharCount };

        charCount += textInfo.graphemeLines[i].length;
        realLineCharCount += textInfo.graphemeLines[i].length;
      }

      return map;
    },

    /**
     * Returns true if object has a style property or has it ina specified line
     * @param {Number} lineIndex
     * @return {Boolean}
     */
    styleHas: function(property, lineIndex) {
      if (this._styleMap && !this.isWrapping) {
        var map = this._styleMap[lineIndex];
        if (map) {
          lineIndex = map.line;
        }
      }
      return fabric.Text.prototype.styleHas.call(this, property, lineIndex);
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @private
     */
    _getStyleDeclaration: function(lineIndex, charIndex) {
      if (this._styleMap && !this.isWrapping) {
        var map = this._styleMap[lineIndex];
        if (!map) {
          return null;
        }
        lineIndex = map.line;
        charIndex = map.offset + charIndex;
      }
      return this.callSuper('_getStyleDeclaration', lineIndex, charIndex);
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @param {Object} style
     * @private
     */
    _setStyleDeclaration: function(lineIndex, charIndex, style) {
      var map = this._styleMap[lineIndex];
      lineIndex = map.line;
      charIndex = map.offset + charIndex;

      this.styles[lineIndex][charIndex] = style;
    },

    /**
     * @param {Number} lineIndex
     * @param {Number} charIndex
     * @private
     */
    _deleteStyleDeclaration: function(lineIndex, charIndex) {
      var map = this._styleMap[lineIndex];
      lineIndex = map.line;
      charIndex = map.offset + charIndex;

      delete this.styles[lineIndex][charIndex];
    },

    /**
     * @param {Number} lineIndex
     * @private
     */
    _getLineStyle: function(lineIndex) {
      var map = this._styleMap[lineIndex];
      return this.styles[map.line];
    },

    /**
     * @param {Number} lineIndex
     * @param {Object} style
     * @private
     */
    _setLineStyle: function(lineIndex, style) {
      var map = this._styleMap[lineIndex];
      this.styles[map.line] = style;
    },

    /**
     * @param {Number} lineIndex
     * @private
     */
    _deleteLineStyle: function(lineIndex) {
      var map = this._styleMap[lineIndex];
      delete this.styles[map.line];
    },

    /**
     * Wraps text using the 'width' property of Textbox. First this function
     * splits text on newlines, so we preserve newlines entered by the user.
     * Then it wraps each line using the width of the Textbox by calling
     * _wrapLine().
     * @param {Array} lines The string array of text that is split into lines
     * @param {Number} desiredWidth width you want to wrap to
     * @returns {Array} Array of lines
     */
    _wrapText: function(lines, desiredWidth) {
      var wrapped = [], i;
      this.isWrapping = true;
      for (i = 0; i < lines.length; i++) {
        wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));
      }
      this.isWrapping = false;
      return wrapped;
    },

    /**
     * Helper function to measure a string of text, given its lineIndex and charIndex offset
     * it gets called when charBounds are not available yet.
     * @param {CanvasRenderingContext2D} ctx
     * @param {String} text
     * @param {number} lineIndex
     * @param {number} charOffset
     * @returns {number}
     * @private
     */
    _measureWord: function(word, lineIndex, charOffset) {
      var width = 0, prevGrapheme, skipLeft = true;
      charOffset = charOffset || 0;
      for (var i = 0, len = word.length; i < len; i++) {
        var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);
        width += box.kernedWidth;
        prevGrapheme = word[i];
      }
      return width;
    },

    /**
     * Wraps a line of text using the width of the Textbox and a context.
     * @param {Array} line The grapheme array that represent the line
     * @param {Number} lineIndex
     * @param {Number} desiredWidth width you want to wrap the line to
     * @returns {Array} Array of line(s) into which the given text is wrapped
     * to.
     */
    _wrapLine: function(_line, lineIndex, desiredWidth) {
      var lineWidth        = 0,
          graphemeLines    = [],
          line             = [],
          // spaces in different languges?
          words            = _line.split(this._reSpaceAndTab),
          word             = '',
          offset           = 0,
          infix            = ' ',
          wordWidth        = 0,
          infixWidth       = 0,
          largestWordWidth = 0,
          lineJustStarted = true,
          additionalSpace = this._getWidthOfCharSpacing();
      for (var i = 0; i < words.length; i++) {
        // i would avoid resplitting the graphemes
        word = fabric.util.string.graphemeSplit(words[i]);
        wordWidth = this._measureWord(word, lineIndex, offset);
        offset += word.length;

        lineWidth += infixWidth + wordWidth - additionalSpace;

        if (lineWidth >= desiredWidth && !lineJustStarted) {
          graphemeLines.push(line);
          line = [];
          lineWidth = wordWidth;
          lineJustStarted = true;
        }

        if (!lineJustStarted) {
          line.push(infix);
        }
        line = line.concat(word);

        infixWidth = this._measureWord([infix], lineIndex, offset);
        offset++;
        lineJustStarted = false;
        // keep track of largest word
        if (wordWidth > largestWordWidth) {
          largestWordWidth = wordWidth;
        }
      }

      i && graphemeLines.push(line);

      if (largestWordWidth > this.dynamicMinWidth) {
        this.dynamicMinWidth = largestWordWidth - additionalSpace;
      }

      return graphemeLines;
    },

    /**
    * Gets lines of text to render in the Textbox. This function calculates
    * text wrapping on the fly every time it is called.
    * @param {String} text text to split
    * @returns {Array} Array of lines in the Textbox.
    * @override
    */
    _splitTextIntoLines: function(text) {
      var newText = fabric.Text.prototype._splitTextIntoLines.call(this, text),
          graphemeLines = this._wrapText(newText.lines, this.width),
          lines = new Array(graphemeLines.length);

      for (var i = 0; i < graphemeLines.length; i++) {
        lines[i] = graphemeLines[i].join('');
      }
      newText.lines = lines;
      newText.graphemeLines = graphemeLines;
      return newText;
    },

    getMinWidth: function() {
      return Math.max(this.minWidth, this.dynamicMinWidth);
    },

    /**
     * Returns object representation of an instance
     * @method toObject
     * @param {Array} [propertiesToInclude] Any properties that you might want to additionally include in the output
     * @return {Object} object representation of an instance
     */
    toObject: function(propertiesToInclude) {
      return this.callSuper('toObject', ['minWidth'].concat(propertiesToInclude));
    }
  });

  /**
   * Returns fabric.Textbox instance from an object representation
   * @static
   * @memberOf fabric.Textbox
   * @param {Object} object Object to create an instance from
   * @param {Function} [callback] Callback to invoke when an fabric.Textbox instance is created
   */
  fabric.Textbox.fromObject = function(object, callback) {
    return fabric.Object._fromObject('Textbox', object, callback, 'text');
  };
})( true ? exports : this);


(function() {

  /**
   * Override _setObjectScale and add Textbox specific resizing behavior. Resizing
   * a Textbox doesn't scale text, it only changes width and makes text wrap automatically.
   */
  var setObjectScaleOverridden = fabric.Canvas.prototype._setObjectScale;

  fabric.Canvas.prototype._setObjectScale = function(localMouse, transform,
                                                     lockScalingX, lockScalingY, by, lockScalingFlip, _dim) {

    var t = transform.target;
    if (by === 'x' && t instanceof fabric.Textbox) {
      var tw = t._getTransformedDimensions().x;
      var w = t.width * (localMouse.x / tw);
      if (w >= t.getMinWidth()) {
        t.set('width', w);
        return true;
      }
    }
    else {
      return setObjectScaleOverridden.call(fabric.Canvas.prototype, localMouse, transform,
        lockScalingX, lockScalingY, by, lockScalingFlip, _dim);
    }
  };

  fabric.util.object.extend(fabric.Textbox.prototype, /** @lends fabric.IText.prototype */ {
    /**
     * @private
     */
    _removeExtraneousStyles: function() {
      for (var prop in this._styleMap) {
        if (!this._textLines[prop]) {
          delete this.styles[this._styleMap[prop].line];
        }
      }
    },

  });
})();


(function() {

  if (typeof document !== 'undefined' && typeof window !== 'undefined') {
    return;
  }

  var DOMParser = __webpack_require__(116).DOMParser,
      URL = __webpack_require__(39),
      HTTP = __webpack_require__(40),
      HTTPS = __webpack_require__(132),

      Canvas = !(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()),
      Image = !(function webpackMissingModule() { var e = new Error("Cannot find module \".\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()).Image;

  /** @private */
  function request(url, encoding, callback) {
    var oURL = URL.parse(url);

    // detect if http or https is used
    if ( !oURL.port ) {
      oURL.port = ( oURL.protocol.indexOf('https:') === 0 ) ? 443 : 80;
    }

    // assign request handler based on protocol
    var reqHandler = (oURL.protocol.indexOf('https:') === 0 ) ? HTTPS : HTTP,
        req = reqHandler.request({
          hostname: oURL.hostname,
          port: oURL.port,
          path: oURL.path,
          method: 'GET'
        }, function(response) {
          var body = '';
          if (encoding) {
            response.setEncoding(encoding);
          }
          response.on('end', function () {
            callback(body);
          });
          response.on('data', function (chunk) {
            if (response.statusCode === 200) {
              body += chunk;
            }
          });
        });

    req.on('error', function(err) {
      if (err.errno === process.ECONNREFUSED) {
        fabric.log('ECONNREFUSED: connection refused to ' + oURL.hostname + ':' + oURL.port);
      }
      else {
        fabric.log(err.message);
      }
      callback(null);
    });

    req.end();
  }

  /** @private */
  function requestFs(path, callback) {
    var fs = __webpack_require__(133);
    fs.readFile(path, function (err, data) {
      if (err) {
        fabric.log(err);
        throw err;
      }
      else {
        callback(data);
      }
    });
  }

  fabric.util.loadImage = function(url, callback, context) {
    function createImageAndCallBack(data) {
      if (data) {
        img.src = new Buffer(data, 'binary');
        // preserving original url, which seems to be lost in node-canvas
        img._src = url;
        callback && callback.call(context, img);
      }
      else {
        img = null;
        callback && callback.call(context, null, true);
      }
    }
    var img = new Image();
    if (url && (url instanceof Buffer || url.indexOf('data') === 0)) {
      img.src = img._src = url;
      callback && callback.call(context, img);
    }
    else if (url && url.indexOf('http') !== 0) {
      requestFs(url, createImageAndCallBack);
    }
    else if (url) {
      request(url, 'binary', createImageAndCallBack);
    }
    else {
      callback && callback.call(context, url);
    }
  };

  fabric.loadSVGFromURL = function(url, callback, reviver) {
    url = url.replace(/^\n\s*/, '').replace(/\?.*$/, '').trim();
    if (url.indexOf('http') !== 0) {
      requestFs(url, function(body) {
        fabric.loadSVGFromString(body.toString(), callback, reviver);
      });
    }
    else {
      request(url, '', function(body) {
        fabric.loadSVGFromString(body, callback, reviver);
      });
    }
  };

  fabric.loadSVGFromString = function(string, callback, reviver) {
    var doc = new DOMParser().parseFromString(string);
    fabric.parseSVGDocument(doc.documentElement, function(results, options) {
      callback && callback(results, options);
    }, reviver);
  };

  fabric.util.getScript = function(url, callback) {
    request(url, '', function(body) {
      // eslint-disable-next-line no-eval
      eval(body);
      callback && callback();
    });
  };

  // fabric.util.createCanvasElement = function(_, width, height) {
  //   return new Canvas(width, height);
  // }

  /**
   * Only available when running fabric on node.js
   * @param {Number} width Canvas width
   * @param {Number} height Canvas height
   * @param {Object} [options] Options to pass to FabricCanvas.
   * @param {Object} [nodeCanvasOptions] Options to pass to NodeCanvas.
   * @return {Object} wrapped canvas instance
   */
  fabric.createCanvasForNode = function(width, height, options, nodeCanvasOptions) {
    nodeCanvasOptions = nodeCanvasOptions || options;

    var canvasEl = fabric.document.createElement('canvas'),
        nodeCanvas = new Canvas(width || 600, height || 600, nodeCanvasOptions),
        nodeCacheCanvas = new Canvas(width || 600, height || 600, nodeCanvasOptions);

    canvasEl.width = nodeCanvas.width;
    canvasEl.height = nodeCanvas.height;
    options = options || { };
    options.nodeCanvas = nodeCanvas;
    options.nodeCacheCanvas = nodeCacheCanvas;
    var FabricCanvas = fabric.Canvas || fabric.StaticCanvas,
        fabricCanvas = new FabricCanvas(canvasEl, options);
    fabricCanvas.nodeCanvas = nodeCanvas;
    fabricCanvas.nodeCacheCanvas = nodeCacheCanvas;
    fabricCanvas.contextContainer = nodeCanvas.getContext('2d');
    fabricCanvas.contextCache = nodeCacheCanvas.getContext('2d');
    fabricCanvas.Font = Canvas.Font;
    return fabricCanvas;
  };

  var originaInitStatic = fabric.StaticCanvas.prototype._initStatic;
  fabric.StaticCanvas.prototype._initStatic = function(el, options) {
    el = el || fabric.document.createElement('canvas');
    this.nodeCanvas = new Canvas(el.width, el.height);
    this.nodeCacheCanvas = new Canvas(el.width, el.height);
    originaInitStatic.call(this, el, options);
    this.contextContainer = this.nodeCanvas.getContext('2d');
    this.contextCache = this.nodeCacheCanvas.getContext('2d');
    this.Font = Canvas.Font;
  };

  /** @ignore */
  fabric.StaticCanvas.prototype.createPNGStream = function() {
    return this.nodeCanvas.createPNGStream();
  };

  fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {
    return this.nodeCanvas.createJPEGStream(opts);
  };

  fabric.StaticCanvas.prototype._initRetinaScaling = function() {
    if (!this._isRetinaScaling()) {
      return;
    }

    this.lowerCanvasEl.setAttribute('width', this.width * fabric.devicePixelRatio);
    this.lowerCanvasEl.setAttribute('height', this.height * fabric.devicePixelRatio);
    this.nodeCanvas.width = this.width * fabric.devicePixelRatio;
    this.nodeCanvas.height = this.height * fabric.devicePixelRatio;
    this.contextContainer.scale(fabric.devicePixelRatio, fabric.devicePixelRatio);
    return this;
  };
  if (fabric.Canvas) {
    fabric.Canvas.prototype._initRetinaScaling = fabric.StaticCanvas.prototype._initRetinaScaling;
  }

  var origSetBackstoreDimension = fabric.StaticCanvas.prototype._setBackstoreDimension;
  fabric.StaticCanvas.prototype._setBackstoreDimension = function(prop, value) {
    origSetBackstoreDimension.call(this, prop, value);
    this.nodeCanvas[prop] = value;
    return this;
  };
  if (fabric.Canvas) {
    fabric.Canvas.prototype._setBackstoreDimension = fabric.StaticCanvas.prototype._setBackstoreDimension;
  }

})();


/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer, __webpack_require__(4)))

/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),
/* 114 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 115 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 116 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return punycode;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(118)(module), __webpack_require__(2)))

/***/ }),
/* 118 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(121);
exports.encode = exports.stringify = __webpack_require__(122);


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer, global, process) {var capability = __webpack_require__(41)
var inherits = __webpack_require__(6)
var response = __webpack_require__(124)
var stream = __webpack_require__(42)
var toArrayBuffer = __webpack_require__(129)

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || 'timeout' in opts) {
		// If the use of XHR should be preferred and includes preserving the 'content-type' header.
		// Force XHR to be used since the Fetch API does not yet support timeouts.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
		if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin'
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('timeout' in opts) {
			xhr.timeout = opts.timeout
			xhr.ontimeout = function () {
				self.emit('timeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode)
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	// Currently, there isn't a way to truly abort a fetch.
	// If you like bikeshedding, see https://github.com/whatwg/fetch/issues/27
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'user-agent',
	'via'
]

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5).Buffer, __webpack_require__(2), __webpack_require__(4)))

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, Buffer, global) {var capability = __webpack_require__(41)
var inherits = __webpack_require__(6)
var stream = __webpack_require__(42)

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function(header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})


		// TODO: this doesn't respect backpressure. Once WritableStream is available, this can be fixed
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			}).catch(function(err) {
				self.emit('error', err)
			})
		}
		read()

	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8	
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(5).Buffer, __webpack_require__(2)))

/***/ }),
/* 125 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __webpack_require__(32).Buffer;
/*</replacement>*/

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(49);

/*<replacement>*/
var util = __webpack_require__(11);
util.inherits = __webpack_require__(6);
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(5).Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}


/***/ }),
/* 130 */
/***/ (function(module, exports) {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),
/* 131 */
/***/ (function(module, exports) {

module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

var http = __webpack_require__(40);

var https = module.exports;

for (var key in http) {
    if (http.hasOwnProperty(key)) https[key] = http[key];
};

https.request = function (params, cb) {
    if (!params) params = {};
    params.scheme = 'https';
    params.protocol = 'https:';
    return http.request.call(this, params, cb);
}


/***/ }),
/* 133 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 134 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_vm._v("\n    " + _vm._s(_vm.message) + "\n    "), _vm._m(0), _vm._v(" "), _c('br'), _vm._v(" "), _c('section', {
    staticClass: "text-center"
  }, [_c('b-button', {
    attrs: {
      "variant": "warning",
      "size": "sm"
    },
    on: {
      "click": _vm.openAccount
    }
  }, [_c('i', {
    staticClass: "icon-pin icons"
  }), _vm._v("Abrir Cuenta")])], 1), _vm._v(" "), _c('b-modal', {
    ref: "modalTable",
    attrs: {
      "id": "modalTable",
      "title": "Cuenta Mesa 1",
      "close-title": "Cerrar",
      "ok-title": "Pagar"
    },
    on: {
      "ok": _vm.submit,
      "shown": _vm.clearName
    }
  }, [_c('form', {
    on: {
      "submit": function($event) {
        $event.stopPropagation();
        $event.preventDefault();
        _vm.submit($event)
      }
    }
  }, [_c('ul', {
    staticClass: "ul-account-check"
  }, [_c('li', [_vm._v(" 1 x Entrada Sopa de Tomate")]), _vm._v(" "), _c('li', [_vm._v(" 1 x Entrada Papas Fritas")]), _vm._v(" "), _c('li', [_vm._v(" 2 x Gaseosas")]), _vm._v(" "), _c('li', [_vm._v(" 2 x Pasta Bolognesa")])])])]), _vm._v(" "), _c('b-modal', {
    ref: "openAccountModal",
    attrs: {
      "id": "openAccountModal",
      "title": "Nueva Cuenta",
      "close-title": "Cerrar",
      "ok-title": "Ir a la seleccion de Menu"
    },
    on: {
      "ok": _vm.openAccount
    }
  }, [_c('form', {
    on: {
      "submit": function($event) {
        $event.stopPropagation();
        $event.preventDefault();
        _vm.submit($event)
      }
    }
  }, [_c('div', {
    staticClass: "form-group"
  }, [_vm._v("\n                Desea abrir una nueva cuenta en esta mesa?\n            ")])])])], 1)
}
var staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', {
    staticClass: "canvas-container"
  }, [_c('canvas', {
    attrs: {
      "id": "canvasFloor"
    }
  })])
}]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-6b2909bf", esExports)
  }
}

/***/ }),
/* 135 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api_categories_json__ = __webpack_require__(136);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__api_categories_json___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__api_categories_json__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__api_dishes_json__ = __webpack_require__(137);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__api_dishes_json___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__api_dishes_json__);



function ApiService() {
    this.categories = __WEBPACK_IMPORTED_MODULE_0__api_categories_json___default.a;
    this.dishes = __WEBPACK_IMPORTED_MODULE_1__api_dishes_json___default.a;
}

/* harmony default export */ __webpack_exports__["a"] = (ApiService);

/***/ }),
/* 136 */
/***/ (function(module, exports) {

module.exports = {"data":[{"id":"1","name":"carnes"},{"id":"2","name":"ensaladas"},{"id":"3","name":"postres"},{"id":"4","name":"otros"}]}

/***/ }),
/* 137 */
/***/ (function(module, exports) {

module.exports = {"data":[{"id":"1","name":"hamburguesa","price":"5000","category":{"id":"1"}},{"id":"2","name":"pollo asado","price":"60000","category":{"id":"1"}},{"id":"3","name":"pescado frito","price":"7000","category":{"id":"1"}},{"id":"4","name":"cerdo en salsa","price":"8000","category":{"id":"1"}},{"id":"21","name":"ensalada cesar","price":"2500","category":{"id":"2"}},{"id":"22","name":"ensalada de papa","price":"3000","category":{"id":"2"}},{"id":"23","name":"ensalada con pasta","price":"1500","category":{"id":"2"}}]}

/***/ }),
/* 138 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_selector_type_script_index_0_configuration_vue__ = __webpack_require__(141);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_1a9725f8_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_configuration_vue__ = __webpack_require__(142);
var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__(139)
}
var normalizeComponent = __webpack_require__(8)
/* script */

/* template */

/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __WEBPACK_IMPORTED_MODULE_0__node_modules_vue_loader_lib_selector_type_script_index_0_configuration_vue__["a" /* default */],
  __WEBPACK_IMPORTED_MODULE_1__node_modules_vue_loader_lib_template_compiler_index_id_data_v_1a9725f8_hasScoped_false_node_modules_vue_loader_lib_selector_type_template_index_0_configuration_vue__["a" /* default */],
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "maintenance/components/configuration.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {return key !== "default" && key.substr(0, 2) !== "__"})) {console.error("named exports are not supported in *.vue files.")}
if (Component.options.functional) {console.error("[vue-loader] configuration.vue: functional components are not supported with templates, they should use render functions.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-1a9725f8", Component.options)
  } else {
    hotAPI.reload("data-v-1a9725f8", Component.options)
  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

/* harmony default export */ __webpack_exports__["a"] = (Component.exports);


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(140);
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__(7)("a15eea84", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-1a9725f8\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./configuration.vue", function() {
     var newContent = require("!!../../node_modules/css-loader/index.js!../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-1a9725f8\",\"scoped\":false,\"hasInlineConfig\":false}!../../node_modules/vue-loader/lib/selector.js?type=styles&index=0!./configuration.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(0)(undefined);
// imports


// module
exports.push([module.i, "\n.canvas-container {\n    display: flex;\n    justify-content: center;\n}\n", ""]);

// exports


/***/ }),
/* 141 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fabric__ = __webpack_require__(112);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_fabric___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_fabric__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ __webpack_exports__["a"] = ({
    props: ['tables', 'floor'],
    data() {
        return {
            message: 'Configuracion de salones',
            tableArray: [],
            table: {
                number: '',
                chairs: ''
            },
            canvas: {},
            selectedObjects: []
        }
    },
    created: function() {
        this.$on('hook:afterDestroy', function() {
            console.log('afterDestroy hook called')
        })
    },
    route: {
        deactivate: function() {
            //stop sending requests
            console.log('ddddd');
        }
    },
    mounted: function() {

        var canvas = new fabric.Canvas('canvasConfiguration', this.floor.size);
        canvas.backgroundColor = this.floor.backgroundColor;
        this.loadConfiguration(canvas, JSON.parse(JSON.stringify(this.tables)), this.floor);
        canvas.renderAll();

        this.canvas = canvas;
    },
    computed: {
    },
    components: {
    },
    methods: {
        loadConfiguration: function(canvas, tables, floor) {
            let self = this;
            let canvas_data = this.tablesConfiguration;

            tables.forEach(table => {
                if (!table.rect) {
                    table.rect = {
                        left: 50,
                        top: 50
                    }
                }
                table.rect = this.addTableRect(canvas, table.rect);
                this.tableArray.push(table);
            });

            canvas.renderAll();

            canvas.on('object:selected', function(event) {
                let objects = [];
                if (event.target) {
                    if (event.target._objects) {
                        objects = event.target._objects;
                    } else {
                        objects = [event.target];
                    }
                    self.objectsSelected(objects);
                }
            });
        },
        addTable: function(_canvas, _tableSits, _tableNumber, tablePosX, tablePosY) {
            let rect = this.createTableRect(_canvas, tablePosX || 50, tablePosY || 50);

            var tableData = {
                arrayNumber: _canvas._objects.length - 1,
                rect: rect,
                tableSits: _tableSits,
                tableNumber: _tableNumber,
                occupied: false,
                disabled: false
            };

            this.tableArray.push(tableData);
        },
        addTableRect: function(_canvas, rect) {
            var rect = new fabric.Rect(rect);
            _canvas.getObjects();
            _canvas.add(rect);
            _canvas.selection = true;
            _canvas.renderAll();
            _canvas.calcOffset();

            return rect;
        },
        createTableRect: function(_canvas, left, top) {
            var rect = new fabric.Rect({
                width: 50,
                height: 50,
                left: left,
                top: top,
                fill: 'rgb(146,99,5)'
            })

            _canvas.getObjects();
            _canvas.add(rect);
            _canvas.selection = true;
            _canvas.renderAll();
            _canvas.calcOffset();

            return rect;
        }, clearData: function() {
            this.table.number = '';
            this.table.chairs = '';
        }, objectsSelected: function(_objects) {
            let objectsData = this.tableArray.filter((ta, index) => {
                return ta.rect.active;
            })
            
            this.selectedObjects = objectsData;
        }, disableSelectedTables: function() {
            this.selectedObjects.forEach(so => {
                so.rect.set('fill', 'rgb(141,147,103)');
                so.disabled = true;
            });
            this.canvas.renderAll();
        }, enableSelectedTables: function() {
            this.selectedObjects.forEach(so => {
                so.rect.set('fill', 'rgb(146,99,5)');
                so.disabled = true;
            });
            this.canvas.renderAll();
        }, saveConfiguration: function() {
            this.$router.app.$emit('save:configuration', this.tableArray, this.floor);
            this.$root.$emit('show::modal', 'successModal');
        }
    }
});



/***/ }),
/* 142 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('div', [_vm._v("\n    " + _vm._s(_vm.message) + "\n    "), _c('div', {
    staticClass: "container"
  }, [_vm._m(0), _vm._v(" "), _c('br'), _vm._v(" "), _c('div', {
    staticClass: "text-center"
  }, [_c('div', [_c('b-button', {
    directives: [{
      name: "b-modal",
      rawName: "v-b-modal.addTableModal",
      modifiers: {
        "addTableModal": true
      }
    }],
    attrs: {
      "variant": "success",
      "size": "sm"
    }
  }, [_c('i', {
    staticClass: "icon-plus icons"
  }), _vm._v(" Agregar Mesa")]), _vm._v(" "), _c('b-button', {
    attrs: {
      "variant": "outline-error",
      "size": "sm"
    },
    on: {
      "click": _vm.disableSelectedTables
    }
  }, [_c('i', {
    staticClass: "icon-close icons"
  }), _vm._v(" Deshabilitar Mesas")]), _vm._v(" "), _c('b-button', {
    attrs: {
      "variant": "outline-success",
      "size": "sm"
    },
    on: {
      "click": _vm.enableSelectedTables
    }
  }, [_c('i', {
    staticClass: "icon-check icons"
  }), _vm._v(" Habilitar Mesas")]), _vm._v(" "), _c('b-button', {
    attrs: {
      "variant": "success",
      "size": "sm"
    },
    on: {
      "click": _vm.saveConfiguration
    }
  }, [_c('i', {
    staticClass: "icon-close icons"
  }), _vm._v(" Salvar Configuracion")])], 1)])]), _vm._v(" "), _c('b-modal', {
    ref: "addTableModal",
    attrs: {
      "id": "addTableModal",
      "title": "Agregar Mesa",
      "ok-title": "Agregar"
    },
    on: {
      "shown": _vm.clearData,
      "ok": function($event) {
        _vm.addTable(_vm.canvas, _vm.table.number, _vm.table.chairs)
      }
    }
  }, [_c('form', {
    on: {
      "submit": function($event) {
        $event.stopPropagation();
        $event.preventDefault();
        _vm.submit($event)
      }
    }
  }, [_c('div', {
    staticClass: "form-group"
  }, [_c('label', {
    attrs: {
      "for": "numeroMesa"
    }
  }, [_vm._v("Numero de Mesa")]), _vm._v(" "), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.table.number),
      expression: "table.number"
    }],
    staticClass: "form-control",
    attrs: {
      "type": "number",
      "min": "1",
      "required": ""
    },
    domProps: {
      "value": (_vm.table.number)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.table.number = $event.target.value
      }
    }
  })]), _vm._v(" "), _c('div', {
    staticClass: "form-group"
  }, [_c('label', {
    attrs: {
      "for": "sillas"
    }
  }, [_vm._v("Cantidad de Sillas")]), _vm._v(" "), _c('input', {
    directives: [{
      name: "model",
      rawName: "v-model",
      value: (_vm.table.chairs),
      expression: "table.chairs"
    }],
    staticClass: "form-control",
    attrs: {
      "type": "number",
      "required": "",
      "min": "1"
    },
    domProps: {
      "value": (_vm.table.chairs)
    },
    on: {
      "input": function($event) {
        if ($event.target.composing) { return; }
        _vm.table.chairs = $event.target.value
      }
    }
  })])])]), _vm._v(" "), _c('b-modal', {
    ref: "successModal",
    attrs: {
      "id": "successModal",
      "title": "Configuracion Guardada",
      "hide-footer": "true"
    }
  }, [_c('form', {
    on: {
      "submit": function($event) {
        $event.stopPropagation();
        $event.preventDefault();
        _vm.submit($event)
      }
    }
  }, [_c('div', {
    staticClass: "form-group"
  }, [_vm._v("\n                Configuracion Guardada con exito.\n            ")])])])], 1)
}
var staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c('section', [_c('div', {
    staticClass: "canvas-container"
  }, [_c('canvas', {
    attrs: {
      "id": "canvasConfiguration"
    }
  })])])
}]
render._withStripped = true
var esExports = { render: render, staticRenderFns: staticRenderFns }
/* harmony default export */ __webpack_exports__["a"] = (esExports);
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require("vue-hot-reload-api").rerender("data-v-1a9725f8", esExports)
  }
}

/***/ })
/******/ ]);